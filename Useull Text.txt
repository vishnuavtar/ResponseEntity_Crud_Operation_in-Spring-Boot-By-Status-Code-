

String str = "welcome";

s.o.p("input")
Scanner sc  = new Scanner(s.in);

char ch = sc.next().charAt(0);



s.o.p(toOccurence(str,ch));



staic int toOccurence(String str,char ch){

int count =0;

int a[] = new int[str.lenght()];

for(int i = 0; i<str.lenght(); i++){
a[i] = str.charAt(i);

if(a[i]==ch){

count++;
}

}

return count;


} 



Output ->> e


2




System.out.print(list.stream().max(Integer::compare).get());

table employee

name id email



RestService


input id;


employee salary


select * from employee inner join salary on employee.id=salaryid;





//package com.cyfirma.core.domain;
//
//import java.io.Serializable;
//import java.util.Date;
//import org.springframework.data.annotation.Id;
//import org.springframework.data.mongodb.core.mapping.Document;
//import org.springframework.data.mongodb.core.mapping.Field;
//
//
//
//@Document(collection = "malware_update_audit_count")
//public class MalwareUpdateAuditCount implements Serializable {
//
//	
//	/**
//	 * 
//	 */
//	private static final long serialVersionUID = 1L;
//
//	@Id
//	private String id;
//	
//	@Field("name")
//	private String name;
//	
//	@Field("modifiedBy")
//	private String modifiedBy;
//	
//	@Field("updateCount")
//	private Integer updateCount;
//	
//	private Date modifyDate;
//	
//	@Override
//	public String toString() {
//		return "MalwareUpdateAuditCount [id=" + id + ", name=" + name + ", modifyDate=" + modifyDate + ", modifiedBy="
//				+ modifiedBy + ", updateCount=" + updateCount + "]";
//	}
//
//	public MalwareUpdateAuditCount() {
//		super();
//	}
//
//	public MalwareUpdateAuditCount(String id, String name, Date modifyDate, String modifiedBy, Integer updateCount) {
//		super();
//		this.id = id;
//		this.name = name;
//		this.modifyDate = modifyDate;
//		this.modifiedBy = modifiedBy;
//		this.updateCount = updateCount;
//	}
//
//	public String getId() {
//		return id;
//	}
//
//	public void setId(String id) {
//		this.id = id;
//	}
//
//	public String getName() {
//		return name;
//	}
//
//	public void setName(String name) {
//		this.name = name;
//	}
//
//	public Date getModifyDate() {
//		return modifyDate;
//	}
//
//	public void setModifyDate(Date modifyDate) {
//		this.modifyDate = modifyDate;
//	}
//
//	public String getModifiedBy() {
//		return modifiedBy;
//	}
//
//	public void setModifiedBy(String modifiedBy) {
//		this.modifiedBy = modifiedBy;
//	}
//
//	public Integer getUpdateCount() {
//		return updateCount;
//	}
//
//	public void setUpdateCount(Integer updateCount) {
//		this.updateCount = updateCount;
//	}
//
//	public static long getSerialversionuid() {
//		return serialVersionUID;
//	}
//		
//}



package com.cyfirma.core.domain;
import java.io.Serializable;
import java.util.Date;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.Field;
 
@Document(collection = "malware_update_audit_count")
public class MalwareUpdateAuditCount implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	public static long getSerialversionuid() {
		return serialVersionUID;
	}
	@Id
	private String id;
	@Field("name")
	private String name;
	private Date modifyDate;
	@Field("modifiedBy_By")
	private String modifiedBy;

 
	@Field("update_count")
	private Integer updateCount;
 
	public MalwareUpdateAuditCount() {
		super();
	}
 
	public MalwareUpdateAuditCount(String id, String name, Date modifyDate, String modifiedBy, Integer updateCount) {
		super();
		this.id = id;
		this.name = name;
		this.modifyDate = modifyDate;
		this.modifiedBy = modifiedBy;
		this.updateCount = updateCount;
	}
 
	public String getId() {
		return id;
	}
 
	public void setId(String id) {
		this.id = id;
	}
 
	public String getName() {
		return name;
	}
 
	public void setName(String name) {
		this.name = name;
	}
 
	public Date getModifyDate() {
		return modifyDate;
	}
 
	public void setModifyDate(Date modifyDate) {
		this.modifyDate = modifyDate;
	}
 
	public String getModifiedBy() {
		return modifiedBy;
	}
 
	public void setModifiedBy(String modifiedBy) {
		this.modifiedBy = modifiedBy;
	}
 
	public Integer getUpdateCount() {
		return updateCount;
	}
 
	public void setUpdateCount(Integer updateCount) {
		this.updateCount = updateCount;
	}
 
	@Override
	public String toString() {
		return "MalwareUpdateAuditCount [id=" + id + ", name=" + name + ", modifyDate=" + modifyDate + ", modifiedBy="
				+ modifiedBy + ", updateCount=" + updateCount + "]";
	}

 
}





package com.cyfirma.core.repository;

import java.util.Date;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.mongodb.repository.MongoRepository;

import com.cyfirma.core.domain.MalwareUpdateAuditCount;

public interface MalwareUpdateCountAuditRepository extends MongoRepository<MalwareUpdateAuditCount, String> {

	Page<MalwareUpdateAuditCount> findByModifyDateBetween(Date startDate, Date endDate, Pageable pageable);

	MalwareUpdateAuditCount findByName(String name);
}




package com.cyfirma.core.service.impl;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;

import com.cyfirma.core.commons.utils.MalwareHistoryDownloadHelper;
import com.cyfirma.core.config.ApplicationProperties;
import com.cyfirma.core.config.Constants;
import com.cyfirma.core.domain.ClientThreatCorrelation;
import com.cyfirma.core.domain.Malware;
import com.cyfirma.core.domain.MalwareIOC;
import com.cyfirma.core.domain.MalwareUpdateAuditCount;
import com.cyfirma.core.domain.ThreatIOC;
import com.cyfirma.core.domain.stix.v2_1.MalwareStix21;
import com.cyfirma.core.domain.stix.v2_1.STIX2Objects;
import com.cyfirma.core.integration.alienvault.AlienVaultEngine;
import com.cyfirma.core.integration.alienvault.Indicator;
import com.cyfirma.core.integration.alienvault.MalwarePage;
import com.cyfirma.core.integration.alienvault.Pulse;
import com.cyfirma.core.integration.alienvault.PulsePage;
import com.cyfirma.core.integration.malwarebazaar.FeedEntry;
import com.cyfirma.core.integration.malwarebazaar.MalwareBazaarEngine;
import com.cyfirma.core.repository.ClientThreatCorrelationRepository;
import com.cyfirma.core.repository.MalwareIOCRepository;
import com.cyfirma.core.repository.MalwareRepository;
import com.cyfirma.core.repository.MalwareUpdateCountAuditRepository;
import com.cyfirma.core.service.MalwareService;
import com.cyfirma.core.service.MasterDataService;
import com.cyfirma.core.service.PaidAPIMetricsService;
import com.cyfirma.core.service.ThreatIOCService;
import com.cyfirma.core.service.dto.MalwareDTO;
import com.cyfirma.core.service.dto.MalwareIOCAttribute;
import com.cyfirma.core.service.dto.MalwareIOCProperty;
import com.cyfirma.core.service.mapper.MalwareMapper;
import com.cyfirma.core.service.portal.community.BaseService;

/**
 * @author satya.prakash
 *
 */
@Service
public class MalwareServiceImpl extends BaseService implements MalwareService {

	private final Logger log = LoggerFactory.getLogger(MalwareServiceImpl.class);

	private final MalwareRepository malwareRepository;
	private final MalwareMapper malwareMapper;
	@Autowired
	private MasterDataService masterDataService;
	@Autowired
	private ApplicationProperties applicationProperties;
	@Autowired
	private PaidAPIMetricsService paidAPIMetricsService;
	@Autowired
	private ThreatIOCService threatIOCService;
	@Autowired
	private MalwareIOCRepository malwareIOCRepository;

	@Autowired
	private MalwareUpdateCountAuditRepository malwareUpdateCountAuditRepository;
	@Autowired
	private ClientThreatCorrelationRepository clientThreatCorrelationRepository;
	@Autowired
	private STIX2Objects stix2Objects;

	public MalwareServiceImpl(MalwareRepository malwareRepository, MalwareMapper malwareMapper) {
		this.malwareRepository = malwareRepository;
		this.malwareMapper = malwareMapper;
	}

	/**
	 * Save a malware.
	 *
	 * @param malwareDTO the entity to save
	 * @return the persisted entity
	 */
	@Override
	public MalwareDTO save(MalwareDTO malwareDTO) {
		log.debug("Request to save Malware : {}", malwareDTO);
		Malware malware = null;
		List<Malware> malwares = malwareRepository.findAllByNameIgnoreCase(malwareDTO.getName());
		if (CollectionUtils.isEmpty(malwares)) {
			malware = malwareRepository.save(malwareMapper.toEntity(malwareDTO));
		} else {
			Malware m = malwares.get(0);
			if (StringUtils.hasText(malwareDTO.getName()))
				m.setName(malwareDTO.getName().trim());
			if (!CollectionUtils.isEmpty(malwareDTO.getAliases()))
				m.setAliases(malwareDTO.getAliases());
			if (StringUtils.hasText(malwareDTO.getGroup()))
				m.setGroup(malwareDTO.getGroup());
			if (StringUtils.hasText(malwareDTO.getType()))
				m.setType(malwareDTO.getType());
			if (StringUtils.hasText(malwareDTO.getDescription()))
				m.setDescription(malwareDTO.getDescription());
			if (StringUtils.hasText(malwareDTO.getDetailedDescription()))
				m.setDetailedDescription(malwareDTO.getDetailedDescription());
			if (malwareDTO.getDetailDescriptionModified() != null)
				m.setDetailDescriptionModified(malwareDTO.getDetailDescriptionModified());
			if (malwareDTO.getFirstSeen() != null)
				m.setFirstSeen(malwareDTO.getFirstSeen());
			if (malwareDTO.getLastSeen() != null)
				m.setLastSeen(malwareDTO.getLastSeen());
			if (malwareDTO.getRiskRating() != null)
				m.setRiskRating(malwareDTO.getRiskRating());
			if (malwareDTO.getRecommendations() != null)
				m.setRecommendations(malwareDTO.getRecommendations());
			if (!CollectionUtils.isEmpty(malwareDTO.getUrl()))
				m.setUrl(malwareDTO.getUrl());
			if (!CollectionUtils.isEmpty(malwareDTO.getSourceName()))
				m.setSourceName(malwareDTO.getSourceName());
			if (!CollectionUtils.isEmpty(malwareDTO.getExternalId()))
				m.setExternalId(malwareDTO.getExternalId());
			if (!CollectionUtils.isEmpty(malwareDTO.getIndustry()))
				m.setIndustry(malwareDTO.getIndustry());
			if (!CollectionUtils.isEmpty(malwareDTO.getThreatActor()))
				m.setThreatActor(malwareDTO.getThreatActor());
			if (!CollectionUtils.isEmpty(malwareDTO.getTtps()))
				m.setTtps(malwareDTO.getTtps());
			if (!CollectionUtils.isEmpty(malwareDTO.getFeatures()))
				m.setFeatures(malwareDTO.getFeatures());
			if (!CollectionUtils.isEmpty(malwareDTO.getIoc()))
				m.setIoc(malwareDTO.getIoc());
			if (!CollectionUtils.isEmpty(malwareDTO.getIndustries()))
				m.setIndustries(malwareDTO.getIndustries());
			// if(!CollectionUtils.isEmpty(malwareDTO.getTechnologies()))
			// m.setTechnologies(malwareDTO.getTechnologies());
			if (!CollectionUtils.isEmpty(malwareDTO.getGeographies()))
				m.setGeographies(malwareDTO.getGeographies());
			if (!CollectionUtils.isEmpty(malwareDTO.getIocs()))
				m.setIoc(malwareDTO.getIoc());
			if (!CollectionUtils.isEmpty(malwareDTO.getThreatActors()))
				m.setThreatActors(malwareDTO.getThreatActors());
			m.setAssociatedCampaigns(malwareDTO.getAssociatedCampaigns());
			if (!CollectionUtils.isEmpty(malwareDTO.getMalwareVariants()))
				m.setMalwareVariants(malwareDTO.getMalwareVariants());
			if (!CollectionUtils.isEmpty(malwareDTO.getAssets()))
				m.setAssets(malwareDTO.getAssets());
			m.setModified(LocalDate.now());
			m.setTechnologies(malwareDTO.getTechnologies());
			malware = malwareRepository.save(m);
			MalwareUpdateAuditCount malwareUpdateAuditCount = malwareUpdateCountAuditRepository.findByName(m.getName());
			Integer updateCount = 1;

			if (malwareUpdateAuditCount != null) {
			    updateCount = malwareUpdateAuditCount.getUpdateCount() + 1;
			    malwareUpdateAuditCount.setModifyDate(new Date());
			    malwareUpdateAuditCount.setModifiedBy(m.getModifiedBy());
			} else if (m != null && m.getName() != null && m.getModifiedBy() != null) {
			    malwareUpdateAuditCount = new MalwareUpdateAuditCount();
			    malwareUpdateAuditCount.setName(m.getName());
			    malwareUpdateAuditCount.setModifyDate(new Date());
			    malwareUpdateAuditCount.setModifiedBy(m.getModifiedBy());
			    malwareUpdateCountAuditRepository.save(malwareUpdateAuditCount);
			}

			if (malwareUpdateAuditCount != null) {
			    malwareUpdateAuditCount.setUpdateCount(updateCount);
			    malwareUpdateCountAuditRepository.save(malwareUpdateAuditCount);
			} else {
				malwareUpdateAuditCount = new MalwareUpdateAuditCount();
			    malwareUpdateAuditCount.setId(malware.getId());
			    malwareUpdateAuditCount.setName(malware.getName());
			    malwareUpdateAuditCount.setModifyDate(new Date());
			    malwareUpdateAuditCount.setModifiedBy(malware.getModifiedBy());
			}
			malwareUpdateAuditCount.setUpdateCount(updateCount);
			malwareUpdateCountAuditRepository.save(malwareUpdateAuditCount);
		}
	
		try {
			masterDataService.refreshMasterData(Constants.THREAT_VIEW.TYPE.MALWARE, malware, null, null);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return malwareMapper.toDto(malware);
	}

	@Override
	public MalwareIOC saveMalwareIOC(MalwareIOC malwareIOC) {
		MalwareIOC existingMalwareIOC = null;
		try {
			if (malwareIOC != null && StringUtils.hasText(malwareIOC.getIndicatorType())) {
				String indicatorType = getIndicatorType(malwareIOC.getIndicatorType());
				if (StringUtils.hasText(indicatorType))
					return null;

				List<MalwareIOC> malwareIOCs = getMalwareIOC(indicatorType, malwareIOC);

				if (!CollectionUtils.isEmpty(malwareIOCs)) {
					existingMalwareIOC = malwareIOCs.get(0);
					log.debug("Existing Threat IOC - {}", malwareIOC);
				}

				if (existingMalwareIOC == null)
					existingMalwareIOC = new MalwareIOC();
				else {
					if (StringUtils.hasText(malwareIOC.getThreatActorId())
							&& StringUtils.hasText(existingMalwareIOC.getThreatActorId())
							&& existingMalwareIOC.getThreatActorId().equalsIgnoreCase(malwareIOC.getThreatActorId())
							&& existingMalwareIOC.getLastSeen() != null) {
						if (existingMalwareIOC.getLastSeen().toInstant()
								.isAfter(new Date(System.currentTimeMillis() - 1000 * 60 * 60 * 24 * 30).toInstant())) {
							return existingMalwareIOC;
						}
					}
				}

				if (StringUtils.hasText(existingMalwareIOC.getIndicatorType())) {
					existingMalwareIOC.setIndicatorType(indicatorType);
				}

				if (StringUtils.hasText(malwareIOC.getValue()))
					existingMalwareIOC.setValue(malwareIOC.getValue());
				if (StringUtils.hasText(malwareIOC.getFullValue()))
					existingMalwareIOC.setFullValue(malwareIOC.getFullValue());
				if (StringUtils.hasText(malwareIOC.getMd5Hash()))
					existingMalwareIOC.setMd5Hash(malwareIOC.getMd5Hash());
				if (StringUtils.hasText(malwareIOC.getSha1Hash()))
					existingMalwareIOC.setSha1Hash(malwareIOC.getSha1Hash());
				if (StringUtils.hasText(malwareIOC.getSha256Hash()))
					existingMalwareIOC.setSha256Hash(malwareIOC.getSha256Hash());
				if (StringUtils.hasText(malwareIOC.getFileName()))
					existingMalwareIOC.setFileName(malwareIOC.getFileName());
				if (StringUtils.hasText(malwareIOC.getCategory()))
					existingMalwareIOC.setCategory(malwareIOC.getCategory());
				if (StringUtils.hasText(malwareIOC.getRecommendedAction()))
					existingMalwareIOC.setRecommendedAction(malwareIOC.getRecommendedAction());
				if (StringUtils.hasText(malwareIOC.getDescription()))
					existingMalwareIOC.setDescription(malwareIOC.getDescription());
				if (StringUtils.hasText(malwareIOC.getEid()))
					existingMalwareIOC.setEid(malwareIOC.getEid());
				if (StringUtils.hasText(malwareIOC.getRole()))
					existingMalwareIOC.setRole(malwareIOC.getRole());
				if (StringUtils.hasText(malwareIOC.getThreatActorId()))
					existingMalwareIOC.setThreatActorId(malwareIOC.getThreatActorId());
				if (StringUtils.hasText(malwareIOC.getThreatActorName())) {
					if (StringUtils.hasText(existingMalwareIOC.getThreatActorName())) {
						existingMalwareIOC.getTags().add(existingMalwareIOC.getThreatActorName());
					}
					existingMalwareIOC.getTags().add(malwareIOC.getThreatActorName());
					existingMalwareIOC.setThreatActorName(malwareIOC.getThreatActorName());
				}
				if (StringUtils.hasText(malwareIOC.getUid()))
					existingMalwareIOC.setUid(malwareIOC.getUid());

				if (!CollectionUtils.isEmpty(malwareIOC.getClientName())) {
					existingMalwareIOC.addClientUIDs(new ArrayList<String>(malwareIOC.getClientName()).get(0),
							malwareIOC.getUid());
				}

				if (!CollectionUtils.isEmpty(malwareIOC.getTags()))
					existingMalwareIOC.getTags().addAll(malwareIOC.getTags());
				if (StringUtils.hasText(malwareIOC.getThreatScore()))
					existingMalwareIOC.setThreatScore(malwareIOC.getThreatScore());
				if (StringUtils.hasText(malwareIOC.getCountryName()))
					existingMalwareIOC.setCountryName(malwareIOC.getCountryName());
				if (StringUtils.hasText(malwareIOC.getCountryCode()))
					existingMalwareIOC.setCountryCode(malwareIOC.getCountryCode());
				if (StringUtils.hasText(malwareIOC.getSource()))
					existingMalwareIOC.setSource(malwareIOC.getSource());
				if (malwareIOC.getFirstSeen() != null) {
					if (existingMalwareIOC.getFirstSeen() == null) {
						existingMalwareIOC.setFirstSeen(malwareIOC.getFirstSeen());
					} else if (malwareIOC.getFirstSeen().toInstant()
							.isBefore(existingMalwareIOC.getFirstSeen().toInstant()))
						existingMalwareIOC.setFirstSeen(malwareIOC.getFirstSeen());
				}
				if (malwareIOC.getLastSeen() != null) {
					if (existingMalwareIOC.getLastSeen() == null) {
						existingMalwareIOC.setLastSeen(malwareIOC.getLastSeen());
					} else if (malwareIOC.getLastSeen().toInstant()
							.isAfter(existingMalwareIOC.getLastSeen().toInstant()))
						existingMalwareIOC.setLastSeen(malwareIOC.getLastSeen());
				}

				if (malwareIOC.getPopularity() != null)
					existingMalwareIOC.setPopularity(malwareIOC.getPopularity());
				if (!CollectionUtils.isEmpty(malwareIOC.getClientName()))
					existingMalwareIOC.getClientName().addAll(malwareIOC.getClientName());

				Malware malware = null;
				if (StringUtils.hasText(existingMalwareIOC.getMalwareId())
						&& StringUtils.hasText(malwareIOC.getMalwareId())
						&& !existingMalwareIOC.getMalwareId().equalsIgnoreCase(malwareIOC.getMalwareId())) {
					malware = malwareRepository.findById(malwareIOC.getMalwareId()).get();
				} else if (StringUtils.hasText(malwareIOC.getMalwareId())) {
					malware = malwareRepository.findById(malwareIOC.getMalwareId()).get();
				}
				if (malware != null) {
					if (StringUtils.hasText(malware.getId()))
						existingMalwareIOC.setMalwareId(malware.getId());
				}
				if (existingMalwareIOC.getLastSeen() == null && existingMalwareIOC.getFirstSeen() != null)
					existingMalwareIOC.setLastSeen(existingMalwareIOC.getFirstSeen());
				if (existingMalwareIOC.getFirstSeen() == null && existingMalwareIOC.getLastSeen() != null)
					existingMalwareIOC.firstSeen(existingMalwareIOC.getLastSeen());

				if (existingMalwareIOC.getFirstSeen() != null && existingMalwareIOC.getLastSeen() != null
						&& existingMalwareIOC.getFirstSeen().toInstant()
								.isAfter(existingMalwareIOC.getLastSeen().toInstant())) {
					existingMalwareIOC.setLastSeen(existingMalwareIOC.getFirstSeen());
				}

				if (StringUtils.hasText(existingMalwareIOC.getValue()))
					existingMalwareIOC.setValue(existingMalwareIOC.getValue().replace("[.]", ".").replace("[:]", ":"));

				if (!CollectionUtils.isEmpty(existingMalwareIOC.getClientName())
						|| !CollectionUtils.isEmpty(existingMalwareIOC.getClientUIDs())) {
					existingMalwareIOC.setCyfirmaIOC(true);
				}

				if (existingMalwareIOC.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.FileHash)) {
					if (StringUtils.hasText(existingMalwareIOC.getValue())) {
						if (StringUtils.hasText(existingMalwareIOC.getMd5Hash())
								&& existingMalwareIOC.getValue().equalsIgnoreCase(existingMalwareIOC.getMd5Hash())) {
							existingMalwareIOC.setValue(null);
						} else if (StringUtils.hasText(existingMalwareIOC.getSha1Hash())
								&& existingMalwareIOC.getValue().equalsIgnoreCase(existingMalwareIOC.getSha1Hash())) {
							existingMalwareIOC.setValue(null);
						} else if (StringUtils.hasText(existingMalwareIOC.getSha256Hash())
								&& existingMalwareIOC.getValue().equalsIgnoreCase(existingMalwareIOC.getSha256Hash())) {
							existingMalwareIOC.setValue(null);
						}
					}
					if (StringUtils.hasText(existingMalwareIOC.getFileName())) {
						if (StringUtils.hasText(existingMalwareIOC.getMd5Hash())
								&& existingMalwareIOC.getFileName().equalsIgnoreCase(existingMalwareIOC.getMd5Hash())) {
							existingMalwareIOC.setFileName(null);
						} else if (StringUtils.hasText(existingMalwareIOC.getSha1Hash()) && existingMalwareIOC
								.getFileName().equalsIgnoreCase(existingMalwareIOC.getSha1Hash())) {
							existingMalwareIOC.setFileName(null);
						} else if (StringUtils.hasText(existingMalwareIOC.getSha256Hash()) && existingMalwareIOC
								.getFileName().equalsIgnoreCase(existingMalwareIOC.getSha256Hash())) {
							existingMalwareIOC.setFileName(null);
						}
					}
					if (StringUtils.hasText(existingMalwareIOC.getValue())
							&& StringUtils.hasText(existingMalwareIOC.getFileName())) {
						existingMalwareIOC.setValue(existingMalwareIOC.getFileName());
					}
				}

				existingMalwareIOC.setLastSeen(new Date());
				existingMalwareIOC.setFieldsToNUll();
				existingMalwareIOC = malwareIOCRepository.save(existingMalwareIOC);

				if (existingMalwareIOC != null && malware != null) {
					malware.setLastSeen(new Date());
					if (malware.getUpdateCount() == null)
						malware.setUpdateCount(1);
					else
						malware.setUpdateCount(malware.getUpdateCount() + 1);
					malwareRepository.save(malware);
				}
			}
		} catch (Exception ex) {
			log.error("Error while saving threat ioc : error : " + ex.getMessage());
			ex.printStackTrace();
		}
		return existingMalwareIOC;
	}

	@Override
	public List<MalwareIOC> getMalwareIOC(String indicatorType, MalwareIOC malwareIOC) {
		List<MalwareIOC> malwareIOCs = null;
		if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.FileHash)) {
			if (StringUtils.hasText(malwareIOC.getMd5Hash()))
				malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndMd5Hash(Constants.IOCIndicatorType.FileHash,
						malwareIOC.getMd5Hash().toLowerCase());
			if (CollectionUtils.isEmpty(malwareIOCs) && StringUtils.hasText(malwareIOC.getSha1Hash()))
				malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndSha1Hash(Constants.IOCIndicatorType.FileHash,
						malwareIOC.getSha1Hash().toLowerCase());
			if (CollectionUtils.isEmpty(malwareIOCs) && StringUtils.hasText(malwareIOC.getSha256Hash()))
				malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndSha256Hash(Constants.IOCIndicatorType.FileHash,
						malwareIOC.getSha256Hash().toLowerCase());
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.IP)) {
			malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.IP,
					malwareIOC.getValue());
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Domain)) {
			if (!StringUtils.hasText(malwareIOC.getFullValue()))
				malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.Domain,
						malwareIOC.getValue().toLowerCase());
			else {
				List<MalwareIOC> malwareIOCsTemp = malwareIOCRepository.findByIndicatorTypeAndValue(
						Constants.IOCIndicatorType.Domain,
						malwareIOC.getFullValue().toLowerCase().substring(0, 128).trim());
				if (!CollectionUtils.isEmpty(malwareIOCsTemp)) {
					for (MalwareIOC temp : malwareIOCsTemp) {
						if (temp != null && StringUtils.hasText(temp.getFullValue())
								&& temp.getFullValue().equalsIgnoreCase(malwareIOC.getFullValue())) {
							malwareIOCs = new ArrayList<MalwareIOC>();
							malwareIOCs.add(temp);
							break;
						}
					}
				}
			}
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.URL)) {
			if (!StringUtils.hasText(malwareIOC.getFullValue()))
				malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.URL,
						malwareIOC.getValue().toLowerCase());
			else {
				List<MalwareIOC> malwareIOCsTemp = malwareIOCRepository.findByIndicatorTypeAndValue(
						Constants.IOCIndicatorType.URL,
						malwareIOC.getFullValue().toLowerCase().substring(0, 128).trim());
				if (!CollectionUtils.isEmpty(malwareIOCsTemp)) {
					for (MalwareIOC temp : malwareIOCsTemp) {
						if (temp != null && StringUtils.hasText(temp.getFullValue())
								&& temp.getFullValue().equalsIgnoreCase(malwareIOC.getFullValue())) {
							malwareIOCs = new ArrayList<MalwareIOC>();
							malwareIOCs.add(temp);
							break;
						}
					}
				}
			}
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Hostname)) {
			if (!StringUtils.hasText(malwareIOC.getFullValue()))
				malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.Hostname,
						malwareIOC.getValue().toLowerCase());
			else {
				List<MalwareIOC> malwareIOCsTemp = malwareIOCRepository.findByIndicatorTypeAndValue(
						Constants.IOCIndicatorType.Hostname,
						malwareIOC.getFullValue().toLowerCase().substring(0, 128).trim());
				if (!CollectionUtils.isEmpty(malwareIOCsTemp)) {
					for (MalwareIOC temp : malwareIOCsTemp) {
						if (temp != null && StringUtils.hasText(temp.getFullValue())
								&& temp.getFullValue().equalsIgnoreCase(malwareIOC.getFullValue())) {
							malwareIOCs = new ArrayList<MalwareIOC>();
							malwareIOCs.add(temp);
							break;
						}
					}
				}
			}
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Files)) {
			malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValueIgnoreCase(Constants.IOCIndicatorType.Files,
					malwareIOC.getValue());
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.SSL)) {
			if (!StringUtils.hasText(malwareIOC.getFullValue()))
				malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.SSL,
						malwareIOC.getValue().toLowerCase());
			else {
				List<MalwareIOC> malwareIOCsTemp = malwareIOCRepository.findByIndicatorTypeAndValue(
						Constants.IOCIndicatorType.SSL,
						malwareIOC.getFullValue().toLowerCase().substring(0, 128).trim());
				if (!CollectionUtils.isEmpty(malwareIOCsTemp)) {
					for (MalwareIOC temp : malwareIOCsTemp) {
						if (temp != null && StringUtils.hasText(temp.getFullValue())
								&& temp.getFullValue().equalsIgnoreCase(malwareIOC.getFullValue())) {
							malwareIOCs = new ArrayList<MalwareIOC>();
							malwareIOCs.add(temp);
							break;
						}
					}
				}
			}
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.CVE)) {
			malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValueIgnoreCase(Constants.IOCIndicatorType.CVE,
					malwareIOC.getValue());
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Mutex)) {
			if (!StringUtils.hasText(malwareIOC.getFullValue()))
				malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.Mutex,
						malwareIOC.getValue().toLowerCase());
			else {
				List<MalwareIOC> malwareIOCsTemp = malwareIOCRepository.findByIndicatorTypeAndValue(
						Constants.IOCIndicatorType.Mutex,
						malwareIOC.getFullValue().toLowerCase().substring(0, 128).trim());
				if (!CollectionUtils.isEmpty(malwareIOCsTemp)) {
					for (MalwareIOC temp : malwareIOCsTemp) {
						if (temp != null && StringUtils.hasText(temp.getFullValue())
								&& temp.getFullValue().equalsIgnoreCase(malwareIOC.getFullValue())) {
							malwareIOCs = new ArrayList<MalwareIOC>();
							malwareIOCs.add(temp);
							break;
						}
					}
				}
			}
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Email)) {
			if (!StringUtils.hasText(malwareIOC.getFullValue()))
				malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.Email,
						malwareIOC.getValue().toLowerCase());
			else {
				List<MalwareIOC> malwareIOCsTemp = malwareIOCRepository.findByIndicatorTypeAndValue(
						Constants.IOCIndicatorType.Email,
						malwareIOC.getFullValue().toLowerCase().substring(0, 128).trim());
				if (!CollectionUtils.isEmpty(malwareIOCsTemp)) {
					for (MalwareIOC temp : malwareIOCsTemp) {
						if (temp != null && StringUtils.hasText(temp.getFullValue())
								&& temp.getFullValue().equalsIgnoreCase(malwareIOC.getFullValue())) {
							malwareIOCs = new ArrayList<MalwareIOC>();
							malwareIOCs.add(temp);
							break;
						}
					}
				}
			}
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Exploit)) {
			if (!StringUtils.hasText(malwareIOC.getFullValue()))
				malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.Exploit,
						malwareIOC.getValue().toLowerCase());
			else {
				List<MalwareIOC> malwareIOCsTemp = malwareIOCRepository.findByIndicatorTypeAndValue(
						Constants.IOCIndicatorType.Exploit,
						malwareIOC.getFullValue().toLowerCase().substring(0, 128).trim());
				if (!CollectionUtils.isEmpty(malwareIOCsTemp)) {
					for (MalwareIOC temp : malwareIOCsTemp) {
						if (temp != null && StringUtils.hasText(temp.getFullValue())
								&& temp.getFullValue().equalsIgnoreCase(malwareIOC.getFullValue())) {
							malwareIOCs = new ArrayList<MalwareIOC>();
							malwareIOCs.add(temp);
							break;
						}
					}
				}
			}
		}

		return malwareIOCs;
	}

	/**
	 * Get all the malwares.
	 *
	 * @param pageable the pagination information
	 * @return the list of entities
	 */
	@Override
	public Page<MalwareDTO> findAll(Pageable pageable) {
		log.debug("Request to get all Malwares");
		return malwareRepository.findAll(pageable).map(malwareMapper::toDto);
	}

	@Override
	public Set<String> findAllMalwareNames() {
		log.debug("Request to get all Malwares Names");
		Set<String> malwares = new LinkedHashSet<String>();
		malwareRepository.findAll().forEach(malware -> {
			// if(!CollectionUtils.isEmpty(malware.getAliases())) {
			// malware.getAliases().forEach(a->{
			// malwares.add(a.toLowerCase());
			// });
			// }
			malwares.add(malware.getName().toLowerCase());
		});
		return malwares;
	}

	@Override
	public Set<String> findAllMalwareIndustryNames() {
		log.debug("Request to get all Malwares Industry Names");
		Set<String> industries = new LinkedHashSet<String>();
		malwareRepository.findAll().forEach(malware -> {
			if (malware != null && !CollectionUtils.isEmpty(malware.getIndustries()))
				industries.addAll(malware.getIndustries());
		});
		return industries;
	}

	/**
	 * Get one malware by id.
	 *
	 * @param id the id of the entity
	 * @return the entity
	 */
	@Override
	public MalwareDTO findById(String id) {
		log.debug("Request to get Malware : {}", id);
		Optional<Malware> malware = malwareRepository.findById(id);
		if (malware.isPresent())
			return malwareMapper.toDto(malware.get());
		else
			return null;
	}

	/**
	 * Delete the malware by id.
	 *
	 * @param id the id of the entity
	 */
	@Override
	public void delete(String id) {
		log.debug("Request to delete Malware : {}", id);
		malwareRepository.deleteById(id);
	}

	@Override
	public Page<MalwareDTO> findAllByName(String name, Pageable pageable) {
		return malwareRepository.findAllByNameContainingIgnoreCaseOrAliasesRegex(name, "^(?i)" + name, pageable)
				.map(malwareMapper::toDto);
		// return
		// malwareRepository.findAllByNameContainingIgnoreCaseOrAliasesContainingIgnoreCase(name,
		// name, pageable).map(malwareMapper::toDto);
	}

	/**
	 * output Map for matching malware and threat actor from malware list
	 */
	@Override
	public List<Map<String, String>> malwareListMatching(List<String> malwareNames) {
		List<Map<String, String>> result = new ArrayList<Map<String, String>>();
		if (!CollectionUtils.isEmpty(malwareNames)) {
			Set<String> existingMalwraeNames = findAllMalwareNames();
			if (!CollectionUtils.isEmpty(existingMalwraeNames)) {
				for (String existingMalware : existingMalwraeNames) {
					if (StringUtils.hasText(existingMalware)) {
						if (malwareNames.contains(existingMalware.toLowerCase())
								|| malwareNames.contains(existingMalware.toUpperCase())
								|| malwareNames.contains(existingMalware)) {
							// Map<String,String> entiry = new HashMap<String,String>();
							List<Malware> malwares1 = malwareRepository.findAllByNameContainingIgnoreCaseOrAliasesRegex(
									existingMalware, "^(?i)" + existingMalware);
							List<Malware> malwares2 = malwareRepository.findAllByNameIgnoreCase(existingMalware);
							List<Malware> malwares3 = malwareRepository
									.findAllByAliasesIgnoreCaseIn(new HashSet<String>(Arrays.asList(existingMalware
											+ "," + existingMalware.toLowerCase() + "," + existingMalware.toUpperCase()
											+ "," + StringUtils.capitalize(existingMalware).split(","))));
							List<Malware> malwares = new ArrayList<Malware>();
							if (!CollectionUtils.isEmpty(malwares1))
								malwares.addAll(new HashSet<Malware>(malwares1));
							if (!CollectionUtils.isEmpty(malwares2))
								malwares.addAll(new HashSet<Malware>(malwares2));
							if (!CollectionUtils.isEmpty(malwares3))
								malwares.addAll(new HashSet<Malware>(malwares3));

//							if(!CollectionUtils.isEmpty(malwares) && malwares.get(0)!=null && !CollectionUtils.isEmpty(malwares.get(0).getThreatActor())) {
//								entiry.put(existingMalware, new ArrayList<String>(malwares.get(0).getThreatActor()).get(0));
//								result.add(entiry);
//							} else {
//								log.debug("Malware {}  and Threat Actors : {}",existingMalware, malwares.get(0).getThreatActor());
//								entiry.put(existingMalware, "no-threat-actor");
//								result.add(entiry);
//							}

						}
					}
				}
			}
		}

		return result;
	}

	@Override
	public void updateFromAlienVaultMalwareList() {
		try {
			AlienVaultEngine ave = AlienVaultEngine.config(applicationProperties.getCore().getAlienvaultkey(),
					paidAPIMetricsService);
			int i = 0;
			for (int pageNo = 35; pageNo < 50; pageNo++) {
				MalwarePage malwarePage = ave.malwareSearchByCuckooCountDesc("", "", pageNo);
				if (malwarePage != null && !CollectionUtils.isEmpty(malwarePage.getResults())) {
					Set<Malware> malwareSet = new HashSet<Malware>();
					for (com.cyfirma.core.integration.alienvault.Malware malware : malwarePage.getResults()) {
						if (malware != null && StringUtils.hasText(malware.getName())) {
							String name = malware.getName().substring(malware.getName().indexOf("/") + 1,
									malware.getName().length());
							Malware m = new Malware();
							m.setType(malware.getCategory());
							m.setName(name);
							m.addAliases(malware.getName().substring(malware.getName().indexOf(":") + 1,
									malware.getName().length()));
							malwareSet.add(m);
						}
					}
					if (!CollectionUtils.isEmpty(malwareSet)) {
						for (Malware m : malwareSet) {
							if (m != null && StringUtils.hasText(m.getName())) {
								List<Malware> mList = malwareRepository
										.findAllByNameContainingIgnoreCaseOrAliasesRegex(m.getName(), m.getName());
								if (CollectionUtils.isEmpty(mList)) {
									malwareRepository.save(m);
									try {
										masterDataService.refreshMasterData(Constants.THREAT_VIEW.TYPE.MALWARE, m, null,
												null);
									} catch (Exception e) {
										e.printStackTrace();
									}
									i++;
								}
							}
						}
					}
				}
				log.info(
						"Alient valut api called for Malwar Search on Page No: {}, and total record to be inserted in db is: {} ",
						pageNo, i);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Scheduled(fixedDelay = 1000 * 111 * 222 * 3, initialDelay = 1000 * 63 * 94)
	@Override
	public void updateFromAlienVaultMalwareIOC() {
		if (!applicationProperties.getCore().getIocUpdateSchedulerRun()
				|| !applicationProperties.getCore().getServerurl().contains(Constants.ServerUrls.PROD))
			return;

		try {
			AlienVaultEngine ave = AlienVaultEngine.config(applicationProperties.getCore().getAlienvaultkey(),
					paidAPIMetricsService);
			long count = malwareRepository.count();
			if (count > 0) {
				for (int pageNo = 0; pageNo < count / 3; pageNo++) {
					Page<Malware> page = malwareRepository
							.findAll(PageRequest.of(pageNo, 3, Sort.Direction.ASC, "modified"));
					if (page != null && !CollectionUtils.isEmpty(page.getContent())) {
						for (Malware malware : page.getContent()) {
							if (malware != null && StringUtils.hasText(malware.getName())) {
								String search = malware.getName();
								if (StringUtils.hasText(malware.getType())
										&& !search.toLowerCase().contains(malware.getType().toLowerCase()))
									search = search + " " + malware.getType();
								if (StringUtils.hasText(malware.getGroup())
										&& !search.toLowerCase().contains(malware.getGroup().toLowerCase()))
									search = search + " " + malware.getGroup();

								search = search.replace("  ", " ").trim();

								PulsePage pulsePage = ave.searchPulses(search);
								if (pulsePage == null || pulsePage.getCount() == null || pulsePage.getCount() == 0) {
									pulsePage = ave.searchPulses(malware.getName());
								}

								if (pulsePage != null && !CollectionUtils.isEmpty(pulsePage.getResults())) {
									List<Pulse> pulses = pulsePage.getResults();
									if (!CollectionUtils.isEmpty(pulses)) {
										for (Pulse p : pulses) {
											try {
												if (p != null) {
													String text = "";
													if (StringUtils.hasText(p.getName()))
														text = text + " " + p.getName();
													if (StringUtils.hasText(p.getAdversary()))
														text = text + " " + p.getAdversary();
													if (StringUtils.hasText(p.getDescription()))
														text = text + " " + p.getDescription();
													if (!CollectionUtils.isEmpty(p.getTags()))
														text = text + " " + String.join(" ", p.getTags());
													if (StringUtils.hasText(p.getAdversary()))
														text = text + " " + p.getAdversary();

													if (StringUtils.hasText(text)) {
														if (text.toLowerCase().contains(malware.getName().toLowerCase())
																|| text.toLowerCase().contains(malware.getName()
																		.replace(" ", "").toLowerCase())) {
															List<Indicator> indicators = p.getIndicators();
															if (CollectionUtils.isEmpty(indicators)) {
																indicators = ave.getAllIndicatorsForPulse(p.getId());
															}

															if (!CollectionUtils.isEmpty(indicators)) {
																/*
																 * IPV4,
																 * IPV6,DOMAIN,HOSTNAME,EMAIL,URL,URI,MD5,SHA1,SHA256,
																 * PEHASH,IMPHASH,CIDR,PATH,MUTEX,CVE
																 */
																for (Indicator i : indicators) {
																	List<String> cves = new ArrayList<String>();
																	List<String> Hosts = new ArrayList<String>();
																	List<String> domains = new ArrayList<String>();
																	List<String> ips = new ArrayList<String>();
																	List<String> md5s = new ArrayList<String>();
																	List<String> shas = new ArrayList<String>();
																	List<String> urls = new ArrayList<String>();
																	List<String> ssls = new ArrayList<String>();
																	List<String> files = new ArrayList<String>();
																	List<String> exploits = new ArrayList<String>();
																	List<String> emails = new ArrayList<String>();
																	List<String> mutexs = new ArrayList<String>();

																	if (i != null) {
																		if (i.getType() != null && StringUtils
																				.hasText(i.getIndicator())) {
																			switch (i.getType().name()) {
																			case "CVE": {
																				cves.add(i.getIndicator());
																				break;
																			}
																			case "HOSTNAME": {
																				Hosts.add(i.getIndicator());
																				break;
																			}
																			case "DOMAIN": {
																				domains.add(i.getIndicator());
																				break;
																			}
																			case "IPV4": {
																				ips.add(i.getIndicator());
																				break;
																			}
																			case "IPV6": {
																				ips.add(i.getIndicator());
																				break;
																			}
																			case "MD5": {
																				md5s.add(i.getIndicator());
																				break;
																			}
																			case "SHA1": {
																				shas.add(i.getIndicator());
																				break;
																			}
																			case "SHA256": {
																				shas.add(i.getIndicator());
																				break;
																			}
																			case "URL": {
																				urls.add(i.getIndicator());
																				break;
																			}
																			case "PATH": {
																				files.add(i.getIndicator());
																				break;
																			}
																			case "EMAIL": {
																				emails.add(i.getIndicator());
																				break;
																			}
																			case "MUTEX": {
																				mutexs.add(i.getIndicator());
																				break;
																			}

																			}

																			List<ThreatIOC> threatIOCs = new ArrayList<ThreatIOC>();
																			if (!CollectionUtils.isEmpty(md5s))
																				threatIOCs.addAll(threatIOCService
																						.setMD5sToThreatIOC(
																								md5s.toArray(
																										new String[0]),
																								null));
																			else if (!CollectionUtils.isEmpty(shas))
																				threatIOCs.addAll(threatIOCService
																						.setSHAsToThreatIOC(
																								shas.toArray(
																										new String[0]),
																								null));
																			else if (!CollectionUtils.isEmpty(ips))
																				threatIOCs.addAll(threatIOCService
																						.setIPsToThreatIOC(
																								ips.toArray(
																										new String[0]),
																								null));
																			else if (!CollectionUtils.isEmpty(domains))
																				threatIOCs.addAll(threatIOCService
																						.setDomainsToThreatIOC(
																								domains.toArray(
																										new String[0]),
																								null));
																			else if (!CollectionUtils.isEmpty(urls))
																				threatIOCs.addAll(threatIOCService
																						.setURLsToThreatIOC(
																								urls.toArray(
																										new String[0]),
																								null));
																			else if (!CollectionUtils.isEmpty(cves))
																				threatIOCs.addAll(threatIOCService
																						.setCVEsToThreatIOC(
																								cves.toArray(
																										new String[0]),
																								null));
																			else if (!CollectionUtils.isEmpty(files))
																				threatIOCs.addAll(threatIOCService
																						.setFilesToThreatIOC(
																								files.toArray(
																										new String[0]),
																								null));
																			else if (!CollectionUtils.isEmpty(ssls))
																				threatIOCs.addAll(threatIOCService
																						.setSSLsToThreatIOC(
																								ssls.toArray(
																										new String[0]),
																								null));
																			else if (!CollectionUtils.isEmpty(exploits))
																				threatIOCs.addAll(threatIOCService
																						.setExploitssToThreatIOC(
																								exploits.toArray(
																										new String[0]),
																								null));
																			else if (!CollectionUtils.isEmpty(Hosts))
																				threatIOCs.addAll(threatIOCService
																						.setHostsToThreatIOC(
																								Hosts.toArray(
																										new String[0]),
																								null));
																			else if (!CollectionUtils.isEmpty(emails))
																				threatIOCs.addAll(threatIOCService
																						.setEmailsToThreatIOC(
																								emails.toArray(
																										new String[0]),
																								null));
																			else if (!CollectionUtils.isEmpty(mutexs))
																				threatIOCs.addAll(threatIOCService
																						.setMutexToThreatIOC(
																								mutexs.toArray(
																										new String[0]),
																								null));

																			if (!CollectionUtils.isEmpty(threatIOCs))
																				for (ThreatIOC threatIOC : threatIOCs) {
																					if (i.getCreated() != null) {
																						threatIOC.setFirstSeen(
																								i.getCreated());
																						threatIOC.setLastSeen(
																								i.getCreated());
																					} else if (i.getIs_active() != null
																							&& i.getIs_active() == 1) {
																						threatIOC.setLastSeen(
																								new Date());
																					}
																					if (StringUtils.hasText(
																							i.getDescription()))
																						threatIOC.setDescription(
																								i.getDescription());
																					threatIOC = threatIOCService
																							.saveIOCsOnly(threatIOC,
																									false);

																					if (threatIOC != null && StringUtils
																							.hasText(threatIOC
																									.getId())) {
																						MalwareIOC malwareIOC = new MalwareIOC();
																						malwareIOC.setMalwareId(
																								malware.getId());
																						malwareIOC
																								.setClientName(threatIOC
																										.getClientName());
																						malwareIOC.setIndicatorType(
																								threatIOC
																										.getIndicatorType());
																						malwareIOC.setValue(
																								threatIOC.getValue());
																						malwareIOC.setMd5Hash(
																								threatIOC.getMd5Hash());
																						malwareIOC.setSha1Hash(threatIOC
																								.getSha1Hash());
																						malwareIOC
																								.setSha256Hash(threatIOC
																										.getSha256Hash());
																						malwareIOC.setFileName(threatIOC
																								.getFileName());
																						malwareIOC.setCategory(threatIOC
																								.getCategory());
																						malwareIOC.setRecommendedAction(
																								threatIOC
																										.getRecommendedAction());
																						malwareIOC.setDescription(
																								threatIOC
																										.getDescription());
																						malwareIOC.setUid(
																								threatIOC.getUid());
																						malwareIOC
																								.setClientUIDs(threatIOC
																										.getClientUIDs());
																						malwareIOC.setEid(
																								threatIOC.getEid());
																						malwareIOC.setRole(
																								threatIOC.getRole());
																						if (!CollectionUtils
																								.isEmpty(threatIOC
																										.getThreatActorIds()))
																							malwareIOC.setThreatActorId(
																									threatIOC
																											.getThreatActorIds()
																											.iterator()
																											.next());
																						malwareIOC.setThreatActorName(
																								threatIOC
																										.getThreatActorName());
																						malwareIOC.getTags()
																								.add(threatIOC
																										.getThreatActorName());
																						malwareIOC.setTags(
																								threatIOC.getTags());
																						malwareIOC.setThreatScore(
																								threatIOC
																										.getThreatScore());
																						malwareIOC
																								.setPopularity(threatIOC
																										.getPopularity());
																						malwareIOC.setCountryName(
																								threatIOC
																										.getCountryName());
																						malwareIOC.setCountryCode(
																								threatIOC
																										.getCountryCode());
																						malwareIOC.setSource(
																								threatIOC.getSource());
																						if (threatIOC
																								.getFirstSeen() != null
																								&& threatIOC
																										.getFirstSeen()
																										.after(new Date()))
																							malwareIOC.setFirstSeen(
																									new Date());
																						else if (threatIOC
																								.getFirstSeen() != null)
																							malwareIOC.setFirstSeen(
																									threatIOC
																											.getFirstSeen());
																						if (threatIOC
																								.getLastSeen() != null
																								&& threatIOC
																										.getLastSeen()
																										.after(new Date()))
																							malwareIOC.setLastSeen(
																									new Date());
																						else if (threatIOC
																								.getLastSeen() != null)
																							malwareIOC.setLastSeen(
																									threatIOC
																											.getLastSeen());
																						saveMalwareIOC(malwareIOC);
																					}
																				}
																		}
																	}
																}
															}

															if (malware != null) {
																if (!CollectionUtils.isEmpty(p.getIndustries())) {
																	malware.getIndustries().addAll(p.getIndustries());
																}
																if (!CollectionUtils
																		.isEmpty(p.getTargetedCountries())) {
																	malware.getTechnologies()
																			.addAll(p.getTargetedCountries());
																}
																malware.setLastSeen(new Date());
																if (malware.getUpdateCount() != null)
																	malware.setUpdateCount(
																			malware.getUpdateCount() + 1);
																malwareRepository.save(malware);
																log.info(
																		"Malware IOC updated from AV Subscribed Pulse of Malware :  "
																				+ malware.getName());
															}
														}
													}
												}
											} catch (Exception e) {
												log.error("Errow while searching malware pulse in alien vault:  "
														+ malware.getName());
											}
										}
									} else {
										log.info("No Pulse found for Malware Actor/Keyword  :  " + malware.getName());
									}
								}
							}
						}
					}
					try {
						Thread.sleep(Constants.ThreadSleep_10_Sec * 6);
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Override
	public Page<MalwareDTO> findDashboardList(Integer size, Long orgId, Long from, Long to, Pageable pageable) {
		log.debug("Request to get Malwares list for Dashboard");
		Page<Malware> result = null;
		try {
			Map<String, String> orgTagsList = new HashMap<String, String>();
			Set<String> orgIndustryList = new HashSet<String>();
			String indus = null;
			LocalDate reqFrom = null;
			LocalDate reqTo = null;
			Long reqOrgId = null;
			if (orgId != null && orgId > 0) {
				reqOrgId = orgId;
				orgTagsList = masterDataService.getOrgAllDetails(orgId);
				indus = orgTagsList.get("industries");
			}
			if (indus != null && !indus.equalsIgnoreCase("null"))
				orgIndustryList.addAll(Arrays.asList(indus.split(",")));
			if (size != null) {
				if (pageable.getSort() == null)
					pageable = PageRequest.of(0, size, Direction.DESC, "modified");
			}
			if (from != null && from > 0)
				reqFrom = Instant.ofEpochMilli(from).atZone(ZoneId.systemDefault()).toLocalDate();
			if (to != null && to > 0)
				reqTo = Instant.ofEpochMilli(to).atZone(ZoneId.systemDefault()).toLocalDate();

			if (reqOrgId != null && reqFrom != null && reqTo != null)
				result = malwareRepository.findByModifiedBetweenAndIndustryIgnoreCaseIn(reqFrom, reqTo, orgIndustryList,
						pageable);
			else if (reqFrom != null && reqTo != null)
				result = malwareRepository.findByModifiedBetween(reqFrom, reqTo, pageable);
			else if (reqOrgId != null)
				result = malwareRepository.findByIndustryIgnoreCaseIn(orgIndustryList, pageable);
			else
				result = malwareRepository.findAll(pageable);

		} catch (Exception e) {
			log.error("Error in malware service findDashboardList ", e.getMessage());
			e.printStackTrace();
		}
		return result.map(malwareMapper::toDto);
	}

	@Override
	public Page<MalwareIOC> searchIOC(String malwareId, String clientName, String indicatorType, String search,
			Date fromDate, Date toDate, Pageable pageable) {
		if (StringUtils.hasText(indicatorType)) {
			indicatorType = getIndicatorType(indicatorType);
			if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.FileName))
				indicatorType = Constants.IOCIndicatorType.FileHash;
			if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.ThreatActor))
				indicatorType = Constants.IOCIndicatorType.ThreatActor;
		}

		Page<MalwareIOC> malwareIOCPage = null;
		// -for Date, Indicator type and Client
		if (fromDate != null && toDate != null && StringUtils.hasText(indicatorType) && StringUtils.hasText(search)
				&& StringUtils.hasText(clientName)) {
			if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.FileHash)) {
				if (search.length() == 32)
					malwareIOCPage = malwareIOCRepository
							.findByLastSeenBetweenAndIndicatorTypeAndMd5HashAndClientNameAndMalwareId(fromDate, toDate,
									indicatorType, search, clientName, malwareId, pageable);
				else if (search.length() == 40)
					malwareIOCPage = malwareIOCRepository
							.findByLastSeenBetweenAndIndicatorTypeAndSha1HashAndClientNameAndMalwareId(fromDate, toDate,
									indicatorType, search, clientName, malwareId, pageable);
				else if (search.length() == 64)
					malwareIOCPage = malwareIOCRepository
							.findByLastSeenBetweenAndIndicatorTypeAndSha256HashAndClientNameAndMalwareId(fromDate,
									toDate, indicatorType, search, clientName, malwareId, pageable);
				else
					malwareIOCPage = malwareIOCRepository
							.findByLastSeenBetweenAndIndicatorTypeAndValueRegexAndClientNameAndMalwareId(fromDate,
									toDate, indicatorType, "^(?i)" + search, clientName, malwareId, pageable);
			} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.ThreatActor)) {
				malwareIOCPage = malwareIOCRepository
						.findByLastSeenBetweenAndThreatActorNameRegexAndClientNameAndMalwareIdOrLastSeenBetweenAndThreatActorAliasRegexAndClientNameAndMalwareId(
								fromDate, toDate, "^(?i)" + search, clientName, malwareId, fromDate, toDate,
								"^(?i)" + search, clientName, malwareId, pageable);
			} else {
				malwareIOCPage = malwareIOCRepository
						.findByLastSeenBetweenAndIndicatorTypeAndValueRegexAndClientNameAndMalwareId(fromDate, toDate,
								indicatorType, "^(?i)" + search, clientName, malwareId, pageable);
			}
		}
		// -for Date and Indicator Type
		else if (fromDate != null && toDate != null && StringUtils.hasText(indicatorType)
				&& StringUtils.hasText(search)) {
			if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.FileHash)) {
				if (search.length() == 32)
					malwareIOCPage = malwareIOCRepository.findByLastSeenBetweenAndIndicatorTypeAndMd5HashAndMalwareId(
							fromDate, toDate, indicatorType, search, malwareId, pageable);
				else if (search.length() == 40)
					malwareIOCPage = malwareIOCRepository.findByLastSeenBetweenAndIndicatorTypeAndSha1HashAndMalwareId(
							fromDate, toDate, indicatorType, search, malwareId, pageable);
				else if (search.length() == 64)
					malwareIOCPage = malwareIOCRepository
							.findByLastSeenBetweenAndIndicatorTypeAndSha256HashAndMalwareId(fromDate, toDate,
									indicatorType, search, malwareId, pageable);
				else
					malwareIOCPage = malwareIOCRepository
							.findByLastSeenBetweenAndIndicatorTypeAndValueRegexAndMalwareId(fromDate, toDate,
									indicatorType, "^(?i)" + search, malwareId, pageable);
			} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.ThreatActor)) {
				malwareIOCPage = malwareIOCRepository
						.findByLastSeenBetweenAndThreatActorNameRegexAndMalwareIdOrLastSeenBetweenAndThreatActorAliasRegexAndMalwareId(
								fromDate, toDate, "^(?i)" + search, malwareId, fromDate, toDate, "^(?i)" + search,
								malwareId, pageable);
			} else {
				malwareIOCPage = malwareIOCRepository.findByLastSeenBetweenAndIndicatorTypeAndValueRegexAndMalwareId(
						fromDate, toDate, indicatorType, "^(?i)" + search, malwareId, pageable);
			}
		}
		// -for Indicator Type and Client Name
		else if (StringUtils.hasText(indicatorType) && StringUtils.hasText(clientName)) {
			if (StringUtils.hasText(search)) {
				if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.FileHash)) {
					if (search.length() == 32)
						malwareIOCPage = malwareIOCRepository.findByIndicatorTypeAndMd5HashAndClientNameAndMalwareId(
								indicatorType, search, clientName, malwareId, pageable);
					else if (search.length() == 40)
						malwareIOCPage = malwareIOCRepository.findByIndicatorTypeAndSha1HashAndClientNameAndMalwareId(
								indicatorType, search, clientName, malwareId, pageable);
					else if (search.length() == 64)
						malwareIOCPage = malwareIOCRepository.findByIndicatorTypeAndSha256HashAndClientNameAndMalwareId(
								indicatorType, search, clientName, malwareId, pageable);
					else
						malwareIOCPage = malwareIOCRepository.findByIndicatorTypeAndValueRegexAndClientNameAndMalwareId(
								indicatorType, "^(?i)" + search, clientName, malwareId, pageable);
				} else {
					malwareIOCPage = malwareIOCRepository.findByIndicatorTypeAndValueRegexAndClientNameAndMalwareId(
							indicatorType, "^(?i)" + search, clientName, malwareId, pageable);
				}
			} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.ThreatActor)) {
				malwareIOCPage = malwareIOCRepository
						.findByThreatActorNameRegexAndClientNameAndMalwareIdOrThreatActorAliasRegexAndClientNameAndMalwareId(
								"^(?i)" + search, clientName, malwareId, "^(?i)" + search, clientName, malwareId,
								pageable);
			} else
				malwareIOCPage = malwareIOCRepository.findByIndicatorTypeAndClientNameAndMalwareId(indicatorType,
						clientName, malwareId, pageable);
		}
		// -for Date and client Name
		else if (fromDate != null && toDate != null && StringUtils.hasText(clientName)) {
			malwareIOCPage = malwareIOCRepository.findByLastSeenBetweenAndClientNameAndMalwareId(fromDate, toDate,
					clientName, malwareId, pageable);
		}
		// -for Date Wise
		else if (fromDate != null && toDate != null) {
			malwareIOCPage = malwareIOCRepository.findByLastSeenBetweenAndMalwareId(fromDate, toDate, malwareId,
					pageable);
		}
		// -for Client Name
		else if (StringUtils.hasText(clientName)) {
			malwareIOCPage = malwareIOCRepository.findByClientNameAndMalwareId(clientName, malwareId, pageable);
		}
		// -for Indicator Type
		else if (StringUtils.hasText(indicatorType)) {
			if (StringUtils.hasText(search)) {
				if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.FileHash)) {
					if (org.apache.commons.lang3.StringUtils.isNotBlank(malwareId)) {
						if (search.length() == 32)
							malwareIOCPage = malwareIOCRepository.findByIndicatorTypeAndMd5HashAndMalwareId(
									indicatorType, search, malwareId, pageable);
						else if (search.length() == 40)
							malwareIOCPage = malwareIOCRepository.findByIndicatorTypeAndSha1HashAndMalwareId(
									indicatorType, search, malwareId, pageable);
						else if (search.length() == 64)
							malwareIOCPage = malwareIOCRepository.findByIndicatorTypeAndSha256HashAndMalwareId(
									indicatorType, search, malwareId, pageable);
						else
							malwareIOCPage = malwareIOCRepository.findByIndicatorTypeAndValueIgnoreCaseAndMalwareId(
									indicatorType, search, malwareId, pageable);
					} else {
						if (search.length() == 32)
							malwareIOCPage = malwareIOCRepository.findByIndicatorTypeAndMd5Hash(indicatorType, search,
									pageable);
						else if (search.length() == 40)
							malwareIOCPage = malwareIOCRepository.findByIndicatorTypeAndSha1Hash(indicatorType, search,
									pageable);
						else if (search.length() == 64)
							malwareIOCPage = malwareIOCRepository.findByIndicatorTypeAndSha256Hash(indicatorType,
									search, pageable);
						else
							malwareIOCPage = malwareIOCRepository.findByIndicatorTypeAndValueIgnoreCase(indicatorType,
									search, pageable);
					}
				} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.ThreatActor)) {
					malwareIOCPage = malwareIOCRepository
							.findByThreatActorNameRegexAndMalwareIdOrThreatActorAliasRegexAndMalwareId("^(?i)" + search,
									malwareId, "^(?i)" + search, malwareId, pageable);
				} else {
					if (org.apache.commons.lang3.StringUtils.isNotBlank(malwareId)) {
						malwareIOCPage = malwareIOCRepository.findByIndicatorTypeAndValueIgnoreCaseAndMalwareId(
								indicatorType, search, malwareId, pageable);
					} else {
						malwareIOCPage = malwareIOCRepository.findByIndicatorTypeAndValueIgnoreCase(indicatorType,
								search, pageable);
					}
				}
			} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.ThreatActor)) {
				malwareIOCPage = malwareIOCRepository.findByThreatActorNameExistsAndMalwareId(true, malwareId,
						pageable);
			} else
				malwareIOCPage = malwareIOCRepository.findByIndicatorTypeAndMalwareId(indicatorType, malwareId,
						pageable);
		}
		// -Default
		else {
			malwareIOCPage = malwareIOCRepository.findByMalwareId(malwareId, pageable);
		}
		return malwareIOCPage;
	}

	@Override
	public String getIndicatorType(String indicatorType) {
		if (!StringUtils.hasText(indicatorType))
			return null;

		if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.FileHash)
				|| indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.MD5)
				|| indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.SHA)
				|| indicatorType.equalsIgnoreCase("sha1") || indicatorType.equalsIgnoreCase("sha2")
				|| indicatorType.equalsIgnoreCase("sha256") || indicatorType.equalsIgnoreCase("sha512")) {
			return Constants.IOCIndicatorType.FileHash;
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.IP)
				|| indicatorType.equalsIgnoreCase("ip"))
			return Constants.IOCIndicatorType.IP;
		else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.URL))
			return Constants.IOCIndicatorType.URL;
		else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Domain))
			return Constants.IOCIndicatorType.Domain;
		else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Hostname))
			return Constants.IOCIndicatorType.Hostname;
		else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Mutex))
			return Constants.IOCIndicatorType.Mutex;
		else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Email))
			return Constants.IOCIndicatorType.Email;
		else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.CVE))
			return Constants.IOCIndicatorType.CVE;
		else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.SSL))
			return Constants.IOCIndicatorType.SSL;
		else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Files))
			return Constants.IOCIndicatorType.Files;
		else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Exploit))
			return Constants.IOCIndicatorType.Exploit;
		else if (StringUtils.hasText(indicatorType))
			return indicatorType;

		return null;
	}

	@Override
	public MalwareIOCAttribute setIOCAttributes(List<MalwareIOC> iocList) {
		MalwareIOCAttribute iocAttribute = new MalwareIOCAttribute();

		if (!CollectionUtils.isEmpty(iocList)) {
			Set<String> ids = new HashSet<String>();
			iocList.forEach(ioc -> {
				if (ioc != null && StringUtils.hasText(ioc.getIndicatorType())) {
					if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.FileHash)) {
						if (StringUtils.hasText(ioc.getMd5Hash()) && !ids.contains(ioc.getMd5Hash())) {
							MalwareIOCProperty iocProperty = new MalwareIOCProperty(ioc);
							iocProperty.setKey(Constants.IOCIndicatorType.MD5);
							iocProperty.setValue(ioc.getMd5Hash());
							iocAttribute.addMD5(iocProperty);

							ids.add(ioc.getMd5Hash());
						}
						if (StringUtils.hasText(ioc.getSha1Hash()) && !ids.contains(ioc.getSha1Hash())) {
							MalwareIOCProperty iocProperty = new MalwareIOCProperty(ioc);
							iocProperty.setKey(Constants.IOCIndicatorType.SHA);
							iocProperty.setValue(ioc.getSha1Hash());
							iocAttribute.addSHA(iocProperty);

							ids.add(ioc.getSha1Hash());
						}
						if (StringUtils.hasText(ioc.getSha256Hash()) && !ids.contains(ioc.getSha256Hash())) {
							MalwareIOCProperty iocProperty = new MalwareIOCProperty(ioc);
							iocProperty.setKey(Constants.IOCIndicatorType.SHA);
							iocProperty.setValue(ioc.getSha256Hash());
							iocAttribute.addSHA(iocProperty);

							ids.add(ioc.getSha256Hash());
						}
					} else if (StringUtils.hasText(ioc.getValue()) && !ids.contains(ioc.getValue())) {
						if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.Domain)) {
							MalwareIOCProperty iocProperty = new MalwareIOCProperty(ioc);
							iocProperty.setKey(Constants.IOCIndicatorType.Domain);
							iocProperty.setValue(ioc.getValue());
							iocAttribute.addDomain(iocProperty);
						} else if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.URL)) {
							MalwareIOCProperty iocProperty = new MalwareIOCProperty(ioc);
							iocProperty.setKey(Constants.IOCIndicatorType.URL);
							iocProperty.setValue(ioc.getValue());
							iocAttribute.addURL(iocProperty);
						} else if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.IP)) {
							MalwareIOCProperty iocProperty = new MalwareIOCProperty(ioc);
							iocProperty.setKey(Constants.IOCIndicatorType.IP);
							iocProperty.setValue(ioc.getValue());
							iocAttribute.addIP(iocProperty);
						} else if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.CVE)) {
							if (StringUtils.hasText(ioc.getValue())
									&& ioc.getValue().trim().toLowerCase().contains("cve")) {
								MalwareIOCProperty iocProperty = new MalwareIOCProperty(ioc);
								iocProperty.setKey(Constants.IOCIndicatorType.CVE);
								iocProperty.setValue(ioc.getValue());
								iocAttribute.addCVE(iocProperty);
							}
						} else if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.Files)) {
							MalwareIOCProperty iocProperty = new MalwareIOCProperty(ioc);
							iocProperty.setKey(Constants.IOCIndicatorType.Files);
							iocProperty.setValue(ioc.getValue());
							iocAttribute.addFile(iocProperty);
						} else if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.SSL)) {
							MalwareIOCProperty iocProperty = new MalwareIOCProperty(ioc);
							iocProperty.setKey(Constants.IOCIndicatorType.SSL);
							iocProperty.setValue(ioc.getValue());
							iocAttribute.addSSL(iocProperty);
						} else if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.Email)) {
							MalwareIOCProperty iocProperty = new MalwareIOCProperty(ioc);
							iocProperty.setKey(Constants.IOCIndicatorType.Email);
							iocProperty.setValue(ioc.getValue());
							iocAttribute.addEmail(iocProperty);
						} else if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.Hostname)) {
							MalwareIOCProperty iocProperty = new MalwareIOCProperty(ioc);
							iocProperty.setKey(Constants.IOCIndicatorType.Hostname);
							iocProperty.setValue(ioc.getValue());
							iocAttribute.addHostName(iocProperty);
						} else if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.Mutex)) {
							MalwareIOCProperty iocProperty = new MalwareIOCProperty(ioc);
							iocProperty.setKey(Constants.IOCIndicatorType.Mutex);
							iocProperty.setValue(ioc.getValue());
							iocAttribute.addMutex(iocProperty);
						} else if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.Exploit)) {
							MalwareIOCProperty iocProperty = new MalwareIOCProperty(ioc);
							iocProperty.setKey(Constants.IOCIndicatorType.Exploit);
							iocProperty.setValue(ioc.getValue());
							iocAttribute.addExploit(iocProperty);
						}
						ids.add(ioc.getValue());
					}
				}
			});
		}
		return iocAttribute;
	}

	// @Scheduled(fixedDelay = 1000 * 55 * 65 * 3, initialDelay = 1000 * 63 * 17)
	@Override
	public void malwareBazaarIOCDownload() {
		if (!applicationProperties.getCore().getIocUpdateSchedulerRun()
				|| !applicationProperties.getCore().getServerurl().contains(Constants.ServerUrls.PROD))
			return;

		List<FeedEntry> feedEntry = MalwareBazaarEngine.config("ddd770a51b0a73117ca401d7aae892e6").getRecentSamples();
		if (!CollectionUtils.isEmpty(feedEntry)) {
			for (FeedEntry fe : feedEntry) {
				if (fe != null) {
					ThreatIOC threatIOC = new ThreatIOC();
					MalwareIOC malwareIOC = new MalwareIOC();

					threatIOC.setIndicatorType(Constants.IOCIndicatorType.FileHash);
					threatIOC.setMd5Hash(fe.getMd5Hash());
					threatIOC.setSha1Hash(fe.getSha1Hash());
					threatIOC.setSha256Hash(fe.getSha256Hash());
					threatIOC.setFileName(fe.getFileName());
					threatIOC.setValue(fe.getFileType() + ":" + fe.getFileName());
					threatIOC.addTags(fe.getSignature());
					threatIOC.addTags(fe.getTags());
					threatIOC.setThreatScore("7");
					threatIOC.setRecommendedAction("Monitor");
					threatIOC.setSource(Constants.IOCSource.MALWARE_BAZAAR);

					if (StringUtils.hasText(fe.getSignature()) && !fe.getSignature().toLowerCase().contains("null")) {
						Malware malware = malwareRepository.findTop1ByNameContainingIgnoreCaseOrAliasesRegex(
								fe.getSignature(), "^(?i)" + fe.getSignature());
						if (malware == null || StringUtils.hasText(malware.getId())) {
							continue;

						}
						threatIOC.setCategory("Malware");
						threatIOC.setRole("Malware");
						threatIOC.setRecommendedAction("Block");
						threatIOC.addTags(malware.getName());
						malwareIOC.setMalwareId(malware.getId());
						malwareIOC.setMalwareName(malware.getName());
					}

					if (StringUtils.hasText(fe.getFirstSeen())) {
						try {
							threatIOC
									.setFirstSeen(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(fe.getFirstSeen()));
						} catch (Exception e) {
							log.error("error while converting vt first seen & last seen, Error : " + e.getMessage());
						}
					}
					if (fe.getLastSeen() == null && StringUtils.hasText(fe.getLastSeen())) {
						try {
							threatIOC.setLastSeen(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(fe.getLastSeen()));
						} catch (Exception e) {
							log.error("error while converting vt first seen & last seen, Error : " + e.getMessage());
						}
					}
					if (threatIOC.getLastSeen() == null)
						threatIOC.setLastSeen(new Date());
					threatIOC = threatIOCService.saveIOCsOnly(threatIOC, false);

					malwareIOC.setClientName(threatIOC.getClientName());
					malwareIOC.setIndicatorType(threatIOC.getIndicatorType());
					malwareIOC.setValue(threatIOC.getValue());
					malwareIOC.setMd5Hash(threatIOC.getMd5Hash());
					malwareIOC.setSha1Hash(threatIOC.getSha1Hash());
					malwareIOC.setSha256Hash(threatIOC.getSha256Hash());
					malwareIOC.setFileName(threatIOC.getFileName());
					malwareIOC.setCategory(threatIOC.getCategory());
					malwareIOC.setRecommendedAction(threatIOC.getRecommendedAction());
					malwareIOC.setDescription(threatIOC.getDescription());
					malwareIOC.setUid(threatIOC.getUid());
					malwareIOC.setClientUIDs(threatIOC.getClientUIDs());
					malwareIOC.setEid(threatIOC.getEid());
					malwareIOC.setRole(threatIOC.getRole());
					if (!CollectionUtils.isEmpty(threatIOC.getThreatActorIds()))
						malwareIOC.setThreatActorId(threatIOC.getThreatActorIds().iterator().next());
					malwareIOC.setThreatActorName(threatIOC.getThreatActorName());
					malwareIOC.getTags().addAll(threatIOC.getTags());
					malwareIOC.getTags().add(threatIOC.getThreatActorName());
					malwareIOC.setThreatScore(threatIOC.getThreatScore());
					malwareIOC.setPopularity(threatIOC.getPopularity());
					malwareIOC.setCountryName(threatIOC.getCountryName());
					malwareIOC.setCountryCode(threatIOC.getCountryCode());
					malwareIOC.setSource(threatIOC.getSource());
					if (threatIOC.getFirstSeen() != null && threatIOC.getFirstSeen().after(new Date()))
						malwareIOC.setFirstSeen(new Date());
					else if (threatIOC.getFirstSeen() != null)
						malwareIOC.setFirstSeen(threatIOC.getFirstSeen());
					if (threatIOC.getLastSeen() != null && threatIOC.getLastSeen().after(new Date()))
						malwareIOC.setLastSeen(new Date());
					else if (threatIOC.getLastSeen() != null)
						malwareIOC.setLastSeen(threatIOC.getLastSeen());
					saveMalwareIOC(malwareIOC);
				}
			}
		}
	}

//	@Scheduled(fixedDelay = 14400000, initialDelay = 1000 *  60 * 20)
	@Override
	public void scrapeAnyrunIOC() {
		if (!applicationProperties.getCore().getIocUpdateSchedulerRun()
				|| !applicationProperties.getCore().getServerurl().contains(Constants.ServerUrls.PROD))
			return;
		String blogUrl = "https://any.run/malware-trends/";
		try {
			Document doc = Jsoup.connect(blogUrl).get();

			Elements boxes = doc.select("div.box");
			for (Element box : boxes) {
				Elements els2 = box.select("h2.title");
				String name = "";
				for (Element els : els2) {
					name = els.text();
				}

				Malware malware = malwareRepository.findTop1ByNameIgnoreCase(name);
				if (malware == null) {
					continue;
				}

				Elements els4 = box.getElementsByClass("readMore");

				String url = "https://any.run" + els4.attr("href");
				Document childDoc = Jsoup.connect(url).get();
				try {
					Element es = childDoc.getElementById("ipData");

					Elements link = es.getElementsByClass("list__item");
					for (Element e : link) {
						String ip = e.text().trim();
						Pageable pageable = PageRequest.of(0, 25);
						MalwareIOC malwareIOC = null;
						Page<MalwareIOC> mIOC = malwareIOCRepository.findByIndicatorTypeAndValueIgnoreCaseAndMalwareId(
								Constants.IOCIndicatorType.IP, ip, malware.getId(), pageable);
						if (mIOC.hasContent()) {
							malwareIOC = mIOC.getContent().get(0);
							malwareIOC.setLastSeen(new Date());
						} else {
							malwareIOC = new MalwareIOC();
						}

						malwareIOC.setIndicatorType(Constants.IOCIndicatorType.IP);
						malwareIOC.setValue(ip);
						malwareIOC.setMalwareId(malware.getId());
						malwareIOC.setLastSeen(new Date());
						malwareIOC.firstSeen(new Date());
						malwareIOCRepository.save(malwareIOC);

						ThreatIOC threatIOC = new ThreatIOC();
						threatIOC.setIndicatorType(Constants.IOCIndicatorType.IP);
						threatIOC.setValue(ip);
						threatIOC.setLastSeen(new Date());
						Set<String> tags = new HashSet<String>();
						tags.add(name);
						threatIOC.setTags(tags);
						threatIOCService.saveIOCsOnly(threatIOC, false);
					}

					es = childDoc.getElementById("hashData");
					link = es.getElementsByClass("list__item");
					for (Element e : link) {
						String hash = e.text().trim();
						Pageable pageable = PageRequest.of(0, 25);
						MalwareIOC malwareIOC = null;
						String hashType = threatIOCService.getIndicatorTypeFromValue(hash);
						Page<MalwareIOC> mIOC = malwareIOCRepository.findByIndicatorTypeAndValueIgnoreCaseAndMalwareId(
								hashType, hash, malware.getId(), pageable);
						if (mIOC.hasContent()) {
							malwareIOC = mIOC.getContent().get(0);
						} else {
							malwareIOC = new MalwareIOC();
							malwareIOC.firstSeen(new Date());
						}

						malwareIOC.setIndicatorType(hashType);
						malwareIOC.setValue(hash);
						malwareIOC.setMalwareId(malware.getId());
						malwareIOC.setLastSeen(new Date());
						malwareIOCRepository.save(malwareIOC);

						ThreatIOC threatIOC = new ThreatIOC();
						threatIOC.setIndicatorType(hashType);
						threatIOC.setValue(hash);
						threatIOC.setLastSeen(new Date());
						Set<String> tags = new HashSet<String>();
						tags.add(name);
						threatIOC.setTags(tags);
						threatIOCService.saveIOCsOnly(threatIOC, false);
					}
					es = childDoc.getElementById("domainData");
					link = es.getElementsByClass("list__item");
					for (Element e : link) {
						String domain = e.text().trim();
						Pageable pageable = PageRequest.of(0, 25);
						MalwareIOC malwareIOC = null;
						Page<MalwareIOC> mIOC = malwareIOCRepository.findByIndicatorTypeAndValueIgnoreCaseAndMalwareId(
								Constants.IOCIndicatorType.Domain, domain, malware.getId(), pageable);
						if (mIOC.hasContent()) {
							malwareIOC = mIOC.getContent().get(0);
							malwareIOC.setLastSeen(new Date());
						} else {
							malwareIOC = new MalwareIOC();
						}

						malwareIOC.setIndicatorType(Constants.IOCIndicatorType.Domain);
						malwareIOC.setValue(domain);
						malwareIOC.setMalwareId(malware.getId());
						malwareIOC.setLastSeen(new Date());
						malwareIOC.firstSeen(new Date());
						malwareIOCRepository.save(malwareIOC);

						ThreatIOC threatIOC = new ThreatIOC();
						threatIOC.setIndicatorType(Constants.IOCIndicatorType.Domain);
						threatIOC.setValue(domain);
						threatIOC.setLastSeen(new Date());
						Set<String> tags = new HashSet<String>();
						tags.add(name);
						threatIOC.setTags(tags);
						threatIOCService.saveIOCsOnly(threatIOC, false);
					}
				} catch (Exception ex) {
					log.error("Error while scraping Anyrun IOC");
					ex.printStackTrace();
				}
			}
		} catch (Exception e) {
			log.info("Error in scraping malware IOC from any run");
			e.printStackTrace();
		}

	}

	@Override
	public MalwareIOC saveIOCsOnly(MalwareIOC malwareIOC) {
		MalwareIOC existingMalwareIOC = null;
		try {
			if (malwareIOC != null && StringUtils.hasText(malwareIOC.getIndicatorType())) {
				String indicatorType = getIndicatorType(malwareIOC.getIndicatorType());
				if (!StringUtils.hasText(indicatorType))
					return null;

				List<MalwareIOC> malwareIOCs = getMalwareIOC(indicatorType, malwareIOC);

				if (!CollectionUtils.isEmpty(malwareIOCs)) {
					existingMalwareIOC = malwareIOCs.get(0);
					log.debug("Existing Malware IOC - {}", existingMalwareIOC);
				}
				if (existingMalwareIOC == null)
					existingMalwareIOC = new MalwareIOC();

				existingMalwareIOC.setMalwareId(malwareIOC.getMalwareId());
				existingMalwareIOC.setClientName(malwareIOC.getClientName());
				existingMalwareIOC.setCategory(malwareIOC.getCategory());
				existingMalwareIOC.setUid(malwareIOC.getUid());
				existingMalwareIOC.setClientUIDs(malwareIOC.getClientUIDs());
				existingMalwareIOC.setThreatActorId(malwareIOC.getThreatActorId());
				existingMalwareIOC.setTags(malwareIOC.getTags());
				existingMalwareIOC.setThreatScore(malwareIOC.getThreatScore());
				existingMalwareIOC.setPopularity(malwareIOC.getPopularity());

				if (!StringUtils.hasText(existingMalwareIOC.getIndicatorType()))
					existingMalwareIOC.setIndicatorType(indicatorType);
				if (StringUtils.hasText(malwareIOC.getValue()))
					existingMalwareIOC.setValue(malwareIOC.getValue());
				if (StringUtils.hasText(malwareIOC.getMd5Hash()))
					existingMalwareIOC.setMd5Hash(malwareIOC.getMd5Hash());
				if (StringUtils.hasText(malwareIOC.getSha1Hash()))
					existingMalwareIOC.setSha1Hash(malwareIOC.getSha1Hash());
				if (StringUtils.hasText(malwareIOC.getSha256Hash()))
					existingMalwareIOC.setSha256Hash(malwareIOC.getSha256Hash());
				if (StringUtils.hasText(malwareIOC.getFileName()))
					existingMalwareIOC.setFileName(malwareIOC.getFileName());
				if (StringUtils.hasText(malwareIOC.getCategory()))
					existingMalwareIOC.setCategory(malwareIOC.getCategory());
				if (StringUtils.hasText(malwareIOC.getRecommendedAction()))
					existingMalwareIOC.setRecommendedAction(malwareIOC.getRecommendedAction());
				if (StringUtils.hasText(malwareIOC.getDescription()))
					existingMalwareIOC.setDescription(malwareIOC.getDescription());
				if (StringUtils.hasText(malwareIOC.getEid()))
					existingMalwareIOC.setEid(malwareIOC.getEid());
				if (StringUtils.hasText(malwareIOC.getRole()))
					existingMalwareIOC.setRole(malwareIOC.getRole());
			}
			if (StringUtils.hasText(malwareIOC.getThreatActorName())) {
				if (StringUtils.hasText(existingMalwareIOC.getThreatActorName())) {
					existingMalwareIOC.getTags().add(existingMalwareIOC.getThreatActorName());
				}
				existingMalwareIOC.getTags().add(malwareIOC.getThreatActorName());
				existingMalwareIOC.setThreatActorName(malwareIOC.getThreatActorName());
			}
			if (StringUtils.hasText(malwareIOC.getUid()))
				existingMalwareIOC.setUid(malwareIOC.getUid());

			if (!CollectionUtils.isEmpty(malwareIOC.getClientName())) {
				existingMalwareIOC.addClientUIDs(new ArrayList<String>(malwareIOC.getClientName()).get(0),
						malwareIOC.getUid());
			}

			if (!CollectionUtils.isEmpty(malwareIOC.getTags()))
				existingMalwareIOC.getTags().addAll(malwareIOC.getTags());
			if (StringUtils.hasText(malwareIOC.getThreatScore())) {
				if (!StringUtils.hasText(existingMalwareIOC.getThreatScore()))
					existingMalwareIOC.setThreatScore(malwareIOC.getThreatScore());
				else {
					try {
						if (Integer.parseInt(existingMalwareIOC.getThreatScore()) < Integer
								.parseInt(malwareIOC.getThreatScore()))
							existingMalwareIOC.setThreatScore(malwareIOC.getThreatScore());
					} catch (Exception e) {
					}
				}
			}
			if (StringUtils.hasText(malwareIOC.getCountryName()))
				existingMalwareIOC.setCountryName(malwareIOC.getCountryName());
			if (StringUtils.hasText(malwareIOC.getCountryCode()))
				existingMalwareIOC.setCountryCode(malwareIOC.getCountryCode());
			if (StringUtils.hasText(malwareIOC.getSource()))
				existingMalwareIOC.setSource(malwareIOC.getSource());
			if (malwareIOC.getFirstSeen() != null) {
				if (existingMalwareIOC.getFirstSeen() == null) {
					existingMalwareIOC.setFirstSeen(malwareIOC.getFirstSeen());
				} else if (malwareIOC.getFirstSeen().toInstant()
						.isBefore(existingMalwareIOC.getFirstSeen().toInstant()))
					existingMalwareIOC.setFirstSeen(malwareIOC.getFirstSeen());
			}
			if (malwareIOC.getLastSeen() != null) {
				if (existingMalwareIOC.getLastSeen() == null) {
					existingMalwareIOC.setLastSeen(malwareIOC.getLastSeen());
				} else if (malwareIOC.getLastSeen().toInstant().isAfter(existingMalwareIOC.getLastSeen().toInstant()))
					existingMalwareIOC.setLastSeen(malwareIOC.getLastSeen());
			}

			if (malwareIOC.getPopularity() != null)
				existingMalwareIOC.setPopularity(malwareIOC.getPopularity());
			if (!CollectionUtils.isEmpty(malwareIOC.getClientName()))
				existingMalwareIOC.getClientName().addAll(malwareIOC.getClientName());
			if (StringUtils.hasText(malwareIOC.getThreatActorName()))
				existingMalwareIOC.setThreatActorName(malwareIOC.getThreatActorName());
			if (existingMalwareIOC.getLastSeen() == null && existingMalwareIOC.getFirstSeen() != null)
				existingMalwareIOC.setLastSeen(existingMalwareIOC.getFirstSeen());
			if (existingMalwareIOC.getFirstSeen() == null && existingMalwareIOC.getLastSeen() != null)
				existingMalwareIOC.firstSeen(existingMalwareIOC.getLastSeen());
			if (existingMalwareIOC.getFirstSeen() != null && existingMalwareIOC.getLastSeen() != null
					&& existingMalwareIOC.getFirstSeen().toInstant()
							.isAfter(existingMalwareIOC.getLastSeen().toInstant()))
				existingMalwareIOC.setLastSeen(existingMalwareIOC.getFirstSeen());
			if (StringUtils.hasText(existingMalwareIOC.getValue()))
				existingMalwareIOC.setValue(existingMalwareIOC.getValue().replace("[.]", ".").replace("[:]", ":"));
			if (!CollectionUtils.isEmpty(existingMalwareIOC.getClientName())
					|| !CollectionUtils.isEmpty(existingMalwareIOC.getClientUIDs()))
				existingMalwareIOC.setCyfirmaIOC(true);
			if (existingMalwareIOC.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.FileHash)) {
				if (StringUtils.hasText(existingMalwareIOC.getValue())) {
					if (StringUtils.hasText(existingMalwareIOC.getMd5Hash())
							&& existingMalwareIOC.getValue().equalsIgnoreCase(existingMalwareIOC.getMd5Hash())) {
						existingMalwareIOC.setValue(null);
					} else if (StringUtils.hasText(existingMalwareIOC.getSha1Hash())
							&& existingMalwareIOC.getValue().equalsIgnoreCase(existingMalwareIOC.getSha1Hash())) {
						existingMalwareIOC.setValue(null);
					} else if (StringUtils.hasText(existingMalwareIOC.getSha256Hash())
							&& existingMalwareIOC.getValue().equalsIgnoreCase(existingMalwareIOC.getSha256Hash())) {
						existingMalwareIOC.setValue(null);
					}
				}
				if (StringUtils.hasText(existingMalwareIOC.getFileName())) {
					if (StringUtils.hasText(existingMalwareIOC.getMd5Hash())
							&& existingMalwareIOC.getFileName().equalsIgnoreCase(existingMalwareIOC.getMd5Hash())) {
						existingMalwareIOC.setFileName(null);
					} else if (StringUtils.hasText(existingMalwareIOC.getSha1Hash())
							&& existingMalwareIOC.getFileName().equalsIgnoreCase(existingMalwareIOC.getSha1Hash())) {
						existingMalwareIOC.setFileName(null);
					} else if (StringUtils.hasText(existingMalwareIOC.getSha256Hash())
							&& existingMalwareIOC.getFileName().equalsIgnoreCase(existingMalwareIOC.getSha256Hash())) {
						existingMalwareIOC.setFileName(null);
					}
				}
				if (!StringUtils.hasText(existingMalwareIOC.getValue())
						&& StringUtils.hasText(existingMalwareIOC.getFileName())) {
					existingMalwareIOC.setValue(existingMalwareIOC.getFileName());
				}
			}
			malwareIOCRepository.save(existingMalwareIOC);
		} catch (Exception ex) {
			log.error("Error while saving Campaign ioc : error : " + ex.getMessage());
			ex.printStackTrace();
		}
		return existingMalwareIOC;
	}

	@Override
	public List<MalwareIOC> getMampaignIOC(String indicatorType, MalwareIOC malwareIOC) {
		List<MalwareIOC> malwareIOCs = null;
		if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.FileHash)) {
			if (StringUtils.hasText(malwareIOC.getMd5Hash()))
				malwareIOCs = malwareIOCRepository.findByMd5Hash(malwareIOC.getMd5Hash().toLowerCase().trim());
			if (CollectionUtils.isEmpty(malwareIOCs) && StringUtils.hasText(malwareIOC.getSha1Hash()))
				malwareIOCs = malwareIOCRepository.findBySha1Hash(malwareIOC.getSha1Hash().toLowerCase().trim());
			if (CollectionUtils.isEmpty(malwareIOCs) && StringUtils.hasText(malwareIOC.getSha256Hash()))
				malwareIOCs = malwareIOCRepository.findBySha256Hash(malwareIOC.getSha256Hash().toLowerCase().trim());
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.IP)) {
			malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.IP,
					malwareIOC.getValue().trim().toLowerCase());
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Domain)) {
			malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.Domain,
					malwareIOC.getValue().toLowerCase().trim());
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.URL)) {
			malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.URL,
					malwareIOC.getValue().toLowerCase().trim());
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Hostname)) {
			malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.Hostname,
					malwareIOC.getValue().toLowerCase());
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Files)) {
			malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.Files,
					malwareIOC.getValue().trim().toLowerCase());
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.SSL)) {
			malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.SSL,
					malwareIOC.getValue().toLowerCase());
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.CVE)) {
			malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.CVE,
					malwareIOC.getValue().trim().toLowerCase());
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Mutex)) {
			malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.Mutex,
					malwareIOC.getValue().toLowerCase());
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Email)) {
			malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.Email,
					malwareIOC.getValue().toLowerCase());
		} else if (indicatorType.equalsIgnoreCase(Constants.IOCIndicatorType.Exploit)) {
			malwareIOCs = malwareIOCRepository.findByIndicatorTypeAndValue(Constants.IOCIndicatorType.Exploit,
					malwareIOC.getValue().toLowerCase());
		}
		return malwareIOCs;
	}

	@Override
	public Set<String> getmalwareTags(MalwareDTO malwareDTO) {
		Set<String> tags = new HashSet<String>();
		try {
			if (malwareDTO != null) {
				if (!CollectionUtils.isEmpty(malwareDTO.getIndustries()))
					tags.addAll(malwareDTO.getIndustries());
				if (!CollectionUtils.isEmpty(malwareDTO.getGeographies()))
					tags.addAll(malwareDTO.getGeographies());
				if (!CollectionUtils.isEmpty(malwareDTO.getTechnologies()))
					tags.addAll(malwareDTO.getTechnologies());
				if (!CollectionUtils.isEmpty(malwareDTO.getAliases()))
					tags.addAll(malwareDTO.getAliases());
				if (!CollectionUtils.isEmpty(malwareDTO.getTtps()))
					tags.addAll(malwareDTO.getTtps());
				if (StringUtils.hasText(malwareDTO.getName()))
					tags.add(malwareDTO.getName());
				if (StringUtils.hasText(malwareDTO.getRecommendations())) {
					tags.addAll(Arrays.asList(malwareDTO.getRecommendations().toLowerCase().split(" ")));
					tags.addAll(Arrays.asList(malwareDTO.getRecommendations().toLowerCase().split(",")));
				}
				if (StringUtils.hasText(malwareDTO.getDescription())) {
					tags.addAll(Arrays.asList(malwareDTO.getDescription().toLowerCase().split(" ")));
					tags.addAll(Arrays.asList(malwareDTO.getDescription().toLowerCase().split(",")));
				}
				if (!CollectionUtils.isEmpty(malwareDTO.getThreatActors())) {
					for (Map<String, String> thratActorMap : malwareDTO.getThreatActors()) {
						if (thratActorMap != null && StringUtils.hasText(thratActorMap.get("name"))) {
							tags.add(thratActorMap.get("name"));
						}
					}
				}

			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return tags;
	}

	@Override
	public List<MalwareStix21> getMalwareStixRelationJson21(Long id) {
		SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
		List<MalwareStix21> malwareStix21s = new ArrayList<>();
		ClientThreatCorrelation clientThreatCorrelation = clientThreatCorrelationRepository.findTop1ByOrgId(id);
		if (clientThreatCorrelation != null
				/* && clientThreatCorrelation.isRestrictMalwares() */ && isNotEmptyCollection(
						clientThreatCorrelation.getMalwares())) {
			Page<Malware> malwares = malwareRepository.findByNameInAndAliasesIn(clientThreatCorrelation.getMalwares(),
					clientThreatCorrelation.getMalwares(),
					super.getPageRequest(0, 100, Sort.Direction.DESC, "riskRating"));
			if (isNotEmptyCollection(malwares.getContent())) {
				malwares.getContent()
						.forEach(i -> malwareStix21s.add(stix2Objects.getMalwareStix21Obj(i, dateFormatter)));
			}
		}
		return malwareStix21s;
	}
	
	public ByteArrayInputStream getActualData() throws IOException {
		List<MalwareUpdateAuditCount> all = malwareUpdateCountAuditRepository.findAll();
		
		ByteArrayInputStream byteArrayInputStream = MalwareHistoryDownloadHelper.dataToExcel(all);
		return byteArrayInputStream;
	}

}




package com.cyfirma.core.service;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.cyfirma.core.domain.stix.v2_1.MalwareStix21;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import com.cyfirma.core.domain.MalwareIOC;
import com.cyfirma.core.service.dto.MalwareDTO;
import com.cyfirma.core.service.dto.MalwareIOCAttribute;

/**
 * Service Interface for managing Malware.
 */
public interface MalwareService {

    /**
     * Save a malware.
     *
     * @param malwareDTO the entity to save
     * @return the persisted entity
     */
    MalwareDTO save(MalwareDTO malwareDTO);

    /**
     * Get all the malwares.
     *
     * @param pageable the pagination information
     * @return the list of entities
     */
    Page<MalwareDTO> findAll(Pageable pageable);


    /**
     * Get the "id" malware.
     *
     * @param id the id of the entity
     * @return the entity
     */
    MalwareDTO findById(String id);

    /**
     * Delete the "id" malware.
     *
     * @param id the id of the entity
     */
    void delete(String id);

	Set<String> findAllMalwareNames();

	Page<MalwareDTO> findAllByName(String name, Pageable pageable);

	List<Map<String, String>> malwareListMatching(List<String> malwareNames);

	void updateFromAlienVaultMalwareList();

	Page<MalwareDTO> findDashboardList(Integer size, Long orgId, Long from, Long to, Pageable pageable);

	String getIndicatorType(String indicatorType);

	Page<MalwareIOC> searchIOC(String malwareId, String clientName, String indicatorType, String search, Date fromDate, Date toDate, Pageable pageable);

	MalwareIOCAttribute setIOCAttributes(List<MalwareIOC> iocList);

	void updateFromAlienVaultMalwareIOC();

	MalwareIOC saveMalwareIOC(MalwareIOC malwareIOC);

	List<MalwareIOC> getMalwareIOC(String indicatorType, MalwareIOC malwareIOC);

	void malwareBazaarIOCDownload();

	void scrapeAnyrunIOC();

	Set<String> findAllMalwareIndustryNames();

	MalwareIOC saveIOCsOnly(MalwareIOC malwareIOC);

	List<MalwareIOC> getMampaignIOC(String indicatorType, MalwareIOC malwareIOC);

	Set<String> getmalwareTags(MalwareDTO malwareDTO);

    List<MalwareStix21> getMalwareStixRelationJson21(Long id);

	ByteArrayInputStream getActualData() throws IOException;
}



package com.cyfirma.core.web.rest;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URI;
import java.net.URISyntaxException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.TimeZone;
import java.util.stream.Collectors;

import javax.servlet.http.HttpServletResponse;

import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.InputStreamResource;
import org.springframework.core.io.Resource;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.util.CollectionUtils;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.codahale.metrics.annotation.Timed;
import com.cyfirma.core.config.Constants;
import com.cyfirma.core.domain.CTIEnterprise;
import com.cyfirma.core.domain.Malware;
import com.cyfirma.core.domain.MalwareIOC;
import com.cyfirma.core.domain.MalwareUpdateAuditCount;
import com.cyfirma.core.domain.PhaseDetails;
import com.cyfirma.core.domain.RecentCampaign;
import com.cyfirma.core.domain.ThreatIOC;
import com.cyfirma.core.domain.UserActivityLogs;
import com.cyfirma.core.repository.CTIEnterpriseRepository;
import com.cyfirma.core.repository.MalwareIOCRepository;
import com.cyfirma.core.repository.MalwareRepository;
import com.cyfirma.core.repository.MalwareUpdateCountAuditRepository;
import com.cyfirma.core.repository.RecentCampaignRepository;
import com.cyfirma.core.repository.UserActivityLogsRepository;
import com.cyfirma.core.service.MalwareAuditService;
import com.cyfirma.core.service.MalwareService;
import com.cyfirma.core.service.MasterDataService;
import com.cyfirma.core.service.MasterSecurityAuditService;
import com.cyfirma.core.service.ThreatIOCService;
import com.cyfirma.core.service.dto.MalwareAuditDTO;
import com.cyfirma.core.service.dto.MalwareDTO;
import com.cyfirma.core.service.dto.OrgDTO;
import com.cyfirma.core.service.impl.CTIEnterpriseServiceImpl;
import com.cyfirma.core.service.impl.MasterDataServiceImpl;
import com.cyfirma.core.service.impl.OrgUser;
import com.cyfirma.core.service.threatview.ThreatViewService;
import com.cyfirma.core.web.rest.errors.BadRequestAlertException;
import com.cyfirma.core.web.rest.util.HeaderUtil;
import com.cyfirma.core.web.rest.util.PaginationUtil;

import liquibase.util.csv.CSVReader;
import liquibase.util.csv.opencsv.CSVWriter;
import tech.jhipster.web.util.ResponseUtil;

/**
 * REST controller for managing Malware.
 */
@RestController
@RequestMapping("/api")
public class MalwareResource extends BaseResource {

    private final Logger log = LoggerFactory.getLogger(MalwareResource.class);

    private static final String ENTITY_NAME = "coreMalware";

    private final MalwareService malwareService;
    
    @Autowired private MalwareUpdateCountAuditRepository malwareUpdateCountAuditRepository;
    @Autowired private CTIEnterpriseRepository ctiEnterpriseRepository; 
    @Autowired private MasterSecurityAuditService masterSecurityAuditService;
    @Autowired private MalwareRepository malwareRepository;
    @Autowired private MalwareIOCRepository malwareIOCRepository;
    @Autowired private ThreatIOCService threatIOCService;
    @Autowired private MalwareAuditService malwareAuditService;
    @Autowired private CTIEnterpriseServiceImpl     ctiEnterpriseService;
    @Autowired private ThreatViewService threatViewService;
    @Autowired private MasterDataService masterDataService;
    @Autowired private UserActivityLogsRepository    userActivityLogsRepository;
    @Autowired private RecentCampaignRepository recentCampaignRepository;

    public MalwareResource(MalwareService malwareService) {
        this.malwareService = malwareService;
    }

    /**
     * POST  /malwares : Create a new malware.
     *
     * @param malwareDTO the malwareDTO to create
     * @return the ResponseEntity with status 201 (Created) and with body the new malwareDTO, or with status 400 (Bad Request) if the malware has already an ID
     * @throws URISyntaxException if the Location URI syntax is incorrect
     */
    @PostMapping("/malwares")
    @Timed
    public ResponseEntity<MalwareDTO> createMalware(@RequestBody MalwareDTO malwareDTO) throws URISyntaxException {
        log.debug("REST request to save Malware : {}", malwareDTO);
        List<Malware> malwares = malwareRepository.findAllByNameIgnoreCase(malwareDTO.getName());
        if (malwareDTO.getId() != null) {
            throw new BadRequestAlertException("A new malware cannot already have an ID", ENTITY_NAME, "idexists");
        }
        if (!CollectionUtils.isEmpty(malwares)) {
        	throw new BadRequestAlertException("Malware name already exists in DB", ENTITY_NAME, "nameexists");
        }
        malwareDTO.setCreatedBy(getLoggedInUserName());
        malwareDTO.setModifiedBy(getLoggedInUserName());
		if (malwareDTO.getCreated() == null || StringUtils.isEmpty(malwareDTO.getCreated().toString()))
			malwareDTO.setCreated(LocalDate.now());
        MalwareDTO result = malwareService.save(malwareDTO);
        return ResponseEntity.created(new URI("/api/malwares/" + result.getId()))
            .headers(HeaderUtil.createEntityCreationAlert(ENTITY_NAME, result.getId().toString()))
            .body(result);
    }
    
    
    @PostMapping("/malwares/create")
    @Timed
    public ResponseEntity<Object> create(@RequestBody Map<String, Object> inputMap) throws URISyntaxException {
        log.debug("REST request to save Malware : {}", inputMap);
        /*if (malwareDTO.getId() != null) {
            throw new BadRequestAlertException("A new malware cannot already have an ID", ENTITY_NAME, "idexists");
        }*/
        MalwareDTO malwareDTO = new MalwareDTO();
        DateTimeFormatter formatter = null;
        
        
        if(inputMap.get("name").toString() != null){
        	String name= inputMap.get("name").toString();
        	malwareDTO.setName(name);
        }
        if(inputMap != null && inputMap.get("description") != null && !inputMap.get("description").equals("null")){
        	String description= inputMap.get("description").toString();
        	malwareDTO.setDescription(description);
        }
        if(inputMap != null && inputMap.get("url") != null && !inputMap.get("url").equals("null")){
        	String url= inputMap.get("url").toString() ;
        	String[] urls = url.split(",");
    		Set<String> url2 = new HashSet<String>(Arrays.asList(urls));
    		malwareDTO.setUrl(url2);
        }
        if(inputMap != null && inputMap.get("sourceName") != null && !inputMap.get("sourceName").equals("null")){
        	String sourceName= inputMap.get("sourceName").toString();	
        	String[] sourceNames = sourceName.split(",");
    		Set<String> sourceName2 = new HashSet<String>(Arrays.asList(sourceNames));
    		malwareDTO.setSourceName(sourceName2);
    		
        }
        if(inputMap != null && inputMap.get("externalId") != null && !inputMap.get("externalId").equals("null")){
        	String externalId= inputMap.get("externalId").toString();	
        	String[] externalIds = externalId.split(",");
    		Set<String> externalId2 = new HashSet<String>(Arrays.asList(externalIds));
    		malwareDTO.setExternalId(externalId2);
        }
        if(inputMap != null && inputMap.get("createdBy") != null && !inputMap.get("createdBy").equals("null")){
        	String createdBy= inputMap.get("createdBy").toString();
        	malwareDTO.setCreatedBy(createdBy);
        }
        if(inputMap != null && inputMap.get("created") != null && !inputMap.get("created").equals("null")){
        	String created= inputMap.get("created").toString();
        	log.debug("Created:"+created);
        	formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
            LocalDate createdDate = LocalDate.parse(created, formatter);
            malwareDTO.setCreated(createdDate);
            
        }
        if(inputMap != null && inputMap.get("modified") != null && !inputMap.get("modified").equals("null")){
        	String modified= inputMap.get("modified").toString();
        	log.debug("Modified:"+modified);
        	formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
            LocalDate modifiedDate = LocalDate.parse(modified, formatter);
            malwareDTO.setModified(modifiedDate);
        	
        }
        if(inputMap != null && inputMap.get("type") != null && !inputMap.get("type").equals("null")){
        	String type= inputMap.get("type").toString();
        	malwareDTO.setType(type);
        }
        if(inputMap != null && inputMap.get("aliases") != null && !inputMap.get("aliases").equals("null")){
        	String aliases= inputMap.get("aliases").toString();
        	String[] aliasess = aliases.split(",");
    		Set<String> aliases2 = new HashSet<String>(Arrays.asList(aliasess));
    		malwareDTO.setAliases(aliases2);
        }
        malwareDTO.setModifiedBy(getLoggedInUserName());
        malwareDTO = malwareService.save(malwareDTO);
        return ResponseEntity.created(new URI("/api/malwares/" + malwareDTO.getId()))
            .headers(HeaderUtil.createEntityCreationAlert(ENTITY_NAME, malwareDTO.getId().toString()))
            .body(malwareDTO);
    }
    
    /**
     * PUT  /malwares : Updates an existing malware.
     *
     * @param malwareDTO the malwareDTO to update
     * @return the ResponseEntity with status 200 (OK) and with body the updated malwareDTO,
     * or with status 400 (Bad Request) if the malwareDTO is not valid,
     * or with status 500 (Internal Server Error) if the malwareDTO couldn't be updated
     * @throws URISyntaxException if the Location URI syntax is incorrect
     */
    @PutMapping("/malwares")
    @Timed
	public ResponseEntity<MalwareDTO> updateMalware(@RequestBody MalwareDTO malwareDTO) throws URISyntaxException {
		log.debug("REST request to update Malware : {}", malwareDTO);
		MalwareDTO exsMalware = malwareService.findById(malwareDTO.getId());
		List<Malware> malwares = malwareRepository.findAllByNameIgnoreCase(malwareDTO.getName());
		if (malwareDTO.getId() == null) {
			throw new BadRequestAlertException("Invalid id", ENTITY_NAME, "idnull");
		}
		if (!CollectionUtils.isEmpty(malwares)) {
			malwares.forEach(malwareList -> {
				if (!malwareList.getId().equalsIgnoreCase(malwareDTO.getId())) {
					throw new BadRequestAlertException("Malware name already exists in DB", ENTITY_NAME, "nameexists");
				}
			});
		}
		malwareDTO.setCreatedBy(exsMalware.getCreatedBy());
		malwareDTO.setCreated(exsMalware.getCreated());
		malwareDTO.setModifiedBy(getLoggedInUserName());
		if (malwareDTO.getModified() == null || StringUtils.isEmpty(malwareDTO.getModified().toString()))
			malwareDTO.setModified(LocalDate.now());
		if (malwareDTO.getDetailedDescription() != null && exsMalware.getDetailedDescription() != null) {
			if (!exsMalware.getDetailedDescription().equalsIgnoreCase(malwareDTO.getDetailedDescription())) {
				malwareDTO.setDetailDescriptionModified(LocalDate.now());
			}
		}
		MalwareDTO result = malwareService.save(malwareDTO);
		//malwareaudit starts
		MalwareAuditDTO malwareAuditDTO = new MalwareAuditDTO();
		malwareAuditDTO.setAliases(exsMalware.getAliases());
		malwareAuditDTO.setAssociatedCampaigns(exsMalware.getAssociatedCampaigns());
		malwareAuditDTO.setDescription(exsMalware.getDescription());
		malwareAuditDTO.setDetailedDescription(exsMalware.getDetailedDescription());
		malwareAuditDTO.setExternalId(exsMalware.getExternalId());
		malwareAuditDTO.setFeatures(exsMalware.getFeatures());
		malwareAuditDTO.setFirstSeen(exsMalware.getFirstSeen());
		malwareAuditDTO.setLastSeen(exsMalware.getLastSeen());
		malwareAuditDTO.setGeographies(exsMalware.getGeographies());
		malwareAuditDTO.setGroup(exsMalware.getGroup());
		malwareAuditDTO.setIndustries(exsMalware.getIndustries());
		malwareAuditDTO.setIndustry(exsMalware.getIndustry());
		malwareAuditDTO.setIoc(exsMalware.getIoc());
		malwareAuditDTO.setMalwareVariants(exsMalware.getMalwareVariants());
		malwareAuditDTO.setMitigationUrl(exsMalware.getMitigationUrl());
		malwareAuditDTO.setModifiedBy(getLoggedInUserName());
		malwareAuditDTO.setModified(LocalDate.now());
		malwareAuditDTO.setName(exsMalware.getName());
		malwareAuditDTO.setRecommendations(exsMalware.getRecommendations());
		malwareAuditDTO.setRiskRating(exsMalware.getRiskRating());
		malwareAuditDTO.setSourceName(exsMalware.getSourceName());
		malwareAuditDTO.setTechnologies(exsMalware.getTechnologies());
		malwareAuditDTO.setThreatActor(exsMalware.getThreatActor());
		malwareAuditDTO.setThreatActors(exsMalware.getThreatActors());
		malwareAuditDTO.setTtps(exsMalware.getTtps());
		malwareAuditDTO.setType(exsMalware.getType());
		malwareAuditDTO.setUrl(exsMalware.getUrl());
		malwareAuditDTO.setMalwareId(malwareDTO.getId());
		malwareAuditDTO.setDetailDescriptionModified(exsMalware.getDetailDescriptionModified());
		malwareAuditDTO = malwareAuditService.save(malwareAuditDTO);
		return ResponseEntity.ok()
				.headers(HeaderUtil.createEntityUpdateAlert(ENTITY_NAME, malwareDTO.getId().toString())).body(result);
	}
    
	@PutMapping("/malwares/update")
	@Timed
	public ResponseEntity<Object> update(@RequestBody Map<String, Object> inputMap) throws URISyntaxException {
		MalwareDTO malwareDTO = new MalwareDTO();
		DateTimeFormatter formatter = null;

		if (inputMap.get("id").toString() != null) {
			String id = inputMap.get("id").toString();
			malwareDTO.setId(id);
		}
		if (inputMap.get("name").toString() != null) {
			String name = inputMap.get("name").toString();
			malwareDTO.setName(name);
		}
		if (inputMap != null && inputMap.get("description") != null && !inputMap.get("description").equals("null")) {
			String description = inputMap.get("description").toString();
			malwareDTO.setDescription(description);
		}
		if (inputMap != null && inputMap.get("url") != null && !inputMap.get("url").equals("null")) {
			String url = inputMap.get("url").toString().replace("[", "").replace("]", "");
			String[] urls = url.split(",");
			Set<String> url2 = new HashSet<String>(Arrays.asList(urls));
			malwareDTO.setUrl(url2);
		}
		if (inputMap != null && inputMap.get("sourceName") != null && !inputMap.get("sourceName").equals("null")) {
			String sourceName = inputMap.get("sourceName").toString().replace("[", "").replace("]", "");
			String[] sourceNames = sourceName.split(",");
			Set<String> sourceName2 = new HashSet<String>(Arrays.asList(sourceNames));
			malwareDTO.setSourceName(sourceName2);

		}
		if (inputMap != null && inputMap.get("externalId") != null && !inputMap.get("externalId").equals("null")) {
			String externalId = inputMap.get("externalId").toString().replace("[", "").replace("]", "");
			String[] externalIds = externalId.split(",");
			Set<String> externalId2 = new HashSet<String>(Arrays.asList(externalIds));
			malwareDTO.setExternalId(externalId2);
		}
		if (inputMap != null && inputMap.get("createdBy") != null && !inputMap.get("createdBy").equals("null")) {
			String createdBy = inputMap.get("createdBy").toString();
			malwareDTO.setCreatedBy(createdBy);
		}
		if (inputMap != null && inputMap.get("created") != null && !inputMap.get("created").equals("null")) {
			String created = inputMap.get("created").toString();
			log.debug("Created:" + created);
			formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
			LocalDate createdDate = LocalDate.parse(created, formatter);
			malwareDTO.setCreated(createdDate);

		}
		if (inputMap != null && inputMap.get("modified") != null && !inputMap.get("modified").equals("null")) {
			String modified = inputMap.get("modified").toString();
			log.debug("Modified:" + modified);
			formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
			LocalDate modifiedDate = LocalDate.parse(modified, formatter);
			malwareDTO.setModified(modifiedDate);

		}
		if (inputMap != null && inputMap.get("type") != null && !inputMap.get("type").equals("null")) {
			String type = inputMap.get("type").toString();
			malwareDTO.setType(type);
		}
		if (inputMap != null && inputMap.get("aliases") != null && !inputMap.get("aliases").equals("null")) {
			String aliases = inputMap.get("aliases").toString().replace("[", "").replace("]", "");
			String[] aliasess = aliases.split(",");
			Set<String> aliases2 = new HashSet<String>(Arrays.asList(aliasess));
			malwareDTO.setAliases(aliases2);
		}
		malwareDTO.setModifiedBy(getLoggedInUserName());
		malwareDTO = malwareService.save(malwareDTO);
		return ResponseEntity.ok()
				.headers(HeaderUtil.createEntityUpdateAlert(ENTITY_NAME, malwareDTO.getId().toString()))
				.body(malwareDTO);
	}

    /**
     * GET  /malwares : get all the malwares.
     *
     * @param pageable the pagination information
     * @return the ResponseEntity with status 200 (OK) and the list of malwares in body
     */
    @GetMapping("/malwares")
    @Timed
    public ResponseEntity<List<MalwareDTO>> getAllMalwares(Pageable pageable) {
        log.debug("REST request to get a page of Malwares");
        int pno = 0;
        int psize = 20;
        Sort sort = null;
        if(pageable!=null) {
       		pno = pageable.getPageNumber();
       		if(pageable.getPageSize()==0)
       			psize = pageable.getPageSize();
       		if(pageable.getSort()!=null)
       			sort = pageable.getSort();
        }
        if(pageable.getSort()==null)
        	sort = Sort.by(new Sort.Order(Sort.Direction.DESC, "lastSeen", Sort.NullHandling.NULLS_LAST),
        			new Sort.Order(Sort.Direction.DESC, "riskRating", Sort.NullHandling.NULLS_LAST));
        Page<MalwareDTO> page = malwareService.findAll(PageRequest.of(pno, psize, sort));
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(page, "/api/malwares");
        return new ResponseEntity<>(page.getContent(), headers, HttpStatus.OK);
    }

    @GetMapping("/malwares/search")
    @Timed
    public ResponseEntity<List<MalwareDTO>> searchByName(@RequestParam String name, @RequestParam(required = false) Long orgId,Pageable pageable) {
        log.debug("REST request to get a page of Malwares");    
        Long orgIds = null;
        if(orgId !=null && orgId>0) {
        	orgIds = orgId;
        } else {
        	orgIds = masterDataService.getOrgUserAuthorized(getLoggedInUserName()).getOrgId();
        }	

        final Set<String> orgIndustryList = masterDataService.getOrgBasicIndustriesUnauthorized(orgIds);
     	final Set<String> orgGeographyList = masterDataService.getOrgGeographiesUnauthorized(orgIds);
     	final Set<String> orgTechList = masterDataService.getOrgTechnologiesAssetsAndAttackSurfaceServersUnauthorized(orgIds, false);
     	Set<RecentCampaign> activeCampaigns  =  threatViewService.getActiveCampaign(orgIds);
     	
        Page<MalwareDTO> page = malwareService.findAllByName(name,pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(page, "/api/malwares");
        if(page!=null && !CollectionUtils.isEmpty(page.getContent())) {
        	List<MalwareDTO> malwares = page.getContent();
        	for(MalwareDTO malwareDTO:malwares) {
   			 	if (malwareDTO != null && !StringUtils.isEmpty(malwareDTO.getId())) {
   			 //	 Set<Map<String, String>> taMpaData =malwareDTO.getThreatActors();
   	        	
					/*
					 * Set<String> taList=new HashSet<String>();
					 * if(!CollectionUtils.isEmpty(taMpaData)) { for(Map<String,String>
					 * map:taMpaData) { for(Map.Entry<String, String> data:map.entrySet()) {
					 * if(data.getKey().equalsIgnoreCase("name")) taList.add(data.getValue()); } } }
					 */
   	        	List<CTIEnterprise> listdata=ctiEnterpriseService. getCTIEnterpriseByMalware(malwareDTO.getName());
   	        	List<CTIEnterprise> listdataAias=new ArrayList<CTIEnterprise>();
   	        	if(CollectionUtils.isEmpty(listdata)){
   	        	Boolean isPresent=false;
   	        	Set<String>malwareAlias=malwareDTO.getAliases();
   	        	if(!CollectionUtils.isEmpty(malwareAlias)) {	
   	        		for(String malwareData:malwareAlias) {
   	        			if(!isPresent) {
   	        			listdataAias=ctiEnterpriseService. getCTIEnterpriseByMalware(malwareData);
   	        			if(!CollectionUtils.isEmpty(listdataAias) &&!isPresent) {
   	        				if(CollectionUtils.isEmpty(listdata))
   	        				{
   	        					listdata=new LinkedList<CTIEnterprise>();
   	        					listdata.addAll(listdataAias);
   	        				}else
   	        				listdata.addAll(listdataAias);
   	        				isPresent=true;
   	        			}
   	        		}  
   	        		}
   	        		
   	        	} 
   	        	}
   	        	Set<String> threatActors = new HashSet<String>();
   	    		for (Map<String, String> map : malwareDTO.getThreatActors()) {
   	    			String tA = map.get("name");
   	    			threatActors.add(tA);
   	    		}
   	    		Set<String> campaign = new HashSet<String>();
   	    		for (Map<String, String> map : malwareDTO.getAssociatedCampaigns()) {
   	    			String recentCampaign = map.get("name");
   	    			campaign.add(recentCampaign);
   	    		}
   	        	// ----------------relavancy code ------------------------//	  
   	  		  Set<String> tags = malwareService.getmalwareTags(malwareDTO);
   	  		  threatViewService.validaterRelevantOrgConfigDataSet(malwareDTO, malwareDTO.getDescription(), tags, orgIndustryList, orgGeographyList, orgTechList, activeCampaigns, threatActors, null, campaign);
   	  		
   	  		//------------------end --------------------------------//
   	        	
   	        	if(!CollectionUtils.isEmpty(listdata)){	
   	        		PhaseDetails phasedetails=ctiEnterpriseService.getPhaseDetails(listdata);
   				    if(phasedetails!=null)
   				    	malwareDTO.setPhaseDetails(phasedetails);
   	        	}
   			 		Calendar c = Calendar.getInstance();
   			 		c.add(Calendar.YEAR, -1);
   		        	List<MalwareIOC> listIOC = malwareIOCRepository.findByMalwareIdAndLastSeenGreaterThanOrderByLastSeenDesc(malwareDTO.getId(), c.getTime());
   		        	if (!CollectionUtils.isEmpty(listIOC))
   		        		malwareDTO.setIocAttributes(malwareService.setIOCAttributes(listIOC));  	
		        }
        	}
        }
        return new ResponseEntity<>(page.getContent(), headers, HttpStatus.OK);
    }
    
    /**
     * GET  /malwares/:id : get the "id" malware.
     *
     * @param id the id of the malwareDTO to retrieve
     * @return the ResponseEntity with status 200 (OK) and with body the malwareDTO, or with status 404 (Not Found)
     */
    @GetMapping("/malwares/key-search")
    @Timed
    public ResponseEntity<List<Malware>> malwareSearch(@RequestParam(required = false) String key) {
        log.debug("REST request to search Malware : {}", key);
        List<Malware> result = new ArrayList<>();
        if (key != null && !StringUtils.isEmpty(key))
        	result = malwareRepository.findAllByNameContainingIgnoreCaseOrAliasesRegexOrTypeContainingIgnoreCase(key, "^(?i)"+key, key);
        return ResponseUtil.wrapOrNotFound(Optional.ofNullable(result));
    }
    
    /**
     * GET  /malwares/:id : get the "id" malware.
     *
     * @param id the id of the malwareDTO to retrieve
     * @return the ResponseEntity with status 200 (OK) and with body the malwareDTO, or with status 404 (Not Found)
     */
    @GetMapping("/malwares/{id}")
    @Timed
    public ResponseEntity<MalwareDTO> getMalware(@PathVariable String id,@RequestParam(required = false) Long orgId) {
        log.debug("REST request to get Malware : {}", id);
    
        Long orgIds = null;
        if(orgId !=null && orgId>0) {
        	orgIds = orgId;
        } else {
        	orgIds = masterDataService.getOrgUserAuthorized(getLoggedInUserName()).getOrgId();
        }	
        OrgDTO org = masterDataService.getOrgUnauthorized(orgIds);
        
        final Set<String> orgIndustryList = masterDataService.getOrgBasicIndustriesUnauthorized(orgIds);
		final Set<String> orgGeographyList = masterDataService.getOrgGeographiesUnauthorized(orgIds);
		final Set<String> orgTechList = masterDataService.getOrgTechnologiesAssetsAndAttackSurfaceServersUnauthorized(orgIds, false);
		Set<RecentCampaign> activeCampaigns  =  threatViewService.getActiveCampaign(orgIds);

        MalwareDTO malwareDTO = malwareService.findById(id);
        if(org!=null && org.getPov()!=null && (org.getPov().equalsIgnoreCase(Constants.Account_Package.TRIAL_POV))) {
			Long todaycount=userActivityLogsRepository.countByOrgIdAndCategoryAndDateGreaterThan(org.getId(),"Malware",LocalDate.now().minusDays(1));
			UserActivityLogs userActivity=	userActivityLogsRepository.findTop1ByOrgIdAndCategoryAndDateGreaterThan(org.getId(),"Malware",LocalDate.now().minusDays(1));
			if(todaycount==0) {
			UserActivityLogs userActivityLogs=new UserActivityLogs();
			userActivityLogs.setDate(LocalDate.now());
			userActivityLogs.setCategory("Malware");
			userActivityLogs.setValue(malwareDTO.getName());
			userActivityLogs.setOrgId(org.getId());
			userActivityLogsRepository.save(userActivityLogs);
			}else if(userActivity!=null &&  userActivity.getValue()!=null && !userActivity.getValue().equalsIgnoreCase(malwareDTO.getName()) ) {
				return  new ResponseEntity<MalwareDTO>(new MalwareDTO (),HttpStatus.FORBIDDEN);
			}
        }	
        if (malwareDTO != null && !StringUtils.isEmpty(malwareDTO.getId())) {
			/*
			 * Set<Map<String, String>> taMpaData =malwareDTO.getThreatActors();
			 * 
			 * Set<String> taList=new HashSet<String>();
			 * if(!CollectionUtils.isEmpty(taMpaData)) { for(Map<String,String>
			 * map:taMpaData) { for(Map.Entry<String, String> data:map.entrySet()) {
			 * if(data.getKey().equalsIgnoreCase("name")) taList.add(data.getValue()); } } }
			 */
        	List<CTIEnterprise> listdata=ctiEnterpriseService. getCTIEnterpriseByMalware(malwareDTO.getName());
        	List<CTIEnterprise> listdataAias=new ArrayList<CTIEnterprise>();
        	if(CollectionUtils.isEmpty(listdata)){
        		Boolean isPresent=false;
        	Set<String>malwareAlias=malwareDTO.getAliases();
        	if(!CollectionUtils.isEmpty(malwareAlias)){	
        		for(String malwareData:malwareAlias) {
        			if(!isPresent) {
        			listdataAias=ctiEnterpriseService. getCTIEnterpriseByMalware(malwareData);
        			if(!CollectionUtils.isEmpty(listdataAias) &&!isPresent) {
        				if(CollectionUtils.isEmpty(listdata))
	        				{
	        					listdata=new LinkedList<CTIEnterprise>();
	        					listdata.addAll(listdataAias);
	        				}else
        				listdata.addAll(listdataAias);
        				isPresent=true;
        			}
        		}   
        		}
        		
        	} 
        	}
        	if(!CollectionUtils.isEmpty(listdata)){	
        		PhaseDetails phasedetails=ctiEnterpriseService.getPhaseDetails(listdata);
			    if(phasedetails!=null)
			    	malwareDTO.setPhaseDetails(phasedetails);
        	}
        	Calendar c = Calendar.getInstance();
        	c.add(Calendar.YEAR, -1);
        	List<MalwareIOC> listIOC = malwareIOCRepository.findByMalwareIdAndLastSeenGreaterThanOrderByLastSeenDesc(malwareDTO.getId(), c.getTime());
        	if (!CollectionUtils.isEmpty(listIOC)) {
        		malwareDTO.setIocAttributes(malwareService.setIOCAttributes(listIOC));
        	}
        	
        	Set<String> threatActors = new HashSet<String>();
    		for (Map<String, String> map : malwareDTO.getThreatActors()) {
    			String tA = map.get("name");
    			threatActors.add(tA);
    		}
    		Set<String> campaign = new HashSet<String>();
    		for (Map<String, String> map : malwareDTO.getAssociatedCampaigns()) {
    			String recentCampaign = map.get("name");
    			campaign.add(recentCampaign);
    		}
        	// ----------------relavancy code ------------------------//	  
  		  Set<String> tags = malwareService.getmalwareTags(malwareDTO);
  		  threatViewService.validaterRelevantOrgConfigDataSet(malwareDTO, malwareDTO.getDescription(), tags, orgIndustryList, orgGeographyList, orgTechList, activeCampaigns, threatActors, null, campaign);
  		
  		//------------------end --------------------------------//
        	
        }
        return ResponseUtil.wrapOrNotFound(Optional.ofNullable(malwareDTO));
    }

    /**
     * DELETE  /malwares/:id : delete the "id" malware.
     *
     * @param id the id of the malwareDTO to delete
     * @return the ResponseEntity with status 200 (OK)
     */
	@DeleteMapping("/malwares/{id}")
	@Timed
	public ResponseEntity<Void> deleteMalware(@PathVariable String id) {
		log.debug("REST request to delete Malware : {}", id);
		if (masterDataService.haveAccess(getLoggedInUserName(), -1l)) {
			MalwareDTO malwareDTO = malwareService.findById(id);
			OrgUser orgUser = masterDataService.getOrgUserAuthorized(getLoggedInUserName());
			masterSecurityAuditService.saveAudit(orgUser.getOrgId(), orgUser.getOrgName(), orgUser.getEmail(), Malware.class.getName(),
					Constants.SecurityAuditAction.malwareDelete, null, malwareDTO);
			malwareService.delete(id);
			return ResponseEntity.ok().headers(HeaderUtil.createEntityDeletionAlert(ENTITY_NAME, id)).build();
		} else {
			return ResponseEntity.badRequest().headers(HeaderUtil.createEntityDeletionAlert(ENTITY_NAME, id)).build();
		}
	}
    
    @PostMapping("/malwares/updation-by-ctienterprise")
    @Timed
    public ResponseEntity<List<MalwareDTO>> createMalware() throws URISyntaxException {
        log.debug("REST request to save Malware : {}");
        List<CTIEnterprise> ctis = ctiEnterpriseRepository.findByType("malware");
        List<MalwareDTO> malwareList = new ArrayList<>();
        if(!CollectionUtils.isEmpty(ctis)) {
        	for (CTIEnterprise ctiEnterprise : ctis) {
				MalwareDTO malwareDTO = new MalwareDTO(ctiEnterprise);
				MalwareDTO malware = malwareService.save(malwareDTO);
				malwareList.add(malware);
			}
        }
        return new ResponseEntity<>(malwareList , HttpStatus.OK);
    }
    
    @SuppressWarnings("unchecked")
	@PostMapping("/malwares/match")
    @Timed
    public ResponseEntity<List<Map<String,String>>> searchMalwareFromList(@RequestBody Map<String,Object> param) throws URISyntaxException {
        log.debug("REST request to Search Malware :");
        List<String> malwares = (List<String>) param.get("malwares");
        return new ResponseEntity<>(malwareService.malwareListMatching(malwares) , HttpStatus.OK);
    }

    @GetMapping("/malwares/update-from-alien-vault")
    @Timed
    public ResponseEntity<String> searchMalwareForAlienVaultByCuckooCount(@RequestBody Map<String,Object> param) throws URISyntaxException {
    	//malwareService.updateFromAlienVaultMalwareList();
    	return new ResponseEntity<>("api called malwareService.updateFromAlienVaultMalwareList()" , HttpStatus.OK);
    }
    
    @GetMapping("/malwares/list")
	@Timed
	public ResponseEntity<List<MalwareDTO>> getMalwareList(@RequestParam(required = false) Integer size, @RequestParam(required = false) Long orgId, 
			@RequestParam(required = false) Long from, @RequestParam(required = false) Long to, Pageable pageable) {
		log.debug("REST request to get all malware for dashboard");
		Page<MalwareDTO> page = malwareService.findDashboardList(size, orgId, from, to, pageable);
		HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(page, "/api/malwares/list");
		List<MalwareDTO> DTOs = page.getContent();
		for (MalwareDTO DTO : DTOs) {
			DTO.setIocs(malwareIOCRepository.findByMalwareId(DTO.getId()));
		}
		return new ResponseEntity<>(page.getContent(), headers, HttpStatus.OK);
	}
    
    @SuppressWarnings("deprecation")
	@GetMapping("/malwares/ioc-list")
	@Timed
	public ResponseEntity<List<MalwareIOC>> getMalwareIOCS(@RequestParam Map<String, String> param, Pageable pageable) {
		log.debug("REST request to get a page of MalwareIOCS");

		// String pattern = "yyyy-MM-dd";
		Date 	fromDate = null;
		Date 	toDate = null;
		String 	search = null;
		String  clientName = null;
		String  indicatorType = null;
		String  malwareId    = null;
		try {
			String pattern = "yyyy-MM-dd'T'HH:mm:ss'.000+0000'";	
			SimpleDateFormat dateFormatter1 = new SimpleDateFormat(pattern);
			if (param != null && param.get("fromDate") != null && !param.get("fromDate").equals("null") && !param.get("fromDate").isEmpty()) {
				fromDate = dateFormatter1.parse(dateFormatter1.format(new Date(Long.parseLong(param.get("fromDate")))));
			}
			if (param != null && param.get("toDate") != null && !param.get("toDate").equals("null") && !param.get("toDate").isEmpty()) {
				toDate = dateFormatter1.parse(dateFormatter1.format(new Date(Long.parseLong(param.get("toDate")))));
				toDate.setHours(23);
				toDate.setMinutes(60);
				toDate.setDate(toDate.getDate() + 1);
			}
			if (param != null && param.get("indicatorType") != null && !param.get("indicatorType").equals("null") && !param.get("indicatorType").isEmpty()) {
				indicatorType = param.get("indicatorType");
			}
			if (param != null && param.get("search") != null && !param.get("search").equals("null") && !param.get("search").isEmpty()) {
				search = param.get("search");
			}
			if (param != null && param.get("client") != null && !param.get("client").equals("null") && !param.get("client").isEmpty()) {
				//clientName = param.get("client");
			}
			if (param != null && param.get("iocClientFilter") != null && !param.get("iocClientFilter").equals("null") && !param.get("iocClientFilter").isEmpty()) {
				String  iocClientNameFilter = param.get("iocClientFilter");
				if(!StringUtils.isEmpty(iocClientNameFilter))
					clientName = iocClientNameFilter;
			}
			if (param != null && param.get("malwareId") != null)
				malwareId = param.get("malwareId");
		} catch (NumberFormatException e) {
			log.error("Exception in date formatter Malware IOC Req " + e);
		} catch (ParseException e) {
			log.error("Exception in date formatter Malware IOC Req " + e);
		}

		Page<MalwareIOC> page = malwareService.searchIOC(malwareId, clientName, indicatorType, search, fromDate, toDate, pageable);

		HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(page, "/api/malwares/ioc-list");
		List<MalwareIOC> DTOs = page.getContent();
		for(MalwareIOC tioc:DTOs){
			if(!StringUtils.isEmpty(clientName)) {
				tioc.setClientName(new HashSet<String>());
				tioc.setClientNameString(clientName);
				if(!CollectionUtils.isEmpty(tioc.getClientUIDs()) && tioc.getClientUIDs().containsKey(clientName)) {
					tioc.setUid(tioc.getClientUIDs().get(clientName));
					tioc.setClientUIDs(new HashMap<String,String>());
					tioc.getClientUIDs().put(clientName, tioc.getUid());
				} else {
					tioc.setClientName(new HashSet<String>());
					tioc.setClientUIDs(new HashMap<String,String>());
					tioc.setUid("");
				}
			} else {
				tioc.setClientName(new HashSet<String>());
				tioc.setClientUIDs(new HashMap<String,String>());
				tioc.setUid("");
			}
		}
		return new ResponseEntity<>(page.getContent(), headers, HttpStatus.OK);
	}
    
    @SuppressWarnings("unused")
	@PostMapping("/malwares/ioc-upload")
	@Timed
	public ResponseEntity<Object> uploadCsv(@RequestParam(required = false) String malwareId, @RequestParam("file") MultipartFile file) {
    	log.debug("REST request to upload malwares IOC csv");
    	StringBuilder resMsg = new StringBuilder();
		boolean isValid = true;
		Set<MalwareIOC> malwareIOCResult = new HashSet<>();
		try {
			InputStream is = file.getInputStream();
			BufferedReader br = new BufferedReader(new InputStreamReader(is));
			CSVReader reader = new CSVReader(br);
			List<String[]> lines = reader.readAll();
			reader.close();
			br.close();
			is.close();
			if(file!=null) {
				String fileExtension = FilenameUtils.getExtension(file.getOriginalFilename());
				if(!StringUtils.isEmpty(fileExtension) && !fileExtension.equalsIgnoreCase("csv")) {
				   return ResponseEntity.ok().headers(HeaderUtil.createEntityUpdateAlert(ENTITY_NAME, ""))
							.body("{\"status\":\"" + "error" + "\",\"message\":\"" + "The uploaded file is not of CSV format. Please upload a file in CSV format" + "\"}");
				}
				}
			int headerSize = 1;
			for (String lineValidation : lines.get(0)) {
				if (lineValidation.equalsIgnoreCase("description") || lineValidation.trim().toLowerCase().startsWith("description"))
					break;
				headerSize++;
			}

			boolean check = false;
			int lineNumber = 1;
			for (String[] lineValidation : lines) {
				check = false;
				int x = 0;
				for (String text : lineValidation) {
					x++;
					if (x > headerSize) {
						if (!StringUtils.isEmpty(text)) {
							check = true;
							break;
						}

					}
				}
				if (check) {
					resMsg.append("Extra Data after column Description at row no.  " + lineNumber);
					isValid = false;
				}
				lineNumber++;
			}

			lines.remove(0);
			Set<String> md5Add = new HashSet<>();
			Set<String> sha1Add = new HashSet<>();
			Set<String> sha256Add = new HashSet<>();
			Set<String> ipAdd = new HashSet<>();
			Set<String> urlAdd = new HashSet<>();
			Set<String> domainAdd = new HashSet<>();
			Set<String> uidAdd = new HashSet<>();
			int k = 1;
			for (String[] lineValidation : lines) {
				k++;
				String indicatorTypeVal = lineValidation[5].trim();
			//	String uidCheck = lineValidation[3].trim();
				String reccommendedActionCheck = lineValidation[17].trim();
				Date reportedDate = null;
				Date EidDate = null;
				
//				if (!StringUtils.isEmpty(lineValidation[3].trim())){
//					if(uidAdd.add(lineValidation[3].trim()) == false){
//						resMsg.append("Duplicate UID check in row no."+k);
//						isValid = false;
//					}
//				}
				
//				if (lineValidation[0].trim().equalsIgnoreCase("")) {
//					resMsg.append("Client name cannot be blank check row no." + k + "~");
//					isValid = false;
//				} else if (!file.getOriginalFilename().toLowerCase().contains(lineValidation[0].trim().toLowerCase())) {
//					resMsg.append("Client Name in Col A and Client Name mentioned in the filename should match, Check row no." + k);
//					isValid = false;
//				}
				
//				Set<String> orgNames = orgClient.getAllOrgsNameUnauthorized();
//				if(!orgNames.contains(lineValidation[0].trim().toLowerCase().toLowerCase())) {
//					resMsg.append("Client Name is not present in database, Check row no." + k + "~");
//					isValid = false;
//				}
				
//				if(uidCheck.equalsIgnoreCase("")){
//					resMsg.append("UID cannot be blank check row no." + k + "~");
//					isValid = false;
//				}
				
				if(reccommendedActionCheck.equalsIgnoreCase("")){
					resMsg.append("Recommended Action cannot be left blank check row no." + k + "~");
					isValid = false;
				}
				
				if (!StringUtils.isEmpty(lineValidation[1].trim())) {
					SimpleDateFormat formatter = new SimpleDateFormat("dd-MMM-yy");
					reportedDate = formatter.parse(lineValidation[1].trim());
					if (reportedDate != null && reportedDate.after(new Date())) {
						resMsg.append("Reported Date cannot be greater than current date check row no." + k + "~");
						isValid = false;
					}
				} else {
					resMsg.append("Reported Date cannot be left blank check row no." + k + "~");
					isValid = false;
				}
				
				//md5 duplicate check
				if (!StringUtils.isEmpty(lineValidation[8].trim())){
					if(md5Add.add(lineValidation[8].trim()) == false){
						resMsg.append("Duplicate MD5 hash check in row no."+k);
						isValid = false;
					}
				}
				
				//sha1 duplicate check
				if (!StringUtils.isEmpty(lineValidation[9].trim())){
					if(sha1Add.add(lineValidation[9].trim()) == false){
						resMsg.append("Duplicate SHA1 hash check in row no."+k);
						isValid = false;
					}
				}
				
				//sha256 duplicate check
				if (!StringUtils.isEmpty(lineValidation[10].trim())){
					if(sha256Add.add(lineValidation[10].trim()) == false){
						resMsg.append("Duplicate SHA256 hash check in row no."+k);
						isValid = false;
					}
				}
				
				//ip duplicate check
				if (!StringUtils.isEmpty(lineValidation[11].trim())){
					if(ipAdd.add(lineValidation[11].trim()) == false){
						resMsg.append("Duplicate IP adress check in row no."+k);
						isValid = false;
					}
				}
				
				//url duplicate check
				if (!StringUtils.isEmpty(lineValidation[12].trim())){
					if(urlAdd.add(lineValidation[12].trim()) == false){
						resMsg.append("Duplicate URL check in row no."+k);
						isValid = false;
					}
				}
				
				//domain duplicate check
				if (!StringUtils.isEmpty(lineValidation[13].trim())){
					if(domainAdd.add(lineValidation[13].trim()) == false){
						resMsg.append("Duplicate Domain check in row no."+k);
						isValid = false;
					}
				}
				
   //			String last = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf('_') + 1,file.getOriginalFilename().lastIndexOf("."));
				SimpleDateFormat formatter = new SimpleDateFormat("dd MMM yy");
	//			Date fileDate = formatter.parse(last);
				
//				if (!StringUtils.isEmpty(lineValidation[4].trim())) {
//					String eid = lineValidation[4].trim();
//					String eidDate = "";
//					eid = eid.substring(0,eid.lastIndexOf("-"));
//					eidDate = eid.substring(eid.length()-8);
//					formatter = new SimpleDateFormat("dd-MM-yy");
//					EidDate = formatter.parse(eidDate);
//				}
//					else {
//					resMsg.append("EID Field cannot be left blank check row no." + k + "~");
//					isValid = false;
//					break;
//				}
				
//				if(!reportedDate.equals(fileDate)){
//					resMsg.append("Date Mismatch check row no." + k + "~");
//					isValid = false;
//					break;
//				} else if(!reportedDate.equals(EidDate)) {
//					resMsg.append("Date Mismatch check row no." + k + "~");
//					isValid = false;
//					break;
//				} else if(!fileDate.equals(EidDate)) {
//					resMsg.append("Date Mismatch check row no." + k + "~");
//					isValid = false;
//					break;
//				}
//				
				if (!indicatorTypeVal.equalsIgnoreCase("File Hash") && !indicatorTypeVal.equalsIgnoreCase("IP Address") && !indicatorTypeVal.equalsIgnoreCase("IP") && !indicatorTypeVal.equalsIgnoreCase("Domain") && !indicatorTypeVal.equalsIgnoreCase("URL")
						&& !indicatorTypeVal.equalsIgnoreCase("Mutex") && !indicatorTypeVal.equalsIgnoreCase("Hostname") && !indicatorTypeVal.equalsIgnoreCase("Email")) {
					resMsg.append("Indicator type should be 'File Hash' or 'IP Address' or 'URL'  or 'Domain' or 'Hostname' or 'Mutex'  or 'Email'  check the row no " + k  +"~");
					isValid = false;
				}

				if (indicatorTypeVal.equalsIgnoreCase("file hash") || indicatorTypeVal.equalsIgnoreCase("file md5")
						|| indicatorTypeVal.equalsIgnoreCase("filehash") || indicatorTypeVal.equalsIgnoreCase("filemd5")
						|| indicatorTypeVal.equalsIgnoreCase("file_hash")
						|| indicatorTypeVal.equalsIgnoreCase("file_md5")
						|| indicatorTypeVal.equalsIgnoreCase("file-hash")
						|| indicatorTypeVal.equalsIgnoreCase("file-md5") || indicatorTypeVal.equalsIgnoreCase("hash")
						|| indicatorTypeVal.equalsIgnoreCase("md5") || indicatorTypeVal.equalsIgnoreCase("sha")
						|| indicatorTypeVal.equalsIgnoreCase("sha1") || indicatorTypeVal.equalsIgnoreCase("sha256")
						|| indicatorTypeVal.equalsIgnoreCase("sha512")) {

					if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim())
							|| !StringUtils.isEmpty(lineValidation[9].trim())
							|| !StringUtils.isEmpty(lineValidation[10].trim())) {
						if (!StringUtils.isEmpty(lineValidation[8].trim())) { // md5
							boolean md5Check = threatIOCService.validateIndicatorValue(Constants.IOCIndicatorType.MD5, lineValidation[8]);
							if (md5Check == false) {
								resMsg.append("MD5 hash not valid check the value '"+ lineValidation[8] +"' in the row no " + k + "~");
								isValid = false;
							}
						}
						if (!StringUtils.isEmpty(lineValidation[9].trim())) { // sha1
							boolean sha1Check = threatIOCService.validateIndicatorValue(Constants.IOCIndicatorType.SHA1, lineValidation[9]);
							if (sha1Check == false) {
								resMsg.append("SHA1 hash not valid check the value '"+ lineValidation[9] +"' in the row no " + k + "~");
								isValid = false;
							}
						}
						if (!StringUtils.isEmpty(lineValidation[10].trim())) { // sha2
							boolean sha2Check = threatIOCService.validateIndicatorValue(Constants.IOCIndicatorType.SHA2, lineValidation[10]);
							if (sha2Check == false) {
								resMsg.append("SHA2 hash not valid check the value '"+ lineValidation[10] +"' in the row no " + k + "~");
								isValid = false;
							}
						}

					} else {
						resMsg.append("Indicator type 'File Hash' must have File name or MD5_Hash or SHA1_Hash or SHA256_Hash. Check the indicator type and appropriate value in row no " + k  +"~");
						isValid = false;
					}

				}
				if (indicatorTypeVal.equalsIgnoreCase("File Hash")) {
					StringBuilder otherCol = new StringBuilder();
					if (!StringUtils.isEmpty(lineValidation[11].trim())
							|| !StringUtils.isEmpty(lineValidation[12].trim())
							|| !StringUtils.isEmpty(lineValidation[13].trim())
							|| !StringUtils.isEmpty(lineValidation[14].trim())
							|| !StringUtils.isEmpty(lineValidation[15].trim())
							|| !StringUtils.isEmpty(lineValidation[16].trim())) {

						if (!StringUtils.isEmpty(lineValidation[11].trim()))
							otherCol.append("Indicator type 'File Hash' must not have value in IP Address (column 'L').");
						if (!StringUtils.isEmpty(lineValidation[12].trim()))
							otherCol.append("Indicator type 'File Hash' must not have value in URL (column 'M').");
						if (!StringUtils.isEmpty(lineValidation[13].trim()))
							otherCol.append("Indicator type 'File Hash' must not have value in Domain (column 'N').");
						if (!StringUtils.isEmpty(lineValidation[14].trim()))
							otherCol.append("Indicator type 'File Hash' must not have value in Hostname (column 'O').");
						if (!StringUtils.isEmpty(lineValidation[15].trim()))
							otherCol.append("Indicator type 'File Hash' must not have value in Mutex (column 'P').");
						if (!StringUtils.isEmpty(lineValidation[16].trim()))
							otherCol.append("Indicator type 'File Hash' must not have value in Email (column 'Q').");

						resMsg.append(otherCol + " " + "Check the row no " + k + "~");
						isValid = false;
					}

				}

				if (indicatorTypeVal.equalsIgnoreCase("IP Address") || indicatorTypeVal.equalsIgnoreCase("IP")) {
					StringBuilder otherCol = new StringBuilder();
					if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim())
							|| !StringUtils.isEmpty(lineValidation[9].trim())
							|| !StringUtils.isEmpty(lineValidation[10].trim())
							|| !StringUtils.isEmpty(lineValidation[12].trim())
							|| !StringUtils.isEmpty(lineValidation[13].trim())
							|| !StringUtils.isEmpty(lineValidation[14].trim())
							|| !StringUtils.isEmpty(lineValidation[15].trim())
							|| !StringUtils.isEmpty(lineValidation[16].trim())) {
						if (!StringUtils.isEmpty(lineValidation[7].trim())
								|| !StringUtils.isEmpty(lineValidation[8].trim())
								|| !StringUtils.isEmpty(lineValidation[9].trim())
								|| !StringUtils.isEmpty(lineValidation[10].trim()))
							otherCol.append("Indicator type 'IP Address' must not have value in File_Name or MD5_Hash or SHA1_Hash or SHA256_Hash.");
						if (!StringUtils.isEmpty(lineValidation[12].trim()))
							otherCol.append("Indicator type 'IP Address' must not have value in URL (column 'M').");
						if (!StringUtils.isEmpty(lineValidation[13].trim()))
							otherCol.append("Indicator type 'IP Address' must not have value in Domain (column 'N').");
						if (!StringUtils.isEmpty(lineValidation[14].trim()))
							otherCol.append("Indicator type 'IP Address' must not have value in Hostname (column 'O').");
						if (!StringUtils.isEmpty(lineValidation[15].trim()))
							otherCol.append("Indicator type 'IP Address' must not have value in Mutex (column 'P').");
						if (!StringUtils.isEmpty(lineValidation[16].trim()))
							otherCol.append("Indicator type 'IP Address' must not have value in Email (column 'Q').");

						resMsg.append(otherCol + " " + "Check the row no " + k + "~");
						isValid = false;
					}
					if (StringUtils.isEmpty(lineValidation[11].trim())) {
						resMsg.append( "Indicator type 'IP Address' must have IP address value in column 'L'. Check the row no " + k  +"~");
						isValid = false;
					} else {
						boolean ipCheck = threatIOCService.validateIndicatorValue("IP Address", lineValidation[11]);
						if (ipCheck == false) {
							resMsg.append( "'IP Address' value is not valid in column 'L'. Check the row no " + k  + "~");
							isValid = false;
						}
					}

				}

				if (indicatorTypeVal.equalsIgnoreCase("URL")) {
					StringBuilder otherCol = new StringBuilder();
					if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim())
							|| !StringUtils.isEmpty(lineValidation[9].trim())
							|| !StringUtils.isEmpty(lineValidation[10].trim())
							|| !StringUtils.isEmpty(lineValidation[11].trim())
							|| !StringUtils.isEmpty(lineValidation[13].trim())
							|| !StringUtils.isEmpty(lineValidation[14].trim())
							|| !StringUtils.isEmpty(lineValidation[15].trim())
							|| !StringUtils.isEmpty(lineValidation[16].trim())) {
						if (!StringUtils.isEmpty(lineValidation[7].trim())
								|| !StringUtils.isEmpty(lineValidation[8].trim())
								|| !StringUtils.isEmpty(lineValidation[9].trim())
								|| !StringUtils.isEmpty(lineValidation[10].trim()))
							otherCol.append("Indicator type 'URL' must not have value in File_Name or MD5_Hash or SHA1_Hash or SHA256_Hash.");
						if (!StringUtils.isEmpty(lineValidation[11].trim()))
							otherCol.append("Indicator type 'URL' must not have value in IP Address (column 'L').");
						if (!StringUtils.isEmpty(lineValidation[13].trim()))
							otherCol.append("Indicator type 'URL' must not have value in Domain (column 'N').");
						if (!StringUtils.isEmpty(lineValidation[14].trim()))
							otherCol.append("Indicator type 'URL' must not have value in Hostname (column 'O').");
						if (!StringUtils.isEmpty(lineValidation[15].trim()))
							otherCol.append("Indicator type 'URL' must not have value in Mutex (column 'P').");
						if (!StringUtils.isEmpty(lineValidation[16].trim()))
							otherCol.append("Indicator type 'URL' must not have value in Email (column 'Q').");

						resMsg.append(otherCol + " " + "Check the row no " + k  +"~");
						isValid = false;
					}
					if (StringUtils.isEmpty(lineValidation[12].trim())) {
						resMsg.append("Indicator type 'URL' must have URL value in column 'M'. Check the row no " + k + "~");
						isValid = false;
					} else {
						if (!lineValidation[12].trim().startsWith("http") && !lineValidation[12].trim().startsWith("https")) {
							resMsg.append("URL should start with http[:]// or https[:]//. Check the row no " + k + "~");
							isValid = false;
						}
						if (!threatIOCService.isValidRegex(".", lineValidation[12].trim())) {
							resMsg.append("URL contains special character . should be covered with [] like [.]. Check the row no " + k + "~");
							isValid = false;
						}
						if (!threatIOCService.isValidRegex(":", lineValidation[12].trim())) {
							resMsg.append("URL contains special character : should be covered with [] like [:]. Check the row no " + k + "~");
							isValid = false;
						}
						//Validate URL
						Boolean urlCheck = threatIOCService.validateIndicatorValue(Constants.IOCIndicatorType.URL, lineValidation[12].trim().replace("[.]", ".").replace("[:]", ":"));
						if (!urlCheck) {
							resMsg.append("URL entered is not valid. Please enter a valid URL check row no. "+k+"~");
							isValid = false;
						}
					}
					
					/*else {
						boolean urlCheck = threatIOCService.validateIndicatorValue("URL", lineValidation[12]);
						if (urlCheck == false) {
							resMsg.append("'URL' value is not valid in column 'M'. Check the row no " + k );
							isValid = false;
						}
					}*/

				}

				if (indicatorTypeVal.equalsIgnoreCase("Domain")) {
					StringBuilder otherCol = new StringBuilder();
					if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim())
							|| !StringUtils.isEmpty(lineValidation[9].trim())
							|| !StringUtils.isEmpty(lineValidation[10].trim())
							|| !StringUtils.isEmpty(lineValidation[11].trim())
							|| !StringUtils.isEmpty(lineValidation[12].trim())
							|| !StringUtils.isEmpty(lineValidation[14].trim())
							|| !StringUtils.isEmpty(lineValidation[15].trim())
							|| !StringUtils.isEmpty(lineValidation[16].trim())) {
						if (!StringUtils.isEmpty(lineValidation[7].trim())
								|| !StringUtils.isEmpty(lineValidation[8].trim())
								|| !StringUtils.isEmpty(lineValidation[9].trim())
								|| !StringUtils.isEmpty(lineValidation[10].trim()))
							otherCol.append(
									"Indicator type 'Domain' must not have value in File_Name or MD5_Hash or SHA1_Hash or SHA256_Hash.");
						if (!StringUtils.isEmpty(lineValidation[11].trim()))
							otherCol.append("Indicator type 'Domain' must not have value in IP Address (column 'L').");
						if (!StringUtils.isEmpty(lineValidation[12].trim()))
							otherCol.append("Indicator type 'Domain' must not have value in URL (column 'M').");
						if (!StringUtils.isEmpty(lineValidation[14].trim()))
							otherCol.append("Indicator type 'Domain' must not have value in Hostname (column 'O').");
						if (!StringUtils.isEmpty(lineValidation[15].trim()))
							otherCol.append("Indicator type 'Domain' must not have value in Mutex (column 'P').");
						if (!StringUtils.isEmpty(lineValidation[16].trim()))
							otherCol.append("Indicator type 'Domain' must not have value in Email (column 'Q').");

						resMsg.append(otherCol + " " + "Check the row no " + k + "~");
						isValid = false;
					}
					if (StringUtils.isEmpty(lineValidation[13].trim())) {
						resMsg.append("Indicator type 'Domain' must have Domain value in column 'N'. Check the row no " + k + "~");
						isValid = false;
					} else {
						if (lineValidation[13].trim().startsWith("http") || lineValidation[13].trim().startsWith("https")) {
							resMsg.append("Domain should not start with http or https. Check the row no " + k + "~");
							isValid = false;
						}
						if (!threatIOCService.isValidRegex(".", lineValidation[13].trim())) {
							resMsg.append("Domain contains special character . should be covered with [] like [.]. Check the row no " + k + "~");
							isValid = false;
						}
						if (!threatIOCService.isValidRegex(":", lineValidation[13].trim())) {
							resMsg.append("Domain contains special character : should be covered with [] like [:]. Check the row no " + k + "~");
							isValid = false;
						}
						//validate Domain
						Boolean domainCheck = threatIOCService.validateIndicatorValue(Constants.IOCIndicatorType.Domain, lineValidation[13].trim().replace("[.]", ".").replace("[:]", ":"));
						if (!domainCheck) {
							resMsg.append("Domain entered is not valid. Please enter a valid domain check row no. "+k+"~");
							isValid = false;
						}
					}
					
					/*else {
						boolean domainCheck = threatIOCService.validateIndicatorValue("Domain", lineValidation[13]);
						if (domainCheck == false) {
							resMsg.append("'Domain' value is not valid in column 'N'. Check the row no " + k );
							isValid = false;
						}
					}*/

				}

				if (indicatorTypeVal.equalsIgnoreCase("Hostname")) {
					StringBuilder otherCol = new StringBuilder();
					if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim())
							|| !StringUtils.isEmpty(lineValidation[9].trim()) || !StringUtils.isEmpty(lineValidation[10].trim())
							|| !StringUtils.isEmpty(lineValidation[11].trim()) || !StringUtils.isEmpty(lineValidation[12].trim())
							|| !StringUtils.isEmpty(lineValidation[13].trim()) || !StringUtils.isEmpty(lineValidation[15].trim())
							|| !StringUtils.isEmpty(lineValidation[16].trim())) {
						if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim())
								|| !StringUtils.isEmpty(lineValidation[9].trim()) || !StringUtils.isEmpty(lineValidation[10].trim()))
							otherCol.append("Indicator type 'Hostname' must not have value in File_Name or MD5_Hash or SHA1_Hash or SHA256_Hash.");
						if (!StringUtils.isEmpty(lineValidation[11].trim()))
							otherCol.append("Indicator type 'Hostname' must not have value in IP Address (column 'L').");
						if (!StringUtils.isEmpty(lineValidation[12].trim()))
							otherCol.append("Indicator type 'Hostname' must not have value in URL (column 'M').");
						if (!StringUtils.isEmpty(lineValidation[13].trim()))
							otherCol.append("Indicator type 'Hostname' must not have value in Domain (column 'N').");
						if (!StringUtils.isEmpty(lineValidation[15].trim()))
							otherCol.append("Indicator type 'Hostname' must not have value in Mutex (column 'P').");
						if (!StringUtils.isEmpty(lineValidation[16].trim()))
							otherCol.append("Indicator type 'Hostname' must not have value in Email (column 'Q').");

						resMsg.append(otherCol + " " + "Check the row no " + k + "~");
						isValid = false;
					}
					if (StringUtils.isEmpty(lineValidation[14].trim())) {
						resMsg.append("Indicator type 'Host name' must have Host names value in column 'O'. Check the row no " + k + "~");
						isValid = false;
					}
					/*else {
						boolean hostCheck = threatIOCService.validateIndicatorValue("Host name", lineValidation[14]);
						if (hostCheck == false) {
							resMsg.append("'Host name' value is not valid in column 'O'. Check the row no " + k );
							isValid = false;
						}
					}*/

				}

				if (indicatorTypeVal.equalsIgnoreCase("Mutex")) {
					StringBuilder otherCol = new StringBuilder();
					if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim())
							|| !StringUtils.isEmpty(lineValidation[9].trim()) || !StringUtils.isEmpty(lineValidation[10].trim())
							|| !StringUtils.isEmpty(lineValidation[11].trim()) || !StringUtils.isEmpty(lineValidation[12].trim())
							|| !StringUtils.isEmpty(lineValidation[13].trim()) || !StringUtils.isEmpty(lineValidation[14].trim())
							|| !StringUtils.isEmpty(lineValidation[16].trim())) {
						if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim()) || !StringUtils.isEmpty(lineValidation[9].trim()) || !StringUtils.isEmpty(lineValidation[10].trim()))
							otherCol.append("Indicator type 'Mutex' must not have value in File_Name or MD5_Hash or SHA1_Hash or SHA256_Hash.");
						if (!StringUtils.isEmpty(lineValidation[11].trim()))
							otherCol.append("Indicator type 'Mutex' must not have value in IP Address (column 'L').");
						if (!StringUtils.isEmpty(lineValidation[12].trim()))
							otherCol.append("Indicator type 'Mutex' must not have value in URL (column 'M').");
						if (!StringUtils.isEmpty(lineValidation[13].trim()))
							otherCol.append("Indicator type 'Mutex' must not have value in Domain (column 'N').");
						if (!StringUtils.isEmpty(lineValidation[14].trim()))
							otherCol.append("Indicator type 'Mutex' must not have value in Host name (column 'O').");
						if (!StringUtils.isEmpty(lineValidation[16].trim()))
							otherCol.append("Indicator type 'Mutex' must not have value in Email (column 'Q').");

						resMsg.append(otherCol + " " + "Check the row no " + k + "~");
						isValid = false;
					}
					if (StringUtils.isEmpty(lineValidation[15].trim())) {
						resMsg.append("Indicator type 'Mutex' must have Mutex value in column 'P'. Check the row no " + k + "~");
						isValid = false;
					}

				}

				if (indicatorTypeVal.equalsIgnoreCase("Email")) {
					StringBuilder otherCol = new StringBuilder();
					if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim())
							|| !StringUtils.isEmpty(lineValidation[9].trim()) || !StringUtils.isEmpty(lineValidation[10].trim())
							|| !StringUtils.isEmpty(lineValidation[11].trim()) || !StringUtils.isEmpty(lineValidation[12].trim())
							|| !StringUtils.isEmpty(lineValidation[13].trim()) || !StringUtils.isEmpty(lineValidation[14].trim())
							|| !StringUtils.isEmpty(lineValidation[15].trim())) {
						if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim()) || !StringUtils.isEmpty(lineValidation[9].trim())
								|| !StringUtils.isEmpty(lineValidation[10].trim()))
							otherCol.append("Indicator type 'Email' must not have value in File_Name or MD5_Hash or SHA1_Hash or SHA256_Hash.");
						if (!StringUtils.isEmpty(lineValidation[11].trim()))
							otherCol.append("Indicator type 'Email' must not have value in IP Address (column 'L').");
						if (!StringUtils.isEmpty(lineValidation[12].trim()))
							otherCol.append("Indicator type 'Email' must not have value in URL (column 'M').");
						if (!StringUtils.isEmpty(lineValidation[13].trim()))
							otherCol.append("Indicator type 'Email' must not have value in Domain (column 'N').");
						if (!StringUtils.isEmpty(lineValidation[14].trim()))
							otherCol.append("Indicator type 'Email' must not have value in Host name (column 'O').");
						if (!StringUtils.isEmpty(lineValidation[15].trim()))
							otherCol.append("Indicator type 'Email' must not have value in Mutex (column 'P').");

						resMsg.append(otherCol + " " + "Check the row no " + k + "~");
						isValid = false;
					}
					if (StringUtils.isEmpty(lineValidation[16].trim())) {
						resMsg.append("Indicator type 'Email' must have Email value in column 'Q'. Check the row no " + k + "~");
						isValid = false;
					}
					//Email validate
					Boolean emailCheck = threatIOCService.validateIndicatorValue(Constants.IOCIndicatorType.Email, lineValidation[16].trim().replace("[.]", ".").replace("[:]", ":"));
					if (!emailCheck) {
						resMsg.append("Email entered is not valid. Please enter a valid email check row no. "+k+"~");
						isValid = false;
					}
					/* else {
						boolean emailCheck = threatIOCService.validateIndicatorValue("Email", lineValidation[15]));
						if (emailCheck == false) {
							resMsg.append("'Email' value is not valid in column 'Q'. Check the row no " + k );
							isValid = false;
						}
					}*/
				}
			}
			
			if (!isValid)
				return ResponseEntity.ok().headers(HeaderUtil.createEntityUpdateAlert(ENTITY_NAME, "")).body("{\"status\":\"error\",\"message\":\"" + resMsg + "\"}");

			int i = 1;
			for (String[] line : lines) {
				String indicatorType = line[5].trim();
				if (!StringUtils.isEmpty(indicatorType)) {
					indicatorType = threatIOCService.getIndicatorType(indicatorType);
					if (StringUtils.isEmpty(indicatorType))
						return ResponseEntity.ok().body("{\"status\":\"error\",\"message\":\"" + "Indicator type column must not empty." + "\"}");

					ThreatIOC threatIOC		 = new ThreatIOC();
					MalwareIOC malwareIOC    = new MalwareIOC();
					
					if (indicatorType.equalsIgnoreCase("file hash") || indicatorType.equalsIgnoreCase("file md5")
							|| indicatorType.equalsIgnoreCase("filehash") || indicatorType.equalsIgnoreCase("filemd5")
							|| indicatorType.equalsIgnoreCase("file_hash") || indicatorType.equalsIgnoreCase("file_md5")
							|| indicatorType.equalsIgnoreCase("file-hash") || indicatorType.equalsIgnoreCase("file-md5")
							|| indicatorType.equalsIgnoreCase("hash") || indicatorType.equalsIgnoreCase("md5")
							|| indicatorType.equalsIgnoreCase("sha") || indicatorType.equalsIgnoreCase("sha1")
							|| indicatorType.equalsIgnoreCase("sha256") || indicatorType.equalsIgnoreCase("sha512")) {

						threatIOC.setValue(line[7].trim().replace("[.]", ".").replace("[:]", ":"));
						threatIOC.setMd5Hash(line[8].trim());
						threatIOC.setSha1Hash(line[9].trim());
						threatIOC.setSha256Hash(line[10].trim());
						threatIOC.setIndicatorType(Constants.IOCIndicatorType.FileHash);

					}

					if (indicatorType.equalsIgnoreCase("ipaddress") || indicatorType.equalsIgnoreCase("ip address")
							|| indicatorType.equalsIgnoreCase("ip_address")
							|| indicatorType.equalsIgnoreCase("ip-address") || indicatorType.equalsIgnoreCase("ip")) {

						threatIOC.setValue(line[11].trim().replace("[.]", ".").replace("[:]", ":"));
						threatIOC.setIndicatorType(Constants.IOCIndicatorType.IP);
					}

					if (indicatorType.equalsIgnoreCase("url")) {
						threatIOC.setValue(line[12].trim().replace("[.]", ".").replace("[:]", ":"));
						threatIOC.setIndicatorType(Constants.IOCIndicatorType.URL);
					}

					if (indicatorType.equalsIgnoreCase("domain")) {
						threatIOC.setValue(line[13].trim().replace("[.]", ".").replace("[:]", ":"));
						threatIOC.setIndicatorType(Constants.IOCIndicatorType.Domain);
					}

					if (indicatorType.equalsIgnoreCase("hostname") || indicatorType.equalsIgnoreCase("host name")
							|| indicatorType.equalsIgnoreCase("host_name")
							|| indicatorType.equalsIgnoreCase("host_name") || indicatorType.equalsIgnoreCase("host")) {
						threatIOC.setValue(line[14].trim().replace("[.]", ".").replace("[:]", ":"));
						threatIOC.setIndicatorType(Constants.IOCIndicatorType.Hostname);
					}

					if (indicatorType.equalsIgnoreCase("mutex")) {
						threatIOC.setValue(line[15].trim().replace("[.]", ".").replace("[:]", ":"));
						threatIOC.setIndicatorType(Constants.IOCIndicatorType.Mutex);
					}

					if (indicatorType.equalsIgnoreCase("email")) {
						threatIOC.setValue(line[16].trim().replace("[.]", ".").replace("[:]", ":"));
						threatIOC.setIndicatorType(Constants.IOCIndicatorType.Email);
					}

					if (indicatorType.equalsIgnoreCase("CVE")) {
						threatIOC.setValue(line[7].trim().replace("[.]", ".").replace("[:]", ":"));
						threatIOC.setIndicatorType(Constants.IOCIndicatorType.CVE);
					}

					threatIOC.getClientName().addAll(new HashSet<String>(Arrays.asList(line[0].trim())));
					if (!StringUtils.isEmpty(line[1].trim())) {
						SimpleDateFormat formatter = new SimpleDateFormat("dd-MMM-yy");
						formatter.setTimeZone(TimeZone.getTimeZone("GMT"));
						Date reportedDate = formatter.parse(line[1].trim());
						if (reportedDate != null && reportedDate.after(new Date())) {
							threatIOC.firstSeen(new Date());
							threatIOC.lastSeen(new Date());
						} else {
							threatIOC.firstSeen(reportedDate);
							threatIOC.lastSeen(reportedDate);
						}
					} else {
						threatIOC.firstSeen(new Date());
						threatIOC.lastSeen(new Date());
					}
					threatIOC.setThreatActorName(line[2].trim());
					threatIOC.setUid(line[3].trim());
					threatIOC.addClientUIDs(line[0].trim(),line[3].trim());
					threatIOC.setEid(line[4].trim());
					threatIOC.setIndicatorType(line[5].trim());
					threatIOC.setRole(line[6].trim());
					threatIOC.setSource(Constants.IOCSource.CYFIRMA_MALWARE);
					threatIOC.setCyfirmaIOC(true);
					threatIOC.setRecommendedAction(line[17].trim());
					threatIOC.setDescription(line[18].trim());
					if(threatIOC.getLastSeen() == null)
						threatIOC.setLastSeen(new Date());
					 threatIOCService.saveIOCsOnly(threatIOC, false);
					
					malwareIOC.setMalwareId(malwareId);
					
					if(!StringUtils.isEmpty(malwareId)) {
						Optional<Malware> mOpt = malwareRepository.findById(malwareId);
						Malware m = null;
						if(mOpt.isPresent())
							m = mOpt.get();
						if(m!=null) {
							malwareIOC.setMalwareId(m.getId());
							malwareIOC.setMalwareName(m.getName());
						}
					}
					
					malwareIOC.setClientName(threatIOC.getClientName());
					malwareIOC.setIndicatorType(threatIOC.getIndicatorType());
					malwareIOC.setValue(threatIOC.getValue());
					malwareIOC.setMd5Hash(threatIOC.getMd5Hash());
					malwareIOC.setSha1Hash(threatIOC.getSha1Hash());
					malwareIOC.setSha256Hash(threatIOC.getSha256Hash());
					malwareIOC.setFileName(threatIOC.getFileName());
					malwareIOC.setCategory(threatIOC.getCategory());
					malwareIOC.setRecommendedAction(threatIOC.getRecommendedAction());
					malwareIOC.setDescription(threatIOC.getDescription());
					malwareIOC.setUid(threatIOC.getUid());
					malwareIOC.setClientUIDs(threatIOC.getClientUIDs());
					malwareIOC.setEid(threatIOC.getEid());
					malwareIOC.setRole(threatIOC.getRole());
					if(!CollectionUtils.isEmpty(threatIOC.getThreatActorIds()))
						malwareIOC.setThreatActorId(threatIOC.getThreatActorIds().iterator().next());
					malwareIOC.setThreatActorName(threatIOC.getThreatActorName());
					malwareIOC.getTags().add(threatIOC.getThreatActorName());
					malwareIOC.setTags(threatIOC.getTags());
					malwareIOC.setThreatScore(threatIOC.getThreatScore());
					malwareIOC.setPopularity(threatIOC.getPopularity());
					malwareIOC.setCountryName(threatIOC.getCountryName());
					malwareIOC.setCountryCode(threatIOC.getCountryCode());
					malwareIOC.setSource(threatIOC.getSource());
					malwareIOC.setFirstSeen(threatIOC.getFirstSeen());
					malwareIOC.setLastSeen(new Date());
					malwareIOC = malwareService.saveIOCsOnly(malwareIOC);
					malwareIOCResult.add(malwareIOC);
					
					log.debug("#indicatorType : " + indicatorType + " , recored : " + i + "  , saved Object : ");
				}
				i++;
			}			
			
		} catch (Exception e) {
			log.error("Error while uploading file, Error : " + e.getMessage());
		}
		
		if (!CollectionUtils.isEmpty(malwareIOCResult))
			resMsg.append("Malware IOC CSV file uploaded successfully.");
		else
			resMsg.append("Malware IOC CSV file not uploaded.");

		return ResponseEntity.ok().headers(HeaderUtil.createEntityUpdateAlert(ENTITY_NAME, "")).body("{\"status\":\"success\",\"message\":\"" + resMsg + "\"}");
    }
    
    @SuppressWarnings("unused")
	@PostMapping("/malwares/validate-malwareioc-csv")
	@Timed
	public ResponseEntity<Object> validateMalwareIOCCsv(@RequestParam("file") MultipartFile file) {
		StringBuilder resMsg = new StringBuilder();
		boolean isValid = true;
		try {
			InputStream is = file.getInputStream();
			BufferedReader br = new BufferedReader(new InputStreamReader(is));
			CSVReader reader = new CSVReader(br);
			List<String[]> lines = reader.readAll();
			reader.close();
			br.close();
			is.close();
			
			int headerSize = 1;
			for (String lineValidation : lines.get(0)) {
				if (lineValidation.equalsIgnoreCase("description")
						|| lineValidation.trim().toLowerCase().startsWith("description"))
					break;
				headerSize++;
			}
			if(file!=null) {
				String fileExtension = FilenameUtils.getExtension(file.getOriginalFilename());
				if(!StringUtils.isEmpty(fileExtension) && !fileExtension.equalsIgnoreCase("csv")) {
				   return ResponseEntity.ok().headers(HeaderUtil.createEntityUpdateAlert(ENTITY_NAME, ""))
							.body("{\"status\":\"" + "error" + "\",\"message\":\"" + "The uploaded file is not of CSV format. Please upload a file in CSV format" + "\"}");
				}
				}
			boolean check = false;
			int lineNumber = 1;
			for (String[] lineValidation : lines) {
				check = false;
				int x = 0;
				for (String text : lineValidation) {
					x++;
					if (x > headerSize) {
						if (!StringUtils.isEmpty(text)) {
							check = true;
							break;
						}

					}
				}
				if (check) {
					resMsg.append("Extra Data after column Description at row no.  " + lineNumber);
					isValid = false;
				}
				lineNumber++;
			}
			
			lines.remove(0);
			Set<String> md5Add = new HashSet<>();
			Set<String> sha1Add = new HashSet<>();
			Set<String> sha256Add = new HashSet<>();
			Set<String> ipAdd = new HashSet<>();
			Set<String> urlAdd = new HashSet<>();
			Set<String> domainAdd = new HashSet<>();
			Set<String> uidAdd = new HashSet<>();
			int k = 1;
			for (String[] lineValidation : lines) {
				k++;
				String indicatorTypeVal = lineValidation[5].trim();
				String uidCheck = lineValidation[3].trim();
				String reccommendedActionCheck = lineValidation[17].trim();
				Date reportedDate = null;
//				Date EidDate = null;
				
//				if (!StringUtils.isEmpty(lineValidation[3].trim())){
//					if(uidAdd.add(lineValidation[3].trim()) == false){
//						resMsg.append("Duplicate UID check in row no."+k);
//						isValid = false;
//					}
//				}
				
//				if (lineValidation[0].trim().equalsIgnoreCase("")) {
//					resMsg.append("Client name cannot be blank check row no." + k + "~");
//					isValid = false;
//				} else if (!file.getOriginalFilename().toLowerCase().contains(lineValidation[0].trim().toLowerCase())) {
//					resMsg.append("Client Name in Col A and Client Name mentioned in the filename should match, Check row no." + k + "~");
//					isValid = false;
//				}
				
//				Set<String> orgNames = orgClient.getAllOrgsNameUnauthorized();
//				if(!orgNames.contains(lineValidation[0].trim().toLowerCase().toLowerCase())) {
//					resMsg.append("Client Name is not present in database, Check row no." + k + "~");
//					isValid = false;
//				}
				
//				if (uidCheck.equalsIgnoreCase("")) {
//					resMsg.append("UID cannot be blank check row no." + k + "~");
//					isValid = false;
//					// break;
//				}

				if (reccommendedActionCheck.equalsIgnoreCase("")) {
					resMsg.append("Recommended Action cannot be left blank check row no." + k + "~");
					isValid = false;
					// break;
				}
				
				if (!StringUtils.isEmpty(lineValidation[1].trim())) {
					SimpleDateFormat formatter = new SimpleDateFormat("dd-MMM-yy");
					reportedDate = formatter.parse(lineValidation[1].trim());
					if (reportedDate != null && reportedDate.after(new Date())) {
						resMsg.append("Reported Date cannot be greater than current date check row no." + k + "~");
						isValid = false;
					}
				} else {
					resMsg.append("Reported Date cannot be left blank check row no." + k + "~");
					isValid = false;
					// break;
				}
				
				//md5 duplicate check
				if (!StringUtils.isEmpty(lineValidation[8].trim())){
					if(md5Add.add(lineValidation[8].trim()) == false){
						resMsg.append("Duplicate MD5 hash check in row no."+k);
						isValid = false;
					}
				}
				
				//sha1 duplicate check
				if (!StringUtils.isEmpty(lineValidation[9].trim())){
					if(sha1Add.add(lineValidation[9].trim()) == false){
						resMsg.append("Duplicate SHA1 hash check in row no."+k);
						isValid = false;
					}
				}
				
				//sha256 duplicate check
				if (!StringUtils.isEmpty(lineValidation[10].trim())){
					if(sha256Add.add(lineValidation[10].trim()) == false){
						resMsg.append("Duplicate SHA256 hash check in row no."+k);
						isValid = false;
					}
				}
				
				//ip duplicate check
				if (!StringUtils.isEmpty(lineValidation[11].trim())){
					if(ipAdd.add(lineValidation[11].trim()) == false){
						resMsg.append("Duplicate IP adress check in row no."+k);
						isValid = false;
					}
				}
				
				//url duplicate check
				if (!StringUtils.isEmpty(lineValidation[12].trim())){
					if(urlAdd.add(lineValidation[12].trim()) == false){
						resMsg.append("Duplicate URL check in row no."+k);
						isValid = false;
					}
				}
				
				//domain duplicate check
				if (!StringUtils.isEmpty(lineValidation[13].trim())){
					if(domainAdd.add(lineValidation[13].trim()) == false){
						resMsg.append("Duplicate Domain check in row no."+k);
						isValid = false;
					}
				}
				
//				String last = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf('_') + 1,file.getOriginalFilename().lastIndexOf("."));
//				SimpleDateFormat formatter = new SimpleDateFormat("dd MMM yy");
//				Date fileDate = formatter.parse(last);
				
//				if (!StringUtils.isEmpty(lineValidation[4].trim())) {
//					String eid = lineValidation[4].trim();
//					String eidDate = "";
//					eid = eid.substring(0,eid.lastIndexOf("-"));
//					eidDate = eid.substring(eid.length()-8);
//					formatter = new SimpleDateFormat("dd-MM-yy");
//					EidDate = formatter.parse(eidDate);
//				}
//				else {
//					resMsg.append("EID Field cannot be left blank check row no." + k + "~");
//					isValid = false;
//					// break;
//				}
				
//				if(!reportedDate.equals(fileDate)){
//					resMsg.append("Date Mismatch check row no." + k + "~");
//					isValid = false;
//					// break;
//				} else if(!reportedDate.equals(EidDate)) {
//					resMsg.append("Date Mismatch check row no." + k  + "~");
//					isValid = false;
//					// break;
//				} else if(!fileDate.equals(EidDate)) {
//					resMsg.append("Date Mismatch check row no." + k + "~");
//					isValid = false;
//					// break;
//				}
				
				if (!indicatorTypeVal.equalsIgnoreCase("File Hash") && !indicatorTypeVal.equalsIgnoreCase("IP Address") && !indicatorTypeVal.equalsIgnoreCase("IP") && !indicatorTypeVal.equalsIgnoreCase("Domain") && !indicatorTypeVal.equalsIgnoreCase("URL")
						&& !indicatorTypeVal.equalsIgnoreCase("Mutex") && !indicatorTypeVal.equalsIgnoreCase("Hostname") && !indicatorTypeVal.equalsIgnoreCase("Email")) {
					resMsg.append("Indicator type should be 'File Hash' or 'IP Address' or 'IP' or 'URL'  or 'Domain' or 'Hostname' or 'Mutex'  or 'Email'  check the row no " + k  +"~");
					isValid = false;
				}

				if (indicatorTypeVal.equalsIgnoreCase("file hash") || indicatorTypeVal.equalsIgnoreCase("file md5")
						|| indicatorTypeVal.equalsIgnoreCase("filehash") || indicatorTypeVal.equalsIgnoreCase("filemd5")
						|| indicatorTypeVal.equalsIgnoreCase("file_hash")
						|| indicatorTypeVal.equalsIgnoreCase("file_md5")
						|| indicatorTypeVal.equalsIgnoreCase("file-hash")
						|| indicatorTypeVal.equalsIgnoreCase("file-md5") || indicatorTypeVal.equalsIgnoreCase("hash")
						|| indicatorTypeVal.equalsIgnoreCase("md5") || indicatorTypeVal.equalsIgnoreCase("sha")
						|| indicatorTypeVal.equalsIgnoreCase("sha1") || indicatorTypeVal.equalsIgnoreCase("sha256")
						|| indicatorTypeVal.equalsIgnoreCase("sha512")) {

					if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim())
							|| !StringUtils.isEmpty(lineValidation[9].trim())
							|| !StringUtils.isEmpty(lineValidation[10].trim())) {
						if (!StringUtils.isEmpty(lineValidation[8].trim())) { // md5
							boolean md5Check = threatIOCService.validateIndicatorValue(Constants.IOCIndicatorType.MD5, lineValidation[8]);
							if (md5Check == false) {
								resMsg.append("MD5 hash not valid check the value '"+ lineValidation[8] +"' in the row no " + k  +"~");
								isValid = false;
							}
						}
						if (!StringUtils.isEmpty(lineValidation[9].trim())) { // sha1
							boolean sha1Check = threatIOCService.validateIndicatorValue(Constants.IOCIndicatorType.SHA1,	lineValidation[9]);
							if (sha1Check == false) {
								resMsg.append("SHA1 hash not valid check the value '"+ lineValidation[9] +"' in the row no " + k +"~");
								isValid = false;
							}
						}
						if (!StringUtils.isEmpty(lineValidation[10].trim())) { // sha2
							boolean sha2Check = threatIOCService.validateIndicatorValue(Constants.IOCIndicatorType.SHA2,	lineValidation[10]);
							if (sha2Check == false) {
								resMsg.append("SHA2 hash not valid check the value '"+ lineValidation[10] +"' in the row no " + k  +"~");
								isValid = false;
							}
						}

					} else {
						resMsg.append("Indicator type 'File Hash' must have File name or MD5_Hash or SHA1_Hash or SHA256_Hash. Check the indicator type and appropriate value in row no " + k  +"~");
						isValid = false;
					}

				}
				if (indicatorTypeVal.equalsIgnoreCase("File Hash")) {
					StringBuilder otherCol = new StringBuilder();
					if (!StringUtils.isEmpty(lineValidation[11].trim())
							|| !StringUtils.isEmpty(lineValidation[12].trim())
							|| !StringUtils.isEmpty(lineValidation[13].trim())
							|| !StringUtils.isEmpty(lineValidation[14].trim())
							|| !StringUtils.isEmpty(lineValidation[15].trim())
							|| !StringUtils.isEmpty(lineValidation[16].trim())) {

						if (!StringUtils.isEmpty(lineValidation[11].trim()))
							otherCol.append("Indicator type 'File Hash' must not have value in IP Address (column 'L').");
						if (!StringUtils.isEmpty(lineValidation[12].trim()))
							otherCol.append("Indicator type 'File Hash' must not have value in URL (column 'M').");
						if (!StringUtils.isEmpty(lineValidation[13].trim()))
							otherCol.append("Indicator type 'File Hash' must not have value in Domain (column 'N').");
						if (!StringUtils.isEmpty(lineValidation[14].trim()))
							otherCol.append("Indicator type 'File Hash' must not have value in Hostname (column 'O').");
						if (!StringUtils.isEmpty(lineValidation[15].trim()))
							otherCol.append("Indicator type 'File Hash' must not have value in Mutex (column 'P').");
						if (!StringUtils.isEmpty(lineValidation[16].trim()))
							otherCol.append("Indicator type 'File Hash' must not have value in Email (column 'Q').");

						resMsg.append(otherCol + " " + "Check the row no " + k  + "~");
						isValid = false;
					}

				}

				if (indicatorTypeVal.equalsIgnoreCase("IP Address") || indicatorTypeVal.equalsIgnoreCase("IP")) {
					StringBuilder otherCol = new StringBuilder();
					if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim())
							|| !StringUtils.isEmpty(lineValidation[9].trim())
							|| !StringUtils.isEmpty(lineValidation[10].trim())
							|| !StringUtils.isEmpty(lineValidation[12].trim())
							|| !StringUtils.isEmpty(lineValidation[13].trim())
							|| !StringUtils.isEmpty(lineValidation[14].trim())
							|| !StringUtils.isEmpty(lineValidation[15].trim())
							|| !StringUtils.isEmpty(lineValidation[16].trim())) {
						if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim()) || !StringUtils.isEmpty(lineValidation[9].trim()) || !StringUtils.isEmpty(lineValidation[10].trim()))
							otherCol.append("Indicator type 'IP Address' must not have value in File_Name or MD5_Hash or SHA1_Hash or SHA256_Hash.");
						if (!StringUtils.isEmpty(lineValidation[12].trim()))
							otherCol.append("Indicator type 'IP Address' must not have value in URL (column 'M').");
						if (!StringUtils.isEmpty(lineValidation[13].trim()))
							otherCol.append("Indicator type 'IP Address' must not have value in Domain (column 'N').");
						if (!StringUtils.isEmpty(lineValidation[14].trim()))
							otherCol.append("Indicator type 'IP Address' must not have value in Hostname (column 'O').");
						if (!StringUtils.isEmpty(lineValidation[15].trim()))
							otherCol.append("Indicator type 'IP Address' must not have value in Mutex (column 'P').");
						if (!StringUtils.isEmpty(lineValidation[16].trim()))
							otherCol.append("Indicator type 'IP Address' must not have value in Email (column 'Q').");
						
						resMsg.append(otherCol + " " + "Check the row no " + k +"~");
						isValid = false;
					}
					if (StringUtils.isEmpty(lineValidation[11].trim())) {
						resMsg.append( "Indicator type 'IP Address' must have IP address value in column 'L'. Check the row no " + k  +"~");
						isValid = false;
					} else {
						boolean ipCheck = threatIOCService.validateIndicatorValue(Constants.IOCIndicatorType.IP, lineValidation[11]);
						if (ipCheck == false) {
							resMsg.append( "'IP Address' value is not valid in column 'L'. Check the row no " + k + "~");
							isValid = false;
						}
					}

				}

				if (indicatorTypeVal.equalsIgnoreCase("URL")) {
					StringBuilder otherCol = new StringBuilder();
					if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim())
							|| !StringUtils.isEmpty(lineValidation[9].trim())
							|| !StringUtils.isEmpty(lineValidation[10].trim())
							|| !StringUtils.isEmpty(lineValidation[11].trim())
							|| !StringUtils.isEmpty(lineValidation[13].trim())
							|| !StringUtils.isEmpty(lineValidation[14].trim())
							|| !StringUtils.isEmpty(lineValidation[15].trim())
							|| !StringUtils.isEmpty(lineValidation[16].trim())) {
						if (!StringUtils.isEmpty(lineValidation[7].trim())
								|| !StringUtils.isEmpty(lineValidation[8].trim())
								|| !StringUtils.isEmpty(lineValidation[9].trim())
								|| !StringUtils.isEmpty(lineValidation[10].trim()))
							otherCol.append("Indicator type 'URL' must not have value in File_Name or MD5_Hash or SHA1_Hash or SHA256_Hash.");
						if (!StringUtils.isEmpty(lineValidation[11].trim()))
							otherCol.append("Indicator type 'URL' must not have value in IP Address (column 'L').");
						if (!StringUtils.isEmpty(lineValidation[13].trim()))
							otherCol.append("Indicator type 'URL' must not have value in Domain (column 'N').");
						if (!StringUtils.isEmpty(lineValidation[14].trim()))
							otherCol.append("Indicator type 'URL' must not have value in Hostname (column 'O').");
						if (!StringUtils.isEmpty(lineValidation[15].trim()))
							otherCol.append("Indicator type 'URL' must not have value in Mutex (column 'P').");
						if (!StringUtils.isEmpty(lineValidation[16].trim()))
							otherCol.append("Indicator type 'URL' must not have value in Email (column 'Q').");

						resMsg.append(otherCol + " " + "Check the row no " + k + "~");
						isValid = false;
					}
					if (StringUtils.isEmpty(lineValidation[12].trim())) {
						resMsg.append("Indicator type 'URL' must have URL value in column 'M'. Check the row no " + k  +"~");
						isValid = false;
					} else {
						if (!lineValidation[12].trim().startsWith("http") && !lineValidation[12].trim().startsWith("https")) {
							resMsg.append("URL should start with http[:]// or https[:]//. Check the row no " + k  +"~");
							isValid = false;
						}
						if (!threatIOCService.isValidRegex(".", lineValidation[12].trim())) {
							resMsg.append("URL contains special character . should be covered with [] like [.]. Check the row no " + k + "~");
							isValid = false;
						}
						if (!threatIOCService.isValidRegex(":", lineValidation[12].trim())) {
							resMsg.append("URL contains special character : should be covered with [] like [:]. Check the row no " + k + "~");
							isValid = false;
						}
						//Validate URL
						Boolean urlCheck = threatIOCService.validateIndicatorValue(Constants.IOCIndicatorType.URL, lineValidation[12].trim().replace("[.]", ".").replace("[:]", ":"));
						if (!urlCheck) {
							resMsg.append("URL entered is not valid. Please enter a valid URL check row no. "+k+"~");
							isValid = false;
						}
					}
						
						/*else {
						boolean urlCheck = threatIOCService.validateIndicatorValue("URL", lineValidation[12]);
						if (urlCheck == false) {
							resMsg.append("'URL' value is not valid in column 'M'. Check the row no " + k );
							isValid = false;
						}
					}*/

				}

				if (indicatorTypeVal.equalsIgnoreCase("Domain")) {
					StringBuilder otherCol = new StringBuilder();
					if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim())
							|| !StringUtils.isEmpty(lineValidation[9].trim())
							|| !StringUtils.isEmpty(lineValidation[10].trim())
							|| !StringUtils.isEmpty(lineValidation[11].trim())
							|| !StringUtils.isEmpty(lineValidation[12].trim())
							|| !StringUtils.isEmpty(lineValidation[14].trim())
							|| !StringUtils.isEmpty(lineValidation[15].trim())
							|| !StringUtils.isEmpty(lineValidation[16].trim())) {
						if (!StringUtils.isEmpty(lineValidation[7].trim())
								|| !StringUtils.isEmpty(lineValidation[8].trim())
								|| !StringUtils.isEmpty(lineValidation[9].trim())
								|| !StringUtils.isEmpty(lineValidation[10].trim()))
							otherCol.append("Indicator type 'Domain' must not have value in File_Name or MD5_Hash or SHA1_Hash or SHA256_Hash.");
						if (!StringUtils.isEmpty(lineValidation[11].trim()))
							otherCol.append("Indicator type 'Domain' must not have value in IP Address (column 'L').");
						if (!StringUtils.isEmpty(lineValidation[12].trim()))
							otherCol.append("Indicator type 'Domain' must not have value in URL (column 'M').");
						if (!StringUtils.isEmpty(lineValidation[14].trim()))
							otherCol.append("Indicator type 'Domain' must not have value in Hostname (column 'O').");
						if (!StringUtils.isEmpty(lineValidation[15].trim()))
							otherCol.append("Indicator type 'Domain' must not have value in Mutex (column 'P').");
						if (!StringUtils.isEmpty(lineValidation[16].trim()))
							otherCol.append("Indicator type 'Domain' must not have value in Email (column 'Q').");

						resMsg.append(otherCol + " " + "Check the row no " + k  +"~");
						isValid = false;
					}
					if (StringUtils.isEmpty(lineValidation[13].trim())) {
						resMsg.append("Indicator type 'Domain' must have Domain value in column 'N'. Check the row no " + k  +"~");
						isValid = false;
					} else {
						if (lineValidation[13].trim().startsWith("http") || lineValidation[13].trim().startsWith("https")) {
							resMsg.append("Domain should not start with http or https. Check the row no " + k + "~");
							isValid = false;
						}
						if (!threatIOCService.isValidRegex(".", lineValidation[13].trim())) {
							resMsg.append("URL contains special character . should be covered with [] like [.]. Check the row no " + k + "~");
							isValid = false;
						}
						if (!threatIOCService.isValidRegex(":", lineValidation[13].trim())) {
							resMsg.append("URL contains special character : should be covered with [] like [:]. Check the row no " + k + "~");
							isValid = false;
						}
						//validate Domain
						Boolean domainCheck = threatIOCService.validateIndicatorValue(Constants.IOCIndicatorType.Domain, lineValidation[13].trim().replace("[.]", ".").replace("[:]", ":"));
						if (!domainCheck) {
							resMsg.append("Domain entered is not valid. Please enter a valid domain check row no. "+k+"~");
							isValid = false;
						}
					}
					/*else {
						boolean domainCheck = threatIOCService.validateIndicatorValue("Domain", lineValidation[13]);
						if (domainCheck == false) {
							resMsg.append("'Domain' value is not valid in column 'N'. Check the row no " + k );
							isValid = false;
						}
					}*/

				}

				if (indicatorTypeVal.equalsIgnoreCase("Hostname")) {
					StringBuilder otherCol = new StringBuilder();
					if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim())
							|| !StringUtils.isEmpty(lineValidation[9].trim()) || !StringUtils.isEmpty(lineValidation[10].trim())
							|| !StringUtils.isEmpty(lineValidation[11].trim()) || !StringUtils.isEmpty(lineValidation[12].trim())
							|| !StringUtils.isEmpty(lineValidation[13].trim()) || !StringUtils.isEmpty(lineValidation[15].trim())
							|| !StringUtils.isEmpty(lineValidation[16].trim())) {
						if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim())
								|| !StringUtils.isEmpty(lineValidation[9].trim()) || !StringUtils.isEmpty(lineValidation[10].trim()))
							otherCol.append("Indicator type 'Hostname' must not have value in File_Name or MD5_Hash or SHA1_Hash or SHA256_Hash.");
						if (!StringUtils.isEmpty(lineValidation[11].trim()))
							otherCol.append("Indicator type 'Hostname' must not have value in IP Address (column 'L').");
						if (!StringUtils.isEmpty(lineValidation[12].trim()))
							otherCol.append("Indicator type 'Hostname' must not have value in URL (column 'M').");
						if (!StringUtils.isEmpty(lineValidation[13].trim()))
							otherCol.append("Indicator type 'Hostname' must not have value in Domain (column 'N').");
						if (!StringUtils.isEmpty(lineValidation[15].trim()))
							otherCol.append("Indicator type 'Hostname' must not have value in Mutex (column 'P').");
						if (!StringUtils.isEmpty(lineValidation[16].trim()))
							otherCol.append("Indicator type 'Hostname' must not have value in Email (column 'Q').");

						resMsg.append(otherCol + " " + "Check the row no " + k  +"~");
						isValid = false;
					}
					if (StringUtils.isEmpty(lineValidation[14].trim())) {
						resMsg.append("Indicator type 'Host name' must have Host names value in column 'O'. Check the row no " + k  +"~");
						isValid = false;
					} /*else {
						boolean hostCheck = threatIOCService.validateIndicatorValue("Host name", lineValidation[14]);
						if (hostCheck == false) {
							resMsg.append("'Host name' value is not valid in column 'O'. Check the row no " + k );
							isValid = false;
						}
					}*/

				}

				if (indicatorTypeVal.equalsIgnoreCase("Mutex")) {
					StringBuilder otherCol = new StringBuilder();
					if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim())
							|| !StringUtils.isEmpty(lineValidation[9].trim()) || !StringUtils.isEmpty(lineValidation[10].trim())
							|| !StringUtils.isEmpty(lineValidation[11].trim()) || !StringUtils.isEmpty(lineValidation[12].trim())
							|| !StringUtils.isEmpty(lineValidation[13].trim()) || !StringUtils.isEmpty(lineValidation[14].trim())
							|| !StringUtils.isEmpty(lineValidation[16].trim())) {
						if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim()) || !StringUtils.isEmpty(lineValidation[9].trim()) || !StringUtils.isEmpty(lineValidation[10].trim()))
							otherCol.append("Indicator type 'Mutex' must not have value in File_Name or MD5_Hash or SHA1_Hash or SHA256_Hash.");
						if (!StringUtils.isEmpty(lineValidation[11].trim()))
							otherCol.append("Indicator type 'Mutex' must not have value in IP Address (column 'L').");
						if (!StringUtils.isEmpty(lineValidation[12].trim()))
							otherCol.append("Indicator type 'Mutex' must not have value in URL (column 'M').");
						if (!StringUtils.isEmpty(lineValidation[13].trim()))
							otherCol.append("Indicator type 'Mutex' must not have value in Domain (column 'N').");
						if (!StringUtils.isEmpty(lineValidation[14].trim()))
							otherCol.append("Indicator type 'Mutex' must not have value in Host name (column 'O').");
						if (!StringUtils.isEmpty(lineValidation[16].trim()))
							otherCol.append("Indicator type 'Mutex' must not have value in Email (column 'Q').");

						resMsg.append(otherCol + " " + "Check the row no " + k  +"~");
						isValid = false;
					}
					if (StringUtils.isEmpty(lineValidation[15].trim())) {
						resMsg.append("Indicator type 'Mutex' must have Mutex value in column 'P'. Check the row no " + k  +"~");
						isValid = false;
					}

				}

				if (indicatorTypeVal.equalsIgnoreCase("Email")) {
					StringBuilder otherCol = new StringBuilder();
					if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim())
							|| !StringUtils.isEmpty(lineValidation[9].trim()) || !StringUtils.isEmpty(lineValidation[10].trim())
							|| !StringUtils.isEmpty(lineValidation[11].trim()) || !StringUtils.isEmpty(lineValidation[12].trim())
							|| !StringUtils.isEmpty(lineValidation[13].trim()) || !StringUtils.isEmpty(lineValidation[14].trim())
							|| !StringUtils.isEmpty(lineValidation[15].trim())) {
						if (!StringUtils.isEmpty(lineValidation[7].trim()) || !StringUtils.isEmpty(lineValidation[8].trim()) || !StringUtils.isEmpty(lineValidation[9].trim())
								|| !StringUtils.isEmpty(lineValidation[10].trim()))
							otherCol.append("Indicator type 'Email' must not have value in File_Name or MD5_Hash or SHA1_Hash or SHA256_Hash.");
						if (!StringUtils.isEmpty(lineValidation[11].trim()))
							otherCol.append("Indicator type 'Email' must not have value in IP Address (column 'L').");
						if (!StringUtils.isEmpty(lineValidation[12].trim()))
							otherCol.append("Indicator type 'Email' must not have value in URL (column 'M').");
						if (!StringUtils.isEmpty(lineValidation[13].trim()))
							otherCol.append("Indicator type 'Email' must not have value in Domain (column 'N').");
						if (!StringUtils.isEmpty(lineValidation[14].trim()))
							otherCol.append("Indicator type 'Email' must not have value in Host name (column 'O').");
						if (!StringUtils.isEmpty(lineValidation[15].trim()))
							otherCol.append("Indicator type 'Email' must not have value in Mutex (column 'P').");

						resMsg.append(otherCol + " " + "Check the row no " + k  +"~");
						isValid = false;
					}
					if (StringUtils.isEmpty(lineValidation[16].trim())) {
						resMsg.append("Indicator type 'Email' must have Email value in column 'Q'. Check the row no " + k  +"~");
						isValid = false;
					}
					//Email validate
					Boolean emailCheck = threatIOCService.validateIndicatorValue(Constants.IOCIndicatorType.Email, lineValidation[16].trim().replace("[.]", ".").replace("[:]", ":"));
					if (!emailCheck) {
						resMsg.append("Email entered is not valid. Please enter a valid email check row no. "+k+"~");
						isValid = false;
					}
					/* else {
						boolean emailCheck = threatIOCService.validateIndicatorValue("Email", lineValidation[15]);
						if (emailCheck == false) {
							resMsg.append("'Email' value is not valid in column 'Q'. Check the row no " + k );
							isValid = false;
						}
					}*/

				}

			}
		} catch (Exception e) {
			log.error("Error in validate Malware IOCCsv {}", e.getMessage());
			e.printStackTrace();
		}

		String statusMsg = "";
		if (isValid) {
			resMsg.append("Uploaded " + file.getOriginalFilename() + "  Malware IOC CSV file is Valid.");
			statusMsg = "success";
		} else {
		   statusMsg = "error";
		}

		return ResponseEntity.ok().headers(HeaderUtil.createEntityUpdateAlert(ENTITY_NAME, ""))
				.body("{\"status\":\"" + statusMsg + "\",\"message\":\"" + resMsg + "\"}");
	}
    
    @GetMapping("/malwares/ioc-csv-template")
	public void downloadCSVTemplate(HttpServletResponse response) {

		response.setContentType("text/CSV; charset=utf-8");
		response.setHeader("Content-Disposition", "attachment; filename=ioc.csv");
		String columns = "MD5_Hash,SHA,IP,,Domain,Hostname,URL,Mutex,Email,CVE,Exploit File,SSL";
		log.debug("REST request to get a page of Malwares IOCs");

		try {
			
			response.getWriter().write(columns);
		} catch (Exception e) {
			log.error("Error fetching data, Message" + e.getMessage());
		}
	}
    

    @GetMapping("/download-malwares")
   	public void  malwareIocExport(@RequestParam(required=true)String malwareId,HttpServletResponse response) {
     	response.setHeader("Content-Disposition", "attachment; filename=malwareioc.csv");
		String COMMA_DELIMITER = ",";
		String NEW_LINE_SEPARATOR = "\n";
		String HYPHEN = "-";
		String columns = "Last Seen,Threat Actor,Indicator Type,Role,File Name,MD5 Hash,SHA1 Hash,SHA256 Hash,IP,URL,Domain,Hostname,Mutex,Email,Recommended Action";
		Calendar c = Calendar.getInstance();
    	c.add(Calendar.YEAR, -1);
    	List<MalwareIOC> malware = malwareIOCRepository.findByMalwareIdAndLastSeenGreaterThanOrderByLastSeenDesc(malwareId, c.getTime());
		try {
			response.getWriter().write(columns);
			response.getWriter().append(NEW_LINE_SEPARATOR);
			for (int i = 0; i < malware.size(); i++) {
				if (malware.get(i).getLastSeen() != null && !StringUtils.isEmpty(malware.get(i).getLastSeen().toString()))
					response.getWriter().append("\"" + malware.get(i).getLastSeen().toString() + "\"");
				else
					response.getWriter().append("\"" + HYPHEN + "\"");

				response.getWriter().append(COMMA_DELIMITER);

				if (malware.get(i).getThreatActorName() != null && !"".equals(malware.get(i).getThreatActorName()))
					response.getWriter().append("\"" + malware.get(i).getThreatActorName() + "\"");
				else
					response.getWriter().append("\"" + HYPHEN + "\"");

				response.getWriter().append(COMMA_DELIMITER);

				if (malware.get(i).getIndicatorType() != null && !"".equals(malware.get(i).getIndicatorType()))
					response.getWriter().append("\"" + malware.get(i).getIndicatorType() + "\"");
				else
					response.getWriter().append("\"" + HYPHEN + "\"");

				response.getWriter().append(COMMA_DELIMITER);

				if (malware.get(i).getRole() != null && !"".equals(malware.get(i).getRole()))
					response.getWriter().append("\"" + malware.get(i).getRole() + "\"");
				else
					response.getWriter().append("\"" + HYPHEN + "\"");

				response.getWriter().append(COMMA_DELIMITER);

				if (malware.get(i).getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.FileHash)
						&& malware.get(i).getFileName() != null && !"".equals(malware.get(i).getFileName()))
					response.getWriter().append("\"" + malware.get(i).getValue() + "\"");
				else
					response.getWriter().append("\"" + HYPHEN + "\"");

				response.getWriter().append(COMMA_DELIMITER);

				if (malware.get(i).getMd5Hash() != null && !"".equals(malware.get(i).getMd5Hash()))
					response.getWriter().append("\"" + malware.get(i).getMd5Hash() + "\"");
				else
					response.getWriter().append("\"" + HYPHEN + "\"");

				response.getWriter().append(COMMA_DELIMITER);

				if (malware.get(i).getSha1Hash() != null && !"".equals(malware.get(i).getSha1Hash()))
					response.getWriter().append("\"" + malware.get(i).getSha1Hash() + "\"");
				else
					response.getWriter().append("\"" + HYPHEN + "\"");

				response.getWriter().append(COMMA_DELIMITER);

				if (malware.get(i).getSha256Hash() != null && !"".equals(malware.get(i).getSha256Hash()))
					response.getWriter().append("\"" + malware.get(i).getSha256Hash() + "\"");
				else
					response.getWriter().append("\"" + HYPHEN + "\"");

				response.getWriter().append(COMMA_DELIMITER);

				if (malware.get(i).getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.IP)
						&& malware.get(i).getValue() != null && !"".equals(malware.get(i).getValue()))
					response.getWriter().append("\"" + malware.get(i).getValue() + "\"");
				else
					response.getWriter().append("\"" + HYPHEN + "\"");

				response.getWriter().append(COMMA_DELIMITER);

				if (malware.get(i).getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.URL)
						&& malware.get(i).getValue() != null && !"".equals(malware.get(i).getValue()))
					response.getWriter().append("\"" + malware.get(i).getValue() + "\"");
				else
					response.getWriter().append("\"" + HYPHEN + "\"");

				response.getWriter().append(COMMA_DELIMITER);

				if (malware.get(i).getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.Domain)
						&& malware.get(i).getValue() != null && !"".equals(malware.get(i).getValue()))
					response.getWriter().append("\"" + malware.get(i).getValue() + "\"");
				else
					response.getWriter().append("\"" + HYPHEN + "\"");

				response.getWriter().append(COMMA_DELIMITER);

				if (malware.get(i).getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.Hostname)
						&& malware.get(i).getValue() != null && !"".equals(malware.get(i).getValue()))
					response.getWriter().append("\"" + malware.get(i).getValue() + "\"");
				else
					response.getWriter().append("\"" + HYPHEN + "\"");

				response.getWriter().append(COMMA_DELIMITER);

				if (malware.get(i).getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.Mutex)
						&& malware.get(i).getValue() != null && !"".equals(malware.get(i).getValue()))
					response.getWriter().append("\"" + malware.get(i).getValue() + "\"");
				else
					response.getWriter().append("\"" + HYPHEN + "\"");

				response.getWriter().append(COMMA_DELIMITER);

				if (malware.get(i).getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.Email)
						&& malware.get(i).getValue() != null && !"".equals(malware.get(i).getValue()))
					response.getWriter().append("\"" + malware.get(i).getValue() + "\"");
				else
					response.getWriter().append("\"" + HYPHEN + "\"");

				response.getWriter().append(COMMA_DELIMITER);

				if (malware.get(i).getRecommendedAction() != null && !"".equals(malware.get(i).getRecommendedAction()))
					response.getWriter().append("\"" + malware.get(i).getRecommendedAction() + "\"");
				else
					response.getWriter().append("\"" + HYPHEN + "\"");

				response.getWriter().append(COMMA_DELIMITER);

				response.getWriter().append(NEW_LINE_SEPARATOR);

			}
		}	catch (Exception e) {
			log.error("Error in exporting MalwareIoc to csv {}", e.getMessage());
			e.printStackTrace();
		}
	}
     
    @GetMapping("/malwares/anyrun-ioc")
    public String  scrapeAnyrunIOC() {
    	malwareService.scrapeAnyrunIOC();
    	return "Done";
    }
    
    
    @GetMapping("/download-malwares/v2")
   	public void  malwareIocExportV2(@RequestParam(required=true)String malwareId,HttpServletResponse response) {
     	response.setHeader("Content-Disposition", "attachment; filename=malwareioc.csv");
     	
		Calendar c = Calendar.getInstance();
    	c.add(Calendar.YEAR, -1);
    	List<MalwareIOC> threatioc = malwareIOCRepository.findByMalwareIdAndLastSeenGreaterThanOrderByLastSeenDesc(malwareId, c.getTime());
		String[] cscolumns   = { "Client_Name","Threat Actor","UID","EID","Indicator Type","Role","File Name","MD5 Hash","SHA1 Hash","SHA256 Hash","IP","URL","Domain","Hostname","Mutex","Email","Recommended Action","Risk Score","First Seen","Last Seen","Reported_Date", "Campaign Name","Description"};
		try {
		CSVWriter csvWriter = new CSVWriter(response.getWriter(), CSVWriter.DEFAULT_SEPARATOR,CSVWriter.DEFAULT_QUOTE_CHARACTER, CSVWriter.DEFAULT_LINE_END);
		csvWriter.writeNext(cscolumns);
		 SimpleDateFormat dateFormat2 = new SimpleDateFormat("yyyy-MM-dd");
		 
		  List<String[]> dataLines = new ArrayList<>();
    	if ( !CollectionUtils.isEmpty(threatioc))
    	{
				for (MalwareIOC ioc:threatioc) {
					String Client_Name="";
					String Threat_Actor="";
					String UID="";
					String EID="";
					String Indicator_Type="";
					String Role="";
					String File_Name="";
					String MD5_Hash="";
					String SHA1_Hash="";
					String SHA256_Hash="";
					String IP="";
					String URL="";
					String Domain="";
					String Hostname="";
					String Mutex="";
					String Email="";
					String Recommended_Action="";
					String Risk_Score="";
					String First_Seen="";
					String Last_Seen="";
					String Reported_Date="";
					String Campaign_Name="";
					String Description="";
					/*
					 * if (!CollectionUtils.isEmpty(threatioc.get(i).getClientName())) Client_Name=
					 * threatioc.get(i).getClientName().toString();
					 */
					if (!StringUtils.isEmpty(ioc.getThreatActorName()))
					      Threat_Actor= ioc.getThreatActorName();
		
					if (!StringUtils.isEmpty(ioc.getUid()))
					UID = ioc.getUid();
					if (!StringUtils.isEmpty(ioc.getEid()))
						EID= ioc.getEid() ;
					if (!StringUtils.isEmpty(ioc.getIndicatorType() ))
						Indicator_Type=ioc.getIndicatorType();
					if (!StringUtils.isEmpty(ioc.getRole()))
						Role=  ioc.getRole();
					if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.FileHash)
							&&!StringUtils.isEmpty(ioc.getFileName()))
						File_Name= ioc.getValue();
					if (!StringUtils.isEmpty(ioc.getMd5Hash() ))
						MD5_Hash	= ioc.getMd5Hash();
					if (!StringUtils.isEmpty(ioc.getSha1Hash() ))
						SHA1_Hash= ioc.getSha1Hash() ;
					if (!StringUtils.isEmpty(ioc.getSha256Hash()))
						SHA256_Hash= ioc.getSha256Hash();
					if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.IP)
							&& !StringUtils.isEmpty(ioc.getValue()))
						IP= ioc.getValue() ;
			
	
					if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.URL)
							&& !StringUtils.isEmpty(ioc.getValue()))
						URL=ioc.getValue();
					if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.Domain)
							&& !StringUtils.isEmpty(ioc.getValue()))
						Domain=ioc.getValue();
					if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.Hostname)
							&& !StringUtils.isEmpty(ioc.getValue()))
						Hostname= ioc.getValue();
					
					if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.Mutex)
							&& !StringUtils.isEmpty(ioc.getValue()))
						Mutex= ioc.getValue();
					if (ioc.getIndicatorType().equalsIgnoreCase(Constants.IOCIndicatorType.Email)
							&& !StringUtils.isEmpty(ioc.getValue()))
						Email= ioc.getValue();
					if (!StringUtils.isEmpty(ioc.getRecommendedAction() ))
						Recommended_Action= ioc.getRecommendedAction();
					if (!StringUtils.isEmpty(ioc.getThreatScore()))
					Risk_Score= ioc.getThreatScore();
					if (ioc.getFirstSeen() != null)
						First_Seen= dateFormat2.format( ioc.getFirstSeen());
					if (ioc.getLastSeen() != null )
						Last_Seen= dateFormat2.format( ioc.getLastSeen());
					if (ioc.getReportedDate() != null )
						Reported_Date= dateFormat2.format(ioc.getReportedDate());
						
					
					if (!CollectionUtils.isEmpty(ioc.getCampaignIds())){	Set<String> campaignNameSet = new HashSet<String>();
					List<RecentCampaign> campgainList = recentCampaignRepository
							.findByIdIn(ioc.getCampaignIds());
					if (!CollectionUtils.isEmpty(campgainList)) {
						campaignNameSet.addAll(campgainList.stream().map(RecentCampaign::getTitle)
								.collect(Collectors.toList()));
					}
					for (String tag : ioc.getCampaignIds()) {
						if (!StringUtils.isEmpty(tag) && MasterDataServiceImpl.masterRecentCampaign
								.contains(tag.toLowerCase().trim()))
							if (Campaign_Name.isEmpty())
								campaignNameSet.add(StringUtils.capitalize(tag));
							else
								campaignNameSet.add(StringUtils.capitalize(tag));
					}

					if (!CollectionUtils.isEmpty(campaignNameSet)) {
						Campaign_Name = String.join(",", campaignNameSet);
					}}
					if (!StringUtils.isEmpty(ioc.getDescription()))
					Description=ioc.getDescription();
	
	
					dataLines.add(new String[] {Client_Name,Threat_Actor,UID,EID,Indicator_Type,Role,File_Name,MD5_Hash,SHA1_Hash,SHA256_Hash,IP,URL,Domain,Hostname,Mutex,Email,Recommended_Action,Risk_Score,First_Seen,Last_Seen,Reported_Date, Campaign_Name,Description});
				}
				  csvWriter.writeAll(dataLines);
    	}
    	   csvWriter.flush();
    	csvWriter.close();	
		}
		 catch (Exception e) {
				log.error("Error in exporting CampaignIoc to csv {}", e.getMessage());
			}
	}
     
    @GetMapping("/search-date-range")
    public Page<MalwareUpdateAuditCount> searchByDateRange(
            @RequestParam @DateTimeFormat(pattern = "yyyy-MM-dd") Date startDate,
            @RequestParam @DateTimeFormat(pattern = "yyyy-MM-dd") Date endDate,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        Pageable pageable = PageRequest.of(page, size);
        return  malwareUpdateCountAuditRepository.findByModifyDateBetween(startDate, endDate, pageable);
       
    }
	
	
	 @GetMapping("/record")
    public Page<MalwareUpdateAuditCount> getAllMalwareHistory(int page, int size) {
        PageRequest pageRequest = PageRequest.of(page, size);
        return malwareUpdateCountAuditRepository.findAll(pageRequest);
    }
	 
	 @GetMapping("/malware-download")
		public ResponseEntity<Resource> download() throws IOException {
			
			String filename = "employee.csv";
			ByteArrayInputStream actualData =   malwareService.getActualData();

			InputStreamResource file = new InputStreamResource(actualData);
			
			ResponseEntity<Resource> body =    ResponseEntity.ok()
			.header(org.springframework.http.HttpHeaders.CONTENT_DISPOSITION,"attachement; filename="+filename)
			.contentType(MediaType.parseMediaType("application/vnd.ms-excel")).body(file);
			
			return body;
			
		}
}






<div class="filter-container">
<img title="Export Malware count to CSV" class="cp" width="40" style="margin-top: 0px"
  src="../../../../content/images/cap2.0/cyfirma_v1/CYFIRMA_icon_csv_export.png"
  (click)="pov != 'TRIAL_POV' ? malwareDownload() : null" />
</div>


 <h1 jhiTranslate="cyfirmaweb.listview.common.searchmalwarehitory" style="color: #1e81b0;"></h1>


<form (ngSubmit)="searchDateRange(name,startDate,endDate,page,size)" #searchForm="ngForm" id="check">
  <div class="form-group">
    <table>
      <tr>
        <!-- <td>
          <input type="text"  class="mat-form-field-infix" id="name" name="name" [(ngModel)]="name" required [placeholder]="'Malware Name'">
        </td>  -->
        &nbsp;&nbsp;
         <td>
          <input type="date" class="mat-form-field-infix" id="startDate" name="startDate" [(ngModel)]="startDate"
            required placeholder="From Date">
        </td>
        &nbsp;&nbsp;
        <td> <input type="date" class="mat-form-field-infix" id="endDate" name="endDate"
            [(ngModel)]="endDate" required placeholder="To Date">
        </td>
        &nbsp;&nbsp;&nbsp;
        <td><button type="submit" class="closeButton" jhiTranslate="cyfirmaweb.dashboard.search"></button></td> &nbsp;
        
        <td><button type="button" (click)="resetForm()" class="closeButton" jhiTranslate="cyfirmaweb.listview.common.reset"></button></td>
      </tr>
    </table>
  </div>
</form>

<br />
<div class="table-responsive text-nowra">
  <table class="table table-striped mlw-table" >
    <thead>
      <tr>
        <th class="rs" jhiTranslate="cyfirmaweb.listview.common.name"></th>
        <th class="rs" jhiTranslate="cyfirmaweb.listview.common.modifyDate"></th>
        <th class="rs" jhiTranslate="cyfirmaweb.listview.common.modifiedBy"></th>
        <th class="rs" jhiTranslate="cyfirmaweb.listview.common.modifycount" ></th>
      </tr>
    </thead>
    <tbody>
      <tr *ngFor="let malware of malwares">
        <td class="c1">{{malware.name}}</td>
        <td class="c2">{{malware.modifyDate}}</td>
        <td class="c3">{{malware.modifiedBy}}</td>
        <td class="c4">{{malware.updateCount}}</td>
      </tr>
      <tr>
      <!-- <mat-paginator [length]="totalElements" [pageSize]="size" [pageIndex]="page" (page)="onPageChange($event)" id="next"></mat-paginator> -->
        </tr>
    </tbody>
    <mat-paginator [length]="totalElements" [pageSize]="size" [pageIndex]="page" (page)="onPageChange($event)" id="next"></mat-paginator>
  </table>
</div>
<div>
  <button type="button" (click)="closeDialog()" id="close" jhiTranslate="alertCenter.labels.close"></button>
</div> 



<!-- 
<div *ngFor="let malware of malwares">
 <form>
  <label for="name">Name:</label>
  <input type="text" id="name" name="name" [(ngModel)]="malware.name">
 
  <button type="submit">Save</button>
</form>
</div> -->




import { Component, OnInit, ViewChild } from '@angular/core';
import { MalwareUpdateHistoryService } from './malware-update-history.service';
import { MalwareHistory } from '../malware-history';
import { MatDialogRef } from '@angular/material/dialog';
import { ActivatedRoute } from '@angular/router';
import { data } from 'jquery';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'jhi-date-dailog',
  templateUrl: './malware-date-dailog.component.html',
  styleUrls: ['./malware-date-dailog.component.scss'],
})
export class MalwareDateDailogComponent implements OnInit {

  malwares: MalwareHistory[] = [];
  name: string = '';
  startDate: string = '';
  endDate: string = '';
  currentPage = 0;
  pageSize = 10;
  page = 0;
  size = 10;
  totalElements = 0;
  
  recordId!: string;
  id: any;
  FromDate:string= 'From Date';

  


  constructor(private malwareHistoryService: MalwareUpdateHistoryService,
    private route: ActivatedRoute,
    private http: HttpClient,
    private activateRouter:ActivatedRoute,
    private dialogRef: MatDialogRef<MalwareDateDailogComponent>
    
    ) { }

  ngOnInit(): void {

    this.loadRecords();
    
  }


  resetForm() {
    this.name = '';
    this.startDate = '';
    this.endDate = '';
    this.getUpdateMalwares();
  }

  closeDialog() {
    this.dialogRef.close('Dialog closed with result');
  }

  getUpdateMalwares(){
    this.malwareHistoryService.getUpdateMalwares(this.page=0, this.size=10)
    .subscribe((data: any) => {
      this.malwares = data.content;
      
    });
  }
  
  searchDateRange(name: string, startDate: Date, endDate: Date,page: number, size: number) {

    this.malwareHistoryService.searchDateRange(name, startDate, endDate,this.currentPage,this.pageSize).subscribe((data : any) => {
      this.malwares = data.content;
    })
  }



  loadRecords(): void {
    this.malwareHistoryService.getPaginatedRecords(this.page, this.size).subscribe((page) => {
      this.malwares = page.content;
      this.totalElements = page.totalElements;
    });
  }

  onPageChange(event: any): void {
    this.page = event.pageIndex;
    this.size = event.pageSize;
    this.loadRecords();
  }

  malwareDownload() {
    this.malwareHistoryService.downloadExcel().subscribe(response => {
      const blob = new Blob([response], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'malware.csv';
      a.click();
      window.URL.revokeObjectURL(url);
    });
  }

}  



import { HttpClient, HttpParams } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class MalwareUpdateHistoryService {

  private resourceUrl = SERVER_API_URL + 'core/api';


  private resourceUrl2 = SERVER_API_URL + 'core/api/search-date-range';
  private resourceUrl4 = SERVER_API_URL + 'core/api/getmalwares';
  private resourceUrl5 = SERVER_API_URL + 'core/api/record';

  constructor(private httpClient:HttpClient) { }

 
  
  getMalwareHistoryByName(page: number, size: number) {
    const params = new HttpParams()
      .set('page', page.toString())
      .set('size', size.toString());
    
    return this.httpClient.get<any[]>(`${this.resourceUrl}/list`, { params });
  }

  getUpdateMalwares(page: number, size: number):Observable<any>{
    const params = new HttpParams()
    .set('page', page.toString())
    .set('size', size.toString());
    return this.httpClient.get<any>(`${this.resourceUrl5}`,{params})
   }
  

  searchDateRange(name:string,startDate:Date,endDate:Date,page: number, size: number):Observable<any[]>{
    
    const params = new HttpParams()
    .set('page', page.toString())
    .set('size', size.toString());

    return this.httpClient.get<any[]>(`${this.resourceUrl2}?name=${name}&startDate=${startDate}&endDate=${endDate}` , {params})
  }

   
  getPaginatedRecords(page: number, size: number): Observable<any> {
    const params = new HttpParams()
      .set('page', page.toString())
      .set('size', size.toString());

    return this.httpClient.get<any>(this.resourceUrl5, { params });
  }


  downloadExcel() {
    return this.httpClient.get('core/api/malware-download', { responseType: 'blob' });
  }

}



/* eslint-disable @typescript-eslint/restrict-template-expressions */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/restrict-plus-operands */
import { Component, OnInit, OnDestroy } from '@angular/core';
import { HttpErrorResponse, HttpResponse } from '@angular/common/http';
import { Router, ActivatedRoute, Params } from '@angular/router';
import { MatDialog } from '@angular/material/dialog';
import { MatDatepickerInputEvent } from '@angular/material/datepicker';
import { DataCommunicationService, DataService, createRequestOption } from '../../../shared';
import { saveAs } from 'file-saver';
import { Observable, Subscription } from 'rxjs';
import { OrgDetailsService, OrgAssetsService } from '../../../org/org-details-service';
import {
  ClientIncidentService,
  DarkWebService,
  DatabreachIpVulnerabilityService,
  PhishingService,
  OpenCloudVulnerabilityService,
} from '../../../core/services';
import { CyberThreatDashboardService } from '../../../cyber-threat/services/cyber-threat-dashboard.service';
import {
  CampaignComponent,
  ClientDarkwebComponent,
  ClientIncidentComponent,
  IocComponent,
  MalwareComponent,
  MatDialogComponent,
  PhishingDetailsComponent,
  ReportDarkwebObservationsComponent,
} from '../../../shared/components';
import { DialogComponent } from '../../../cyber-threat/dialog/dialog.component';
import { ClientIncident, Geography } from '../../../core/models';
import { Org } from '../../../org/models';
import { OrgService } from '../../../org/org.service';
import $ from 'jquery';
import { OpenCVBDDialogComponent } from '../../../shared/components/opencvdb-dialog/opencvdb-dialog.component';
import { MalwareDateDailogComponent } from './malware-date-dailog/malware-date-dailog.component'; 

@Component({
  selector: 'jhi-list-view',
  templateUrl: './list-view.component.html',
  styleUrls: ['./list-view.component.scss', './digitalrisk/digitalrisk.component.scss', '../tvi.component.scss'],
})
export class TviListViewComponent implements OnInit, OnDestroy {
  private pagerSubscription: Subscription;
  select = 'geography';
  geography: string[] = [];
  industry: string[] = [];
  country: string[] = [];


  params: any;
  routeName: any;
  isAnalyst: boolean;
  pType!: string;
  dwType: any = 'early-warnings';
  pVulnType!: string;
  pAttackType!: string;
  range!: string;
  whatsNew: any;
  clientId!: number;
  filterBy!: string;
  wncat!: any[];
  impactList: string[];
  isLow: boolean;
  isMedium: boolean;
  isHigh: boolean;
  isCritical: boolean;
  isImpactSelected: boolean;
  threatActorPre: string;
  threatActorPost: string;
  genericString: string;
  topCyberSearch!: string;
  reportedCampaignString: string;
  recentMalware: string;
  safeEnable = "Unsafe";
  selectedTab = "";
  ransomwareTab = 'Client';
  dwTab = 'Client';
  searchToggle = false;
  tabConfig: any = {
    client: 'Client',
    global: 'Global',
    top: 'Top',
    stb: 'Client',
    ransomeware: 'ransomeware',
    ransomewareClient: 'ransomewareClient',
  };
  sfwConfig: any = {
    stb: 'software & services',
    tabs: ['Software & Services', 'Cookies', 'URL Forms'],
    data: [],
  };
  filterOpt: any = {
    date: {
      isDateRange: false,
      minDate: new Date(),
      maxDate: new Date(),
      fd: null,
      td: new Date(),
      defDV: 90,
      defDL: [],
    },
    search: '',
    country: '',
    industry: '',
  };
  navInfo: any;
  req: any;
  // ransomwareGITList: any[] = []


  // filter data based on search name
  filterBySearch(name: string) {

    if (this.navInfo.activeTab === 'ransomwareTab') {
      if (name === 'search') {
        this.req.topCyberSearch = this.filterOpt.search;
        this.loadSubTab(this.navInfo.activeSubTab, true);
      }
      else if (name === 'country') {
        localStorage.setItem('country', this.filterOpt.country);
        this.req.isGeography = true;
        this.req.country = this.filterOpt.country;
        this.loadSubTab(this.navInfo.activeSubTab, false);
      }
      else if (name === 'industry') {
        localStorage.setItem('industry', this.filterOpt.industry);
        this.req.isIndustry = true;
        this.req.industry = this.filterOpt.industry;
        this.loadSubTab(this.navInfo.activeSubTab, false);
      }
    }
  }


  loadSubTab(subTab: string, htmlCalled?: boolean) {

    if (htmlCalled) {
      this.dcs.resetPagerInfo();
      this.req.page = 0;
    }

    this.navInfo.activeSubTab = subTab;
    this.req.sort = this.navInfo.sortByDate;

    if (this.navInfo.activeTab === 'client') {
      if (localStorage.getItem('country')) {
        this.filterOpt.country = localStorage.getItem('country');
        this.req.country = this.filterOpt.country;
      } else {
        this.filterOpt.country = '';
      }

      if (localStorage.getItem('industry')) {
        this.filterOpt.industry = localStorage.getItem('industry');
        this.req.industry = this.filterOpt.industry;
      } else {
        this.filterOpt.industry = '';
      }
    }
  }

  searchRansomwareData() {
    const pageReq: any = { page: 0, size: 20, sort: ['date,DESC'] }

    const req: any = {
      geography: this.filterOpt.country,
      industry: this.filterOpt.industry.toLowerCase(),
      orgId: this.clientId
    };
    this.ctds.search(req).subscribe(
      (res: HttpResponse<Object[]>) => {
        const totalItems: any = res.headers.get('X-Total-Count');
        this.dcs.setAjexStatus(false);
        this.dcs.setTotalRecords(totalItems, res.body!.length, pageReq.size);
         this.ransomeListClientData = res.body!
         console.log("ransomewarelistClintData: ", this.ransomeListClientData)

      },
      (error: HttpErrorResponse) => {
        (error: HttpErrorResponse) => this.onError(error)
      }
    );

  }




  clientFilterOpt: any = {
    'top-news-incident-and-attacks': ['Risk Score', 'Geography', 'Industry', 'Technology'],
    'top-geography-industry-and-technology': ['Risk Score', 'Geography', 'Industry', 'Technology'],
    sopt: '',
    git: [],
    fsd: '',
  };
  _objectKeys = Object.keys;
  private dialogConfig: any;
  private cpi!: number;
  hackerInterest: any = {};
  topListData: any;
  sveCat = 'Vulnerability';
  niaCat = 'News';
  relatedCat = 'Top News';
  topGeoCat = 'Top News';
  //  vulClientCat = 'Top vulnerabilities & Exploits';
  vulClientCat = 'Asset Related Vulnerabilities';
  vulClientSubCat = 'Attack Surface Based';
  vulnAssetWithVer: boolean;
  vulnAttSurfWithVer: boolean;
  vulnAssetWithVerFlag: boolean;
  vulnAttSurfWithVerFlag: boolean;
  vulnPrdSearch!: string;
  searchCampaign!: string;
  searchMalware!: string;
  searchPhishing!: string;
  impact!: string;
  isIndustry: boolean;
  isGeography: boolean;
  isTechnology: boolean;
  isAttackMethodDrill: boolean;
  isAssetCommentflag!: boolean;
  assetCommets = '';
  assetType = '';
  gitCats: any = {
    isIndustry: true,
    isGeography: true,
    isTechnology: true,
  };
  dispConfig: any = {};
  public gitFilterInfo: any = {};
  technologiesOptions!: any[];
  industriesOptions!: any[];
  geographiesOptions!: any[];
  public selectedGITOption: any = {};
  selectedCountry!: string;
  isDateSort = true;
  attackMethodDefaultCheck: any = 'top-phishing';
  attackMethodArray: any = [
    {
      key: 'Indicators of Compromise',
      value: 'top-indicators-compromise',
    },
    {
      key: 'Phishing',
      value: 'top-phishing',
    },
    {
      key: 'Malware',
      value: 'top-malware',
    },
    {
      key: 'Campaign',
      value: 'top-campaigns',
    },
  ];
  darkWebArray: any = [
    {
      key: 'Early Warning',
      value: 'early-warnings',
    },
    {
      key: 'Dark Web Observation',
      value: 'dw-observation',
    },
    {
      key: 'Ransomware',
      value: 'ransomeware',
    },
    {
      key: 'Ransomware',
      value: 'ransomeClient',
    },
  ];
  //  attackSurfaceDefaultCheck: any = '';
  situationAwarenessCheck: any = 'top-news-incident-and-attacks';
  situvationAwarenessArray = [
    {
      key: 'TOP CYBER NEWS, INCIDENTS AND ATTACKS',
      value: 'top-news-incident-and-attacks',
    },
  ];
  //  , {
  //    key: 'TOP GEOGRAPHY, INDUSTRY AND TECHNOLOGY',
  //    value: 'top-geography-industry-and-technology'
  //  }];
  dwobservationData: any;
  clientIncident: any;
  dwTabName: any = 'early-warnings';
  clientSubscription: any;
  vul_based_filter: any = {
    isVendor: true,
    isAsset: true,
    isAttackSurface: false,
    isVersionOnly: true,
    isAssetComment: false,
  };
  orgAssetsList: any;
  assetCommentsset = new Set();
  isRansomware!: boolean;
  ransomeListData: any[] = [];
  ransomeListClientData: any[] = [];
  ransomewarelist: any[] = [];
  selectedOrg: any[] = [];
  ransomeList: any;
  ransomeListDropDown: any = '';
  searchRansome: any;
  pov = '';
  size = 20;
  ransomwareMonitoringEnabled = false;
  openCVDB_ddSort = 0;
  openCVDB_pdSort = 0;
  openCVDB_sort: string[] = [];
  filterClientCat = 'Industry';
  tempTopList: any[] = [];
  checkWIPVersion: boolean;
  isCIAEnabled: boolean;
  dwSelectedTab: any = 'early-warnings';
  dataCommunicationService: any;
  pagerInfo: any;
  constructor(
    private router: Router,
    private activatedRoute: ActivatedRoute,
    public dialog: MatDialog,
    private ds: DataService,
    private dcs: DataCommunicationService,
    private ctds: CyberThreatDashboardService,
    private databreachIpVulnerabilityService: DatabreachIpVulnerabilityService,
    private phishingService: PhishingService,
    private darkWebService: DarkWebService,
    private clientIncidentService: ClientIncidentService,
    private orgDetailsService: OrgDetailsService,
    private orgAssetsService: OrgAssetsService,
    private orgService: OrgService,
    private opencvdbService: OpenCloudVulnerabilityService
  ) {
    this.topListData = [];
    this.impactList = [];
    this.isLow = false;
    this.isMedium = false;
    this.isHigh = false;
    this.isCritical = false;
    this.isGeography = true;
    this.isIndustry = true;
    this.isTechnology = true;
    this.isAttackMethodDrill = false;
    this.isImpactSelected = false;
    this.vulnAssetWithVer = false;
    this.vulnAttSurfWithVer = false;
    this.vulnAssetWithVerFlag = false;
    this.vulnAttSurfWithVerFlag = true;
    this.threatActorPre = 'We have identified Threat Actor : ';
    this.threatActorPost = ' as possible threat for you';
    this.genericString = 'This item has been picked up based on following correlation : ';
    this.reportedCampaignString = 'This campaign has been reported in our CTI';
    this.recentMalware = 'Most Seen malware';
    this.dispConfig = this.ds.getDispConfig();
    this.dialogConfig = this.dcs.getDialogConfig();
    this.filterOpt.date.defDL = this.ds.getQuickDateOptions();
    this.isAnalyst = this.dcs.checkAnalyst();
    this.checkWIPVersion = this.dcs.wipVersion('v1'); // temp remove after list page v2 stable
    //  if(this.isAnalyst){
    //    this.darkWebArray.push({
    //      key: 'Ransomware',
    //      value: 'ransomeware'
    //    })
    //  }
    this.gitFilterInfo = this.dcs.loadGitConfit();
    this.isCIAEnabled = this.dcs.getModuleEnabledStatus('cia');
    //  this.routeName = this.activatedRoute.snapshot.paramMap.get('name');
    this.clientSubscription = this.dcs.clientChangedSubscription$.subscribe((_ci: any) => {
      if (_ci) {
        this.clientId = _ci.id;
        // if (this.selectedOrg !== _ci.id) {
        //   this.loadClientGITData();
        // }
        if (_ci.pov) {
          this.pov = _ci.pov;
          if (this.pov && this.pov === 'TRIAL_POV') {
            this.size = 5;
          } else {
            this.size = 20;
          }
        }
        this.makeIntialCall();
      }
    });
    this.activatedRoute.queryParams.subscribe((params: Params) => {
      this.params = params;
      if (this.params.category) {
        this.pType = this.params.category;
      }
      if (this.params.view) {
        this.routeName = this.params.view;
      }
      if (this.routeName === 'attack-methods') {
        this.pType =
          this.params.category === ''
            ? this.attackMethodDefaultCheck
            : JSON.parse(JSON.parse(sessionStorage.getItem('jhi-at')!)).tab === 'executive'
              ? 'top-campaigns'
              : this.params.category;
        //  this.params.category = this.attackMethodDefaultCheck;
      }
      if (this.routeName === 'attack-method-drill' || this.routeName === 'dark-web-drill') {
        this.pType = this.params.category;
        this.pAttackType = this.params.type;
        this.isAttackMethodDrill = true;
        this.range = this.params.range;
      }
      if (sessionStorage.getItem('dwType')) {
        this.dwType = sessionStorage.getItem('dwType');
        this.getDarkWebRecords(this.dwType);
      }
      //  if (this.routeName === 'attack-surface') {
      //    this.pType = this.attackSurfaceDefaultCheck;
      //    //  this.params.category = this.attackMethodDefaultCheck;
      //  }
    });
    this.pagerSubscription = this.dcs.pageChange$.subscribe((pager: any) => {
      const _view = this.dcs.getView() ? this.dcs.getView() : '';
      // console.log(_view,this.routeName,this.params)
      //  tslint:disable-next-line: max-line-length
      if (
        pager &&
        this.params.category !== 'situational-awareness' &&
        this.params.category !== 'digital-risk' &&
        this.pType !== 'top-indicators-compromise' &&
        _view !== 'dialog'
      ) {
        this.cpi = pager.currentPage;
        if (sessionStorage.getItem('subCategory') == null) {
          if (
            this.routeName !== 'attack-methods' &&
            this.routeName !== 'ioc-drill' &&
            this.routeName !== 'attack-method-drill' &&
            //  tslint:disable-next-line: max-line-length
            this.params.category !== 'vulnerabilities'
          ) {
            //  modi on 26-03-21 && this.vulClientCat !== 'Asset Related Vulnerabilities' && this.vulClientCat !== 'Reported Vulnerabilities'
            if (this.pType === 'top-news-incident-and-attacks' && this.relatedCat === 'Related News') {
              this.getClientRelatedFilter(this.pType, this.relatedCat);
            } else if (this.pType === 'top-geography-industry-and-technology' && this.topGeoCat === 'Related News') {
              this.getTopGeoClientRelated(this.pType, this.topGeoCat);
            } else if (this.params.category === 'dark-web') {
              this.getClientDarkWebList(this.dwType);
            } else if (this.vul_based_filter.isAssetComment) {
              this.getAllvulwithAssetcomment('Asset Related Vulnerabilities', this.assetCommets);
            } else {
              const _view1 = this.dcs.getView() ? this.dcs.getView() : '';
              if (this.params.category !== 'situational-awareness' || _view1 !== 'dialog') {
                this.switchListTab(this.tabConfig.stb);
              }
            }
            //  tslint:disable-next-line: max-line-length
          } else if (this.routeName === 'attack-methods' && this.params.category !== 'vulnerabilities') {
            //  modi on 26-03-21 && this.vulClientCat !== 'Asset Related Vulnerabilities' && this.vulClientCat !== 'Reported Vulnerabilities'
            if (this.params.category === 'top-news-incident-and-attacks' && this.relatedCat === 'Related News') {
              this.getClientRelatedFilter(this.params.category, this.relatedCat);
            } else if (this.params.category === 'top-geography-industry-and-technology' && this.topGeoCat === 'Related News') {
              this.getTopGeoClientRelated(this.params.category, this.topGeoCat);
            } else {
              this.switchListTab(this.tabConfig.stb);
            }
            //  tslint:disable-next-line: max-line-length
          } else if (
            this.routeName === 'operations' &&
            this.params &&
            this.params.category === 'vulnerabilities' &&
            this.vulClientCat === 'Asset Related Vulnerabilities' &&
            this.tabConfig.stb === 'Client'
          ) {
            if (this.vul_based_filter.isAssetComment) {
              this.getAllvulwithAssetcomment('Asset Related Vulnerabilities', this.assetCommets);
            } else {
              this.getThreatViewVulByOrgAsset(this.vulClientCat);
            } //  tslint:disable-next-line: max-line-length
          } else if (
            this.routeName === 'operations' &&
            this.params &&
            this.params.category === 'vulnerabilities' &&
            this.vulClientCat === 'Reported Vulnerabilities' &&
            this.tabConfig.stb === 'Client'
          ) {
            this.getThreatViewVulByOnlinereport(this.vulClientCat);
            //  tslint:disable-next-line: max-line-length
          } else if (
            this.routeName === 'executive' &&
            this.params &&
            this.params.category === 'vulnerabilities' &&
            this.vulClientCat === 'Asset Related Vulnerabilities' &&
            this.tabConfig.stb === 'Client'
          ) {
            if (this.vul_based_filter.isAssetComment) {
              this.getAllvulwithAssetcomment('Asset Related Vulnerabilities', this.assetCommets);
            } else {
              this.getThreatViewVulByOrgAsset(this.vulClientCat);
              //  tslint:disable-next-line: max-line-length
            }
          } else if (
            this.routeName === 'executive' &&
            this.params &&
            this.params.category === 'vulnerabilities' &&
            this.vulClientCat === 'Reported Vulnerabilities' &&
            this.tabConfig.stb === 'Client'
          ) {
            this.getThreatViewVulByOnlinereport(this.vulClientCat);
            //  tslint:disable-next-line: max-line-length
          } else if (
            this.routeName === 'management' &&
            this.params &&
            this.params.category === 'vulnerabilities' &&
            this.vulClientCat === 'Asset Related Vulnerabilities' &&
            this.tabConfig.stb === 'Client'
          ) {
            if (this.vul_based_filter.isAssetComment) {
              this.getAllvulwithAssetcomment('Asset Related Vulnerabilities', this.assetCommets);
            } else {
              this.getThreatViewVulByOrgAsset(this.vulClientCat);
              //  tslint:disable-next-line: max-line-length
            }
          } else if (
            this.routeName === 'management' &&
            this.params &&
            this.params.category === 'vulnerabilities' &&
            this.vulClientCat === 'Reported Vulnerabilities' &&
            this.tabConfig.stb === 'Client'
          ) {
            this.getThreatViewVulByOnlinereport(this.vulClientCat);
          } else if (
            (this.routeName === 'executive' || this.routeName === 'management' || this.routeName === 'operations') &&
            this.params &&
            this.params.category === 'vulnerabilities'
          ) {
            this.switchListTab(this.tabConfig.stb);
          } else if (this.routeName && this.routeName === 'ioc-drill') {
            this.loadManageAttackMethodIOCDrill();
          } else if (this.routeName && this.routeName === 'attack-method-drill') {
            this.loadAttackMethodDrillDownList();
          }

          //  else if (this.routeName === 'executive' && this.params && this.params.category === 'vulnerabilities' && this.tabConfig.stb === 'Client') {
          //    this.switchListTab(this.tabConfig.stb);
          //  } else if (this.routeName === 'executive' && this.params && this.params.category === 'vulnerabilities' && this.tabConfig.stb === 'Global') {
          //    this.switchListTab(this.tabConfig.stb);
          //  } else if (this.routeName === 'management' && this.params && this.params.category === 'vulnerabilities' && this.tabConfig.stb === 'Client') {
          //    this.switchListTab(this.tabConfig.stb);
          //  } else if (this.routeName === 'management' && this.params && this.params.category === 'vulnerabilities' && this.tabConfig.stb === 'Global') {
          //    this.switchListTab(this.tabConfig.stb);
          //  }
        }
      }
    });
  }

  ngOnInit() {
    window.scroll({
      top: 0,
      left: 0,
      behavior: 'smooth',
    });
    $('.container-fluid').animate(
      {
        scrollTop: 0,
      },
      100
    );
    //  this.router.events.subscribe((evt) => {
    //    if (!(evt instanceof NavigationEnd)) {
    //      return;
    //    }
    //    window.scrollTo(0, 0);
    //  });
    this.cpi = this.cpi ? this.cpi : 0; //  set current page index
    this.clientId = this.dcs.getChangedOrg() ? this.dcs.getChangedOrg() : this.dcs.getLoggedUser().orgId;
    this.pov = this.dcs.getCurrentClientInfo() && this.dcs.getCurrentClientInfo().pov ? this.dcs.getCurrentClientInfo().pov : null;
    if (this.pov && this.pov === 'TRIAL_POV') {
      this.size = 5;
    } else {
      this.size = 20;
    }
    if (this.params.category !== 'situational-awareness') {
      this.makeIntialCall();
      // this.getRansomeWareClient();
    }
    //this.switchDWOTab('Client');
  }

  makeIntialCall() {
    console.log(this.routeName, this.params);
    if (this.routeName === 'attack-surface') {
      this.switchSwf(this.sfwConfig.stb);
    } else if (this.routeName === 'attack-method-drill' && this.isAttackMethodDrill) {
      this.loadAttackMethodDrillDownList();
    } else if (this.routeName === 'executive' && this.params && this.params.category === 'situational-awareness') {
      this.getClientRelatedFilter('top-news-incident-and-attacks', this.params.category);
    } else if (
      this.routeName === 'management' &&
      this.params &&
      this.params.category === 'situational-awareness' &&
      this.params.type &&
      this.params.type === 'top-geography-industry-and-technology'
    ) {
      this.getClientRelatedFilter('top-geography-industry-and-technology', this.params.category);
      this.situationAwarenessCheck = 'top-geography-industry-and-technology';
      this.pType = 'top-geography-industry-and-technology';
    } else if (this.routeName === 'dark-web-drill' && this.isAttackMethodDrill) {
      this.loadClientDarkWebDrillDownList();
    } else if (this.params && this.params.category === 'vulnerabilities') {
      //  this.getClientVulnListByCategory('vulnerabilities', 'Top Vulnerabilities & Exploits');
      // this.checkVulnAssetWithComment();
      this.filterByFixedDate();
      // this.getClientVulnListByCategory('vulnerabilities', 'Asset Related Vulnerabilities');
      // this.getVulnSubCategory(this.vulClientSubCat);
    }

    //  tslint:disable-next-line:one-line
    else {
      if (this.params.category !== 'top-indicators-compromise') {
        this.filterByFixedDate();
        this.loadGITOptions();
      }
    }
  }
  //  load date on quick date selection
  filterByFixedDate() {
    //  this.dcs.setTotalRecords(0, 0, 0);
    if (this.filterOpt.date.defDV || this.filterOpt.date.defDV !== 0) {
      this.filterOpt.date.isDateRange = false;
      this.filterOpt.date.fd = this.dcs.getDayDiff(this.filterOpt.date.defDV);
      this.filterOpt.date.td = new Date();
      if (this.routeName && this.routeName === 'threat-view/whats-new') {
        this.loadThreatViewListByType();
      } else if (
        this.routeName &&
        (this.routeName === 'operations' ||
          this.routeName === 'management' ||
          this.routeName === 'executive' ||
          this.routeName === 'attack-methods')
      ) {
        if (this.params && this.params.category === 'latest-malicious-ip') {
          this.tabConfig.stb = 'Global';
          this.switchListTab(this.tabConfig.stb);
        } else if (
          this.params.category === 'vulnerabilities' &&
          this.vulClientCat === 'Asset Related Vulnerabilities' &&
          this.tabConfig.stb === 'Client'
        ) {
          this.getVulnSubCategory(this.vulClientSubCat);
          this.getClientVulnListByCategory(this.params.category, this.vulClientCat);
        } else if (
          this.params.category === 'vulnerabilities' &&
          this.vulClientCat === 'Reported Vulnerabilities' &&
          this.tabConfig.stb === 'Client'
        ) {
          this.getVulnSubCategory(this.vulClientSubCat);
          this.getClientVulnListByCategory(this.params.category, this.vulClientCat);
        } else if (this.pType === 'top-news-incident-and-attacks' && this.relatedCat === 'Related News') {
          this.getClientRelatedFilter(this.pType, this.relatedCat);
        } else if (this.pType === 'top-geography-industry-and-technology' && this.topGeoCat === 'Related News') {
          this.getTopGeoClientRelated(this.pType, this.topGeoCat);
        } else if (this.params.category === 'dark-web') {
          this.getClientDarkWebList(this.dwType);
        } else if (this.params.category === 'attack-surface') {
          //  this.getClientDarkWebList();
        } else if (this.params.category === 'digital-risk') {
          //  this.getClientDarkWebList();
        } else if (this.params.country) {
          this.loadAttackMethodManageDrill(this.params.country);
        }
        //  tslint:disable-next-line:one-line
        else {
          this.switchListTab(this.tabConfig.stb);
        }
        //  commented on 260321
        //   else if (this.params.category === 'vulnerabilities' && this.vulClientCat === 'Asset Related Vulnerabilities') {
        //    this.getClientVulnListByCategory(this.params.category, this.vulClientCat);
        //  } else if (this.params.category === 'vulnerabilities' && this.vulClientCat === 'Reported Vulnerabilities') {
        //    this.getClientVulnListByCategory(this.params.category, this.vulClientCat);
        //  }
      } else if (this.routeName && this.routeName === 'ioc-drill') {
        this.loadManageAttackMethodIOCDrill();
      }
    } else {
      this.filterOpt.date.isDateRange = true;
    }
  }
  selectDate(type: string, event: MatDatepickerInputEvent<Date>, action?: string) {
    const date = new Date(event.value ?? new Date());
    if (type === 'fromDate') {
      this.filterOpt.date.fd = date;
      this.filterOpt.date.minDate = this.dcs.minDate(date);
    }
    if (type === 'toDate') {
      this.dcs.setTotalRecords(0, 0, 0);
      this.filterOpt.date.td = date;
      if (this.filterOpt.date.td) {
        if (
          this.params.category === 'vulnerabilities' &&
          this.tabConfig.stb === 'Client' &&
          this.vulClientCat === 'Asset Related Vulnerabilities'
        ) {
          this.getClientVulnListByCategory(this.params.category, this.vulClientCat);
        } else if (this.params.category === 'vulnerabilities' && this.vulClientCat === 'Reported Vulnerabilities') {
          this.getClientVulnListByCategory(this.params.category, this.vulClientCat);
        } else if (this.pType === 'top-news-incident-and-attacks' && this.relatedCat === 'Related News') {
          this.getClientRelatedFilter(this.pType, this.relatedCat);
        } else if (this.pType === 'top-geography-industry-and-technology' && this.topGeoCat === 'Related News') {
          this.getTopGeoClientRelated(this.pType, this.topGeoCat);
        } else {
          this.switchListTab(this.tabConfig.stb);
        }
      }
    }
  }

  filterByClientFilter(type: string) {
    if (type && type === 'selection') {
      if (this.clientFilterOpt.sopt !== 'Risk Rating') {
        //  get client configured GIT info
        const pageReq: any = {
          page: 0,
          size: 10,
          sort: ['id,ASC'],
        };
        this.orgDetailsService.read('All', this.clientId, pageReq).subscribe(
          (res: HttpResponse<any[]>) => {
            const orgAssets = res.body;
            if (orgAssets?.length) {
              if (this.clientFilterOpt.sopt === 'Geography') {
                this.clientFilterOpt.git = orgAssets.filter(_od => _od.key === 'Geography');
              } else if (this.clientFilterOpt.sopt === 'Industry') {
                this.clientFilterOpt.git = orgAssets.filter(_od => _od.key === 'Industry');
              } else if (this.clientFilterOpt.sopt === 'Technology') {
                this.clientFilterOpt.git = orgAssets.filter(_od => _od.key === 'Technology');
              }
            } else {
              this.clientFilterOpt.geo = [];
              this.clientFilterOpt.ind = [];
              this.clientFilterOpt.tech = [];
            }
          },
          error => this.onError(error)
        );
      }
    } else if (type && type === 'filter') {
      // console.log(this.clientFilterOpt.fsd);
      if (this.params.category === 'top-news-incident-and-attacks' || this.params.category === 'top-geography-industry-and-technology') {
        // console.log(this.clientFilterOpt.sopt);
        const listReqObj = {
          type: this.pType,
          fd: this.filterOpt.date.fd,
          td: this.filterOpt.date.td,
          clientId: 0,
          size: this.size,
          geo: this.clientFilterOpt.sopt === 'Geography' ? this.clientFilterOpt.fsd : null,
          ind: this.clientFilterOpt.sopt === 'Industry' ? this.clientFilterOpt.fsd : null,
          tech: this.clientFilterOpt.sopt === 'Technology' ? this.clientFilterOpt.fsd : null,
          riskScore: this.clientFilterOpt.sopt === 'Risk Score' ? this.clientFilterOpt.fsd : null,
        };
        this.dcs.setAjexStatus(true);
        //  tslint:disable-next-line: max-line-length
        this.ctds
          .getThreatViewByCategory(
            listReqObj.type,
            listReqObj.clientId,
            listReqObj.fd.getTime(),
            listReqObj.td.getTime(),
            null,
            this.vulnPrdSearch,
            null,
            listReqObj
          )
          ?.subscribe(
            (response: HttpResponse<any[]>) => {
              this.dcs.setAjexStatus(false);
              this.topListData = response.body ? response.body : [];
            },
            (error: HttpErrorResponse) => this.onError(error)
          );
      }
    }
  }
  //  switch to list tab change
  switchListTab(tab: string) {
    this.tabConfig.stb = tab;
    sessionStorage.setItem('dwType', tab);
    if (this.pType === 'vulnerabilities') {
      this.pType = 'top-vulnerability-and-exploit';
      this.vul_based_filter.isAssetComment = false;
      this.assetCommets = '';
    }
    if (this.pType === 'digital-risk') {
      this.pType = 'top-digital-risk';
    }
    if (this.pType === 'situational-awareness') {
      this.pType = this.dcs.getSituationalAwarenessType() ? this.dcs.getSituationalAwarenessType() : 'top-news-incident-and-attacks';
      //  this.pType = 'top-news-incident-and-attacks';
      this.situationAwarenessCheck = this.pType;
    }
    if (this.pType === 'top-news-incident-and-attacks') {
      this.pType = 'top-news-incident-and-attacks';
      //  this.pType = 'top-news-incident-and-attacks';
    } else {
      this.pType === 'top-geography-industry-and-technology';
      /* this.pType == 'top-geography-industry-and-technology';*/
    }

    //  if(this.params.category =="situational-awareness")
    if (this.routeName === 'attack-methods') {
      if (this.pType === 'Phishing') {
        this.pType = 'top-phishing';
      }
      if (this.pType === 'Malware') {
        this.pType = 'top-malware';
      }
      if (this.pType === 'Campaign') {
        this.pType = 'top-campaigns';
      }
    }
    const listReqObj = {
      type: this.pType,
      fd: this.filterOpt.date.fd,
      td: this.filterOpt.date.td,
      clientId: this.clientId,
      size: this.size,
      page: this.cpi,
    };
    if (!this.vulnPrdSearch) {
      this.vulnPrdSearch = '';
    }
    if (!this.impact) {
      this.impact = '';
    }
    this.topListData = [];
    const pagerReq = {
      page: this.cpi,
      size: this.size,
    };
    switch (tab) {
      case 'Client':
        this.searchCampaign = '';
        this.impactList = [];
        this.clientId = this.dcs.getChangedOrg() ? this.dcs.getChangedOrg() : this.dcs.getLoggedUser().orgId;
        if (this.params.category === 'vulnerabilities') {
          //   this.vulClientCat = 'Top Vulnerabilities & Exploits';  //  modified on 260321
          this.vulClientCat = 'Asset Related Vulnerabilities';
          this.getThreatViewVulByOrgAsset(this.vulClientCat);
        } else if (this.params.category !== 'attack-surface') {
          this.impactList = [];
          this.relatedCat = 'Top News';
          this.topGeoCat = 'Top News';
          if (pagerReq.page !== 0) {
            pagerReq.page = pagerReq.page - 1;
          }
          this.dcs.setAjexStatus(true);
          this.filterClientCat = 'Industry';
          // tslint:disable-next-line: max-line-length
          this.ctds
            .getThreatViewByCategory(
              listReqObj.type,
              listReqObj.clientId,
              listReqObj.fd.getTime(),
              listReqObj.td.getTime(),
              null,
              this.vulnPrdSearch,
              this.impact,
              pagerReq,
              null,
              this.isDateSort,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              '',
              false,
              false,
              '',
              true
            )
            ?.subscribe(
              (response: HttpResponse<any[]>) => {
                this.dcs.setAjexStatus(false);
                this.topListData = response.body ? response.body : [];
                this.filterAttackMethodByCategory();
                let totalItems: any;
                if (this.pType === 'top-malware') {
                  totalItems = this.topListData.length;
                } else {
                  totalItems = response.headers.get('X-Total-Count');
                }
                this.dcs.setTotalRecords(totalItems, this.topListData.length, 50);
                this.setBlurRecords('campaigncltable');
                this.setBlurRecords('malwareclnTable');
                this.setBlurRecords('phishingclntable');
              },
              (error: HttpErrorResponse) => this.onError(error)
            );
        }
        break;
      case 'Global':
        this.searchCampaign = '';
        //  this.vulClientCat = 'Top Vulnerabilities & Exploits';  //  modified on 260321
        this.vulClientCat = 'Asset Related Vulnerabilities';
        listReqObj.clientId = 0;
        this.clientId = 0;
        if (pagerReq.page !== 0) {
          pagerReq.page = pagerReq.page - 1;
        }
        if (this.pType === 'top-campaigns') {
          this.dcs.setAjexStatus(true);
          //  tslint:disable-next-line:max-line-length
          this.ctds
            .getThreatViewByCategory(
              listReqObj.type,
              listReqObj.clientId,
              listReqObj.fd.getTime(),
              listReqObj.td.getTime(),
              null,
              null,
              null,
              pagerReq,
              null,
              this.isDateSort
            )
            ?.subscribe(
              (response: HttpResponse<any[]>) => {
                this.dcs.setAjexStatus(false);
                this.topListData = response.body;
                // let totalItems: any;
                const totalItems: any = response.headers.get('X-Total-Count');
                this.dcs.setTotalRecords(totalItems, this.topListData.length, pagerReq.size);
                this.setBlurRecords('campaignTable');
              },
              (error: HttpErrorResponse) => this.onError(error)
            );
        } else if (this.pType === 'top-phishing') {
          if (this.isImpactSelected) {
            pagerReq.page = 0;
            this.resetAll();
          }
          if (this.pType !== 'top-phishing') {
            this.impactList = [];
          }

          if (this.impactList.includes('LOW')) {
            this.isLow = true;
          } else {
            this.isLow = false;
          }
          if (this.impactList.includes('MEDIUM')) {
            this.isMedium = true;
          } else {
            this.isMedium = false;
          }
          if (this.impactList.includes('HIGH')) {
            this.isHigh = true;
          } else {
            this.isHigh = false;
          }
          if (this.impactList.includes('CRITICAL')) {
            this.isCritical = true;
          } else {
            this.isCritical = false;
          }
          this.dcs.setAjexStatus(true);
          //  tslint:disable-next-line:max-line-length
          this.ctds
            .getThreatViewByCategory(
              listReqObj.type,
              listReqObj.clientId,
              listReqObj.fd.getTime(),
              listReqObj.td.getTime(),
              null,
              null,
              null,
              pagerReq,
              false,
              null,
              this.isLow,
              this.isMedium,
              this.isHigh,
              this.isCritical
            )
            ?.subscribe(
              (response: HttpResponse<any[]>) => {
                this.dcs.setAjexStatus(false);
                this.topListData = response.body;
                let totalItems: any;
                if (this.topListData.length === 0) {
                  totalItems = response.headers.get('0');
                } else {
                  totalItems = response.headers.get('X-Total-Count');
                }
                this.dcs.setTotalRecords(totalItems, this.topListData.length, pagerReq.size);
                this.isImpactSelected = false;
                this.setBlurRecords('PhishinTable');
              },
              (error: HttpErrorResponse) => this.onError(error)
            );
        } else if (this.pType === 'top-malware') {
          if (this.isImpactSelected) {
            pagerReq.page = 0;
            this.resetAll();
          }
          if (this.pType !== 'top-malware') {
            this.impactList = [];
          }
          if (this.impactList.includes('LOW')) {
            this.isLow = true;
          } else {
            this.isLow = false;
          }
          if (this.impactList.includes('MEDIUM')) {
            this.isMedium = true;
          } else {
            this.isMedium = false;
          }
          if (this.impactList.includes('HIGH')) {
            this.isHigh = true;
          } else {
            this.isHigh = false;
          }
          if (this.impactList.includes('CRITICAL')) {
            this.isCritical = true;
          } else {
            this.isCritical = false;
          }
          this.dcs.setAjexStatus(true);
          //  tslint:disable-next-line:max-line-length
          this.ctds
            .getThreatViewByCategory(
              listReqObj.type,
              listReqObj.clientId,
              listReqObj.fd.getTime(),
              listReqObj.td.getTime(),
              null,
              null,
              null,
              pagerReq,
              false,
              this.isDateSort,
              this.isLow,
              this.isMedium,
              this.isHigh,
              this.isCritical
            )
            ?.subscribe(
              (response: HttpResponse<any[]>) => {
                this.dcs.setAjexStatus(false);
                this.topListData = response.body;
                let totalItems: any;
                if (this.topListData.length === 0) {
                  totalItems = response.headers.get('0');
                } else {
                  totalItems = response.headers.get('X-Total-Count');
                }
                this.dcs.setTotalRecords(totalItems, this.topListData.length, pagerReq.size);
                this.isImpactSelected = false;
                this.setBlurRecords('malwareTable');
              },
              (error: HttpErrorResponse) => this.onError(error)
            );
        } else if (this.pType === 'latest-malicious-ip') {
          let country = '';
          if (this.selectedCountry) {
            country = this.selectedCountry;
          }
          this.dcs.setAjexStatus(true);
          //  tslint:disable-next-line:max-line-length
          this.ctds
            .getThreatViewByCategoryForIp(
              listReqObj.type,
              listReqObj.clientId,
              listReqObj.fd.getTime(),
              listReqObj.td.getTime(),
              country,
              pagerReq
            )
            ?.subscribe(
              (response: HttpResponse<any[]>) => {
                this.dcs.setAjexStatus(false);
                this.topListData = response.body;
                // let totalItems: any;
                const totalItems: any = response.headers.get('X-Total-Count');
                this.dcs.setTotalRecords(totalItems, this.topListData.length, pagerReq.size);
              },
              (error: HttpErrorResponse) => this.onError(error)
            );
        } else if (this.pType === 'vulnerabilities' || this.pType === 'top-vulnerability-and-exploit') {
          const category = this.sveCat.toUpperCase();
          if (this.sveCat === 'Cloud Vulnerabilities') {
            this.dcs.setAjexStatus(true);
            this.opencvdbService.query({ ...pagerReq, sort: this.openCVDB_sort }).subscribe(
              response => {
                this.dcs.setAjexStatus(false);
                this.topListData = response.body;
                this.topListData.forEach((element: any) => {
                  if (element.affectedServices !== null) {
                    if (typeof element.affectedServices === 'string') {
                      element.affectedServices = element.affectedServices.split(',');
                    }
                  }
                  if (element.cves !== null) {
                    if (typeof element.cves === 'string') {
                      element.cves = element.cves.split(',');
                    }
                  }
                  if (element.references !== null) {
                    if (typeof element.references === 'string') {
                      element.references = element.references.split(',');
                    }
                  }
                });
                const totalItems: any = response.headers.get('X-Total-Count');
                this.setBlurRecords('vulgbTable1');
                this.dcs.setTotalRecords(totalItems, this.topListData.length, pagerReq.size);
              },
              (error: HttpErrorResponse) => this.onError(error)
            );
          } else {
            this.dcs.setAjexStatus(true);
            //  tslint:disable-next-line:max-line-length
            this.ctds
              .getThreatViewByCategory(
                listReqObj.type,
                listReqObj.clientId,
                listReqObj.fd.getTime(),
                listReqObj.td.getTime(),
                category,
                this.vulnPrdSearch,
                this.impact,
                pagerReq,
                null,
                this.isDateSort,
                null!,
                null!,
                null!,
                null!,
                false,
                false,
                false
              )
              ?.subscribe(
                (response: HttpResponse<any[]>) => {
                  this.dcs.setAjexStatus(false);
                  this.topListData = response.body;
                  const totalItems: any = response.headers.get('X-Total-Count');
                  this.setBlurRecords('vulgbTable');
                  this.dcs.setTotalRecords(totalItems, this.topListData.length, pagerReq.size);
                },
                (error: HttpErrorResponse) => this.onError(error)
              );
          }
        } else if (this.pType === 'digital-risk') {
          //
        } else if (this.pType === 'top-news-incident-and-attacks') {
          if (this.impactList.includes('LOW')) {
            this.isLow = true;
          } else {
            this.isLow = false;
          }
          if (this.impactList.includes('MEDIUM')) {
            this.isMedium = true;
          } else {
            this.isMedium = false;
          }
          if (this.impactList.includes('HIGH')) {
            this.isHigh = true;
          } else {
            this.isHigh = false;
          }
          if (this.impactList.includes('CRITICAL')) {
            this.isCritical = true;
          } else {
            this.isCritical = false;
          }
          if (!this.topCyberSearch) {
            this.topCyberSearch = '';
          }
          const category = this.niaCat.toUpperCase();
          const fromDatelocal = new Date(listReqObj.fd);
          const toDatelocal = new Date(listReqObj.td);

          const currentDate = new Date();
          toDatelocal.setDate(toDatelocal.getDate() + 1);
          if (currentDate.getTime() === toDatelocal.getTime()) {
            toDatelocal.setDate(toDatelocal.getDate() - 1);
          }
          this.dcs.setAjexStatus(true);
          //  tslint:disable-next-line:max-line-length
          this.ctds
            .getThreatViewByCategory(
              listReqObj.type,
              listReqObj.clientId,
              fromDatelocal.getTime(),
              toDatelocal.getTime(),
              category,
              null,
              null,
              pagerReq,
              false,
              this.isDateSort,
              this.isLow,
              this.isMedium,
              this.isHigh,
              this.isCritical,
              null!,
              null!,
              null!,
              this.topCyberSearch
            )
            ?.subscribe(
              (response: HttpResponse<any[]>) => {
                this.dcs.setAjexStatus(false);
                this.topListData = response.body;
                const totalItems: any = response.headers.get('X-Total-Count');
                this.dcs.setTotalRecords(totalItems, this.topListData.length, pagerReq.size);
              },
              (error: HttpErrorResponse) => this.onError(error)
            );
        }
        break;
      case 'Top':
        break;
      case 'dw-observation':
        this.switchDWOTab('Client');
        this.getDWSelectedTab(tab);
        break;
      case 'ransomeware':
        this.ransomwareMonitoringEnabled = this.isAnalyst;
        // if (!this.isAnalyst) {
        //   // this.ransomwareMonitoringEnabled = false;
        //   this.switchTab('Global');
        // } else {
        //   this.switchTab('Client');
        // }
        this.switchTab('Client');
        this.getDWSelectedTab(tab);
        break;
      case 'ransomewareClient':
        this.dwTabName = 'ransomeware';
        this.isRansomware = true;
        this.ransomeListDropDown = '';
        this.getRansomeWareClient();
        break;
      default:
        //  call for client
        break;
    }
  }
  switchDWOTab(tab: string) {
    this.dwTab = tab;
    this.dcs.resetPagerInfo();
    this.cpi = 1;
    this.getClientDarkWebList('dw-observation');
  }
  setBlurRecords(type: any) {
    if (this.pov === 'TRIAL_POV') {
      setTimeout(() => {
        const domarray = document.querySelector('#' + type);
        // const selectedrow = ;
        for (let blurdata = 3; blurdata < 5; blurdata++) {
          domarray?.getElementsByTagName('tr')[blurdata].classList.add('blur');
          // const clonedData = selectedrow.cloneNode(true);
          // domarray.appendChild(clonedData);
        }
        //                 const tag = document.createElement('p');
        //                 const text = document.createTextNode(
        //                     'Unlock this section? Please upgrade the subscription'
        //                 );
        //                 tag.classList.add('unlockpara');

        //                 tag.style.cssText = `
        //             position: absolute;
        //             top: 110px;
        //             left: 40%;
        //             background: #fff;
        //             padding: 10px 20px;
        //             color: #002c63;
        //             font-weight: bolder;
        //             border: 1px solid #ccc;
        // `;
        //                 tag.appendChild(text);
        //                 tag.addEventListener('click', this.upgradeAccount);
        // tslint:disable-next-line: max-line-length
        const tags =
          "<div class='sestionnotification' style='display: flex; width: 450px;    border: 2px solid #ea6e65;    border-radius: 15px; padding: 9px 8px;vertical-align: middle;   text-align: center;    background: #fff;    position: absolute;    margin: 0 0 10px 0;    align-items: center;top: 170px;left: 35%'> <i class='fa fa-rocket' style='  background: #F9E4E1;   height: 60px;width: 60px;    font-size: 20px;    border: 10px solid #fdf3f2;    text-align: center;    padding: 10px;border-radius: 50%;    color: #d92d2a;'></i> <div class='textcontent' style='padding: 0 0 0 20px;text-align: left;'><p class='subscriptionMessage' style='margin: 0;    padding: 0;    font-size: 15px;'>You are currently subscribed to a Trial Package</p> <p class='subtext' style='font-size: 13px;    color: #888;'>To see more data please upgrade to paid package</p> </div><div class='closebtn'>  </div></div>";

        domarray?.insertAdjacentHTML('beforeend', tags);
      }, 1000);
    }
  }

  switchTab(tab: string) {
    this.ransomwareTab = tab;
    this.ransomeListData = [];
    this.ransomeListClientData = [];
    this.dcs.resetPagerInfo();
    this.cpi = 0;
    if (tab === 'Client') {
      this.searchToggle = false;
      this.dwTabName = 'ransomeware';
      this.isRansomware = true;
      this.getRansomeWareClient();
      this.loadClientGITData();
    } else {
      this.dwTabName = 'ransomeware';
      this.isRansomware = true;
      this.ransomeListDropDown = '';
      this.searchToggle = true;
      this.getRansomewareDropdownList();
      this.getRansomeListData();
    }
  }
  getRansomeWare() {
    this.cpi = 0;
    const pagerReq = {
      page: this.cpi,
      size: this.size,
    };
    if (pagerReq.page !== 0) {
      pagerReq.page = pagerReq.page - 1;
    }

    this.dcs.setAjexStatus(true);
    //  tslint:disable-next-line:max-line-length
    this.ctds
      .getRansomeListWithsearch(this.searchRansome ? this.searchRansome : '', this.isRansomware, this.ransomeListDropDown, pagerReq)
      .subscribe(
        (response: HttpResponse<any[]>) => {
          this.dcs.setAjexStatus(false);
          this.ransomeListData = response.body!;
          const totalItems: any = response.headers.get('X-Total-Count');
          this.dcs.setTotalRecords(totalItems, this.ransomeListData.length, pagerReq.size);
        },
        (error: HttpErrorResponse) => this.onError(error)
      );
  }
  getRansomewareDropdownList(): void {
    this.ctds.getRansomeDropDownList(this.isRansomware, { page: 0, size: 100 }).subscribe(
      (response: HttpResponse<any[]>) => {
        this.dcs.setAjexStatus(false);
        this.ransomeList = response.body;
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }
  getRansomeListData() {
    const pagerReq = {
      page: this.cpi > 0 ? this.cpi - 1 : this.cpi,
      size: this.size,
    };
    this.dcs.setAjexStatus(true);
    //  tslint:disable-next-line:max-line-length
    this.ctds.getRansomeList(this.isRansomware, this.ransomeListDropDown, pagerReq).subscribe(
      (response: HttpResponse<any[]>) => {
        this.dcs.setAjexStatus(false);
        this.ransomeListData = response.body!;
        const totalItems: any = response.headers.get('X-Total-Count');
        this.dcs.setTotalRecords(totalItems, this.ransomeListData.length, pagerReq.size);
        this.setBlurRecords('ransomgbtable');
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }
  campaignExportCsv() {
    this.dcs.setAjexStatus(true);
    const orgId = this.tabConfig.stb === 'Client' ? this.clientId : 0;
    this.ctds.topCampaignExport(orgId).subscribe(
      res => {
        this.dcs.setAjexStatus(false);
        const response: any = res;
        const blob = new Blob([response], { type: '*' });
        saveAs(blob, 'top_campaigns.csv');
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }
  ransomwareExportCsv() {
    this.dcs.setAjexStatus(true);
    const orgId = this.tabConfig.stb === 'Client' ? this.clientId : 0;
    this.ctds.downloadRansomeware(0, this.searchRansome ? this.searchRansome : '', true, this.ransomeListDropDown).subscribe(
      res => {
        this.dcs.setAjexStatus(false);
        const response: any = res;
        const blob = new Blob([response], { type: '*' });
        saveAs(blob, 'ransomware.csv');
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }
  ransomwareClientExportCsv() {
    const pagerReq = {
      page: this.cpi - 1,
      size: this.size,
    };
    this.dcs.setAjexStatus(true);
    const orgId = this.clientId;
    if (orgId === 0) {
      alert('Select Client First');
      return;
    }
    this.ctds.downloadRansomewareClient(orgId, pagerReq).subscribe(
      res => {
        this.dcs.setAjexStatus(false);
        const response: any = res;
        const blob = new Blob([response], { type: '*' });
        saveAs(blob, 'ransomwareClient.csv');
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }

  phishingExportCsv() {
    if (this.impactList.includes('LOW')) {
      this.isLow = true;
    } else {
      this.isLow = false;
    }
    if (this.impactList.includes('MEDIUM')) {
      this.isMedium = true;
    } else {
      this.isMedium = false;
    }
    if (this.impactList.includes('HIGH')) {
      this.isHigh = true;
    } else {
      this.isHigh = false;
    }
    if (this.impactList.includes('CRITICAL')) {
      this.isCritical = true;
    } else {
      this.isCritical = false;
    }
    const listReqObj = {
      fd: this.filterOpt.date.fd,
      td: this.filterOpt.date.td,
      clientId: this.clientId,
    };
    this.dcs.setAjexStatus(true);
    const orgId = this.tabConfig.stb === 'Client' ? this.clientId : 0;
    this.ctds.topPhishingExport(orgId, this.isLow, this.isMedium, this.isHigh, this.isCritical, listReqObj.fd.getTime(),listReqObj.td.getTime(),).subscribe(
      res => {
        this.dcs.setAjexStatus(false);
        const response: any = res;
        const blob = new Blob([response], { type: '*' });
        saveAs(blob, 'top_phishing.csv');
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }
  phishingGlobalExportCsv(){
      if (this.impactList.includes('LOW')) {
        this.isLow = true;
      } else {
        this.isLow = false;
      }
      if (this.impactList.includes('MEDIUM')) {
        this.isMedium = true;
      } else {
        this.isMedium = false;
      }
      if (this.impactList.includes('HIGH')) {
        this.isHigh = true;
      } else {
        this.isHigh = false;
      }
      if (this.impactList.includes('CRITICAL')) {
        this.isCritical = true;
      } else {
        this.isCritical = false;
      }
      const listReqObj = {
        fd: this.filterOpt.date.fd,
        td: this.filterOpt.date.td,
        clientId: this.clientId,
      };
      this.dcs.setAjexStatus(true);
      const orgId = this.tabConfig.stb === 'Client' ? this.clientId : 0;
      this.ctds.globalTopPhishingExport(orgId, this.isLow, this.isMedium, this.isHigh, this.isCritical, listReqObj.fd.getTime(),listReqObj.td.getTime(),).subscribe(
        res => {
          this.dcs.setAjexStatus(false);
          const response: any = res;
          const blob = new Blob([response], { type: '*' });
          saveAs(blob, 'top_phishing.csv');
        },
        (error: HttpErrorResponse) => this.onError(error)
      );

  }

  malwareExportCsv() {
    if (this.impactList.includes('LOW')) {
      this.isLow = true;
    } else {
      this.isLow = false;
    }
    if (this.impactList.includes('MEDIUM')) {
      this.isMedium = true;
    } else {
      this.isMedium = false;
    }
    if (this.impactList.includes('HIGH')) {
      this.isHigh = true;
    } else {
      this.isHigh = false;
    }
    if (this.impactList.includes('CRITICAL')) {
      this.isCritical = true;
    } else {
      this.isCritical = false;
    }
    this.dcs.setAjexStatus(true);
    const orgId = this.tabConfig.stb === 'Client' ? this.clientId : 0;
    this.ctds.topmalwareExport(orgId, this.isLow, this.isMedium, this.isHigh, this.isCritical).subscribe(
      res => {
        this.dcs.setAjexStatus(false);
        const response: any = res;
        const blob = new Blob([response], { type: '*' });
        saveAs(blob, 'top_malware.csv');
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }

  //  switch to attack surface web tab change
  getDarkWebRecords(category: string) {
    this.dcs.resetPagerInfo();
    this.cpi = 1;
    if(category === 'early-warnings'){
      this.dwType = 'early-warnings'
    }
    this.getClientDarkWebList(category);
    this.getDWSelectedTab(category);
    sessionStorage.setItem('dwType', category);
  }

  getClientDarkWebList(category: string) {
    if (category === 'early-warnings') {
      this.dwTabName = category;
      const pageReq = {
        page: this.cpi - 1,
        size: this.size,
        sort: ['id,DESC'],
      };
      const eReq = {
        rType: 'Early Warnings',
        pSize: this.size,
        orgId: this.clientId,
      };
      this.dcs.setAjexStatus(true);
      this.ctds.getWeeklyEWReportsList(pageReq, eReq, this.safeEnable).subscribe(
        (response: HttpResponse<any[]>) => {
          this.dcs.setAjexStatus(false);
          this.topListData = response.body;
          const totalItems: any = response.headers.get('X-Total-Count');
          this.dcs.setTotalRecords(totalItems, response.body!.length, 20);
          this.setBlurRecords('earlywartable');
          setTimeout(() => this.dcs.setAjexStatus(false), 200);
        },
        (error: HttpErrorResponse) => this.onError(error)
      );
    } else if (category === 'dw-observation') {
      this.dwTabName = category;
      this.dwobservationData = [];
      if (this.dwTab === 'Global') {
        this.selectedTab = this.dwTab;
        const pageReq = {
          page: this.cpi - 1,
          size: this.size,
          sort: ['date,DESC'],
        };
        this.dcs.setAjexStatus(true);
        this.darkWebService.getDarkwebList({ orgId: 0, from: 0, to: 0 }, pageReq).subscribe(
          (res: HttpResponse<any[]>) => {
            this.dcs.setAjexStatus(false);
            const totalItems = Number(res.headers.get('X-Total-Count'));
            this.dcs.setTotalRecords(totalItems, res.body!.length, 20);
            this.setBlurRecords('dwobgbtable');
            this.dwobservationData = res.body;
          },
          (res: HttpErrorResponse) => this.onError(res)
        );
      } else {
        this.selectedTab = this.dwTab;
        const pageReq = {
          page: this.cpi - 1,
          size: this.size,
          sort: ['master_created_at,DESC'],
        };
        this.dcs.setAjexStatus(true);
        this.clientIncidentService.findBySource(pageReq, this.clientId, 'darkweb', this.safeEnable).subscribe(
          (response: HttpResponse<any[]>) => {
            this.dcs.setAjexStatus(false);
            this.dwobservationData = response.body;
            const totalItems: any = response.headers.get('X-Total-Count');
            this.dcs.setTotalRecords(totalItems, response.body!.length, 20);
            this.setBlurRecords('dwobclntable');
          },
          (error: HttpErrorResponse) => this.onError(error)
        );
      }
    } else if (category === 'ransomeware') {
      this.isRansomware = true;
      this.dwTabName = category;
      if (this.searchRansome) {
        this.searchByTitleRansome();
      } else {
        if (this.ransomwareTab === 'Client') {
          this.getRansomeWareClient();
          // this.loadClientGITData();
        } else {
          this.getRansomeListData();
        }
      }
    }
  }
  onFilterChange(category: string){
    if(category === 'early-warnings'){
      this.getClientDarkWebList('early-warnings');
    }else{
      this.getClientDarkWebList('dw-observation');
    } 
  }
  openDWDialog(_ld: any, opt?: string) {
    this.dcs.setAjexStatus(true);
    _ld.type = 'Dark Web Observation';
    this.darkWebService.find(_ld.id).subscribe(
      (res: HttpResponse<any>) => {
        this.dcs.setAjexStatus(false);
        this.clientIncident = res.body;
        this.dialog.open(ClientIncidentComponent, {
          width: this.dialogConfig.dWidth,
          height: 'auto',
          maxWidth: this.dialogConfig.maxWidth,
          disableClose: true,
          data: { action: _ld.type, label: _ld.type, data: { ...this.clientIncident, type: 'Dark Web Observation' } },
          panelClass: 'slide-ltr',
        });
      },
      (res: HttpErrorResponse) => this.onError(res)
    );
  }

  openDigialRiskDialog(_ld: any, opt?: string) {
    this.dcs.setAjexStatus(true);
    this.clientIncidentService.find(_ld.id).subscribe(
      (res: HttpResponse<ClientIncident>) => {
        this.dcs.setAjexStatus(false);
        this.clientIncident = res.body;
        this.dialog.open(ClientIncidentComponent, {
          width: this.dialogConfig.dWidth,
          height: 'auto',
          maxWidth: this.dialogConfig.maxWidth,
          disableClose: true,
          data: { action: _ld.type, label: _ld.type, data: { ...this.clientIncident, type: 'Dark Web Observation' } },
          panelClass: 'slide-ltr',
        });
      },
      (res: HttpErrorResponse) => this.onError(res)
    );
  }

  //  loading darkweb
  switchSwf(tab: string) {
    this.sfwConfig.stb = tab;
    switch (tab.toLowerCase()) {
      case 'software & services':
        this.dcs.setAjexStatus(true);
        this.ctds.getSfwAndServices(this.clientId).subscribe(
          (res: HttpResponse<any[]>) => {
            this.dcs.setAjexStatus(false);
            this.sfwConfig.data = res.body;
          },
          (error: HttpErrorResponse) => this.onError(error)
        );
        break;
      case 'cookies':
        break;
      case 'url forms':
        break;
      default:
        console.log(tab);
    }
  }
  //  load threat view list by selected type
  loadThreatViewListByType() {
    //  this.dcs.setAjexStatus(true);
    this.wncat = [];
    const dateReq = {
      fd: this.filterOpt.date.fd.getTime(),
      td: this.filterOpt.date.td.getTime(),
    };
    this.ctds.getThreatViewByCategory('whats-new', this.clientId, dateReq.fd, dateReq.td)?.subscribe(
      (response: HttpResponse<any[]>) => {
        this.dcs.setAjexStatus(false);
        this.whatsNew = _wnGroupByCat(response.body!);
        if (this.params.category === 'digital risk') {
          this.wncat = this.whatsNew['DIGITAL RISK'] ? this.whatsNew['DIGITAL RISK'] : [];
        } else if (this.params.category === 'vulnerability and exploit') {
          this.wncat = this.whatsNew['VULNERABILITY AND EXPLOIT'] ? this.whatsNew['VULNERABILITY AND EXPLOIT'] : [];
        } else if (this.params.category === 'phishing and malware') {
          this.wncat = this.whatsNew['PHISHING AND MALWARE'] ? this.whatsNew['PHISHING AND MALWARE'] : [];
        } else if (this.params.category === 'hacker interest') {
          this.wncat = this.whatsNew['HACKER INTEREST'] ? this.whatsNew['HACKER INTEREST'] : [];
        } else if (this.params.category === 'earlywarning or out of band') {
          this.wncat = this.whatsNew['EARLY WARNING OR OUT OF BAND'] ? this.whatsNew['EARLY WARNING OR OUT OF BAND'] : [];
        } else if (this.params.category === 'incident news and attack') {
          this.wncat = this.whatsNew['CYBERATTACKS'] ? this.whatsNew['CYBERATTACKS'] : [];
        }
      },
      (error: HttpErrorResponse) => this.onError(error)
    );

    //  whats new group by category
    function _wnGroupByCat(data: any[]): Record<string, unknown> {
      const _gd: any = {};
      if (data?.length) {
        data.forEach(_d => {
          if (_gd?.[_d.type]) {
            _gd[_d.type].push(_d);
          } else {
            _gd[_d.type] = [_d];
          }
        });
        return _gd;
      } else {
        return _gd;
      }
    }
  }
  //  get data for category changed
  getListByCategory(type: string, cat: string) {
    this.resetAll();
    this.dateVisibility();
    this.pType = type;
    if (type === 'vulnerabilities') {
      // Commenting below code for resolving issue CF-1534.
      // The date dropdown value was getting changed on changing vulnerability type.
      // if (this.sveCat !== 'Vulnerability') {
      //   this.resetDefDate();
      // }
      this.sveCat = cat;
    } else if (this.pType === 'top-news-incident-and-attacks') {
      if (cat === 'News' && this.tabConfig.stb! === 'Client') {
        this.resetDefDate();
      } else if (cat === 'Attack') {
        this.resetDefDate();
      }
      this.niaCat = cat;
    }
    this.switchListTab(this.tabConfig.stb);
  }
  //  get top-incident category
  getClientRelatedFilter(type: string, cat: string) {
    if (this.relatedCat !== 'Related News') {
      this.resetDefDate();
      this.resetAll();
      this.impactList = [];
    }
    if (!this.filterOpt.date && !this.filterOpt.date.td) {
      this.resetDefDate();
      this.resetAll();
    }
    this.pType = type;
    //  if (this.pType === 'situational-awareness') {
    //    this.pType = 'top-news-incident-and-attacks';
    //  }
    const fromDatelocal = new Date(this.filterOpt.date.fd);
    const toDatelocal = new Date(this.filterOpt.date.td);
    const currentDate = new Date();
    toDatelocal.setDate(toDatelocal.getDate() + 1);
    if (currentDate.getTime() === toDatelocal.getTime()) {
      toDatelocal.setDate(toDatelocal.getDate() - 1);
    }
    if (!this.topCyberSearch) {
      this.topCyberSearch = '';
    }

    const listReqObj = {
      type: this.pType,
      fd: fromDatelocal,
      td: toDatelocal,
      clientId: this.clientId,
    };
    const pagerReq = {
      page: this.cpi,
      size: this.size === 5 ? 5 : 200,
    };
    //  if (this.relatedCat !== 'Related News' && this.tabConfig.stb !== 'Client') {
    //    this.impactList = [];
    //  }

    if (this.impactList.includes('LOW')) {
      this.isLow = true;
    } else {
      this.isLow = false;
    }
    if (this.impactList.includes('MEDIUM')) {
      this.isMedium = true;
    } else {
      this.isMedium = false;
    }
    if (this.impactList.includes('HIGH')) {
      this.isHigh = true;
    } else {
      this.isHigh = false;
    }
    if (this.impactList.includes('CRITICAL')) {
      this.isCritical = true;
    } else {
      this.isCritical = false;
    }
    const category = cat.toUpperCase();
    this.dcs.setAjexStatus(true);
    if (pagerReq.page !== 0) {
      pagerReq.page = pagerReq.page - 1;
    }
    this.dcs.setAjexStatus(false);
    //  tslint:disable-next-line:max-line-length
    //  this.ctds.getThreatViewByTopIncident(listReqObj.type, listReqObj.clientId, listReqObj.fd.getTime(),
    //    listReqObj.td.getTime(), category, this.isIndustry, this.isGeography, this.isTechnology, pagerReq, this.isDateSort, this.isLow, this.isMedium, this.isHigh, this.isCritical, this.topCyberSearch).subscribe((response: HttpResponse<any[]>) => {
    //      this.dcs.setAjexStatus(false);
    //      this.topListData = response.body;
    //      const totalItems: any = response.headers.get('X-Total-Count');
    //      this.dcs.setTotalRecords(totalItems, this.topListData.length, pagerReq.size);
    //    }, (error: HttpErrorResponse) => this.onError(error));
  }

  getTopGeoClientRelated(type: string, cat: string) {
    if (this.topGeoCat !== 'Related News') {
      this.resetDefDate();
      this.resetAll();
      this.impactList = [];
    }
    if (!this.filterOpt.date && !this.filterOpt.date.td) {
      this.resetDefDate();
      this.resetAll();
    }
    if (!this.filterOpt.date && !this.filterOpt.date.td) {
      this.filterOpt.date.defDV = 90;
    }
    this.pType = type;

    const fromDatelocal = new Date(this.filterOpt.date.fd + 'Z');
    const toDatelocal = new Date(this.filterOpt.date.td + 'Z');
    toDatelocal.setDate(toDatelocal.getDate() + 1);
    const listReqObj = {
      type: this.pType,
      fd: fromDatelocal,
      td: toDatelocal,
      clientId: this.clientId,
    };
    const pagerReq = {
      page: this.cpi,
      size: this.size === 5 ? 5 : 200,
    };
    //  if (this.topGeoCat !== 'Related News' && this.tabConfig.stb !== 'Client') {
    //    this.impactList = [];
    //  }
    if (this.impactList.includes('LOW')) {
      this.isLow = true;
    } else {
      this.isLow = false;
    }
    if (this.impactList.includes('MEDIUM')) {
      this.isMedium = true;
    } else {
      this.isMedium = false;
    }
    if (this.impactList.includes('HIGH')) {
      this.isHigh = true;
    } else {
      this.isHigh = false;
    }
    if (this.impactList.includes('CRITICAL')) {
      this.isCritical = true;
    } else {
      this.isCritical = false;
    }
    const category = cat.toUpperCase();
    this.dcs.setAjexStatus(true);
    if (pagerReq.page !== 0) {
      pagerReq.page = pagerReq.page - 1;
    }
    //  tslint:disable-next-line:max-line-length
    this.ctds
      .getThreatViewByTopIncident(
        listReqObj.type,
        listReqObj.clientId,
        listReqObj.fd.getTime(),
        listReqObj.td.getTime(),
        category,
        this.isIndustry,
        this.isGeography,
        this.isTechnology,
        pagerReq,
        this.isDateSort,
        this.isLow,
        this.isMedium,
        this.isHigh,
        this.isCritical
      )
      ?.subscribe(
        (response: HttpResponse<any[]>) => {
          this.dcs.setAjexStatus(false);
          this.topListData = response.body;
          const totalItems: any = response.headers.get('X-Total-Count');
          this.dcs.setTotalRecords(totalItems, this.topListData.length, pagerReq.size);
        },
        (error: HttpErrorResponse) => this.onError(error)
      );
  }

  //  added on 26-03-21 for new requirement
  getVulnSubCategory(cat: string, radioNav?: boolean) {
    this.vulClientSubCat = cat;
    if (this.vulClientSubCat === 'Asset Based') {
      this.vulnAssetWithVerFlag = false;
      this.vulnAttSurfWithVerFlag = true;
      this.vulnAttSurfWithVer = false;
      this.vul_based_filter.isAsset = true;
      this.vul_based_filter.isVendor = true;
      this.vul_based_filter.isAttackSurface = false;
      this.vul_based_filter.isVersionOnly = false;
    } else if (this.vulClientSubCat === 'Attack Surface Based') {
      this.vulnAssetWithVerFlag = true;
      this.vulnAssetWithVer = false;
      this.vulnAttSurfWithVerFlag = false;
      this.vul_based_filter.isAsset = true;
      this.vul_based_filter.isVendor = true;
      this.vul_based_filter.isAttackSurface = true;
      this.vul_based_filter.isVersionOnly = true;
    } else if (this.vulClientSubCat === 'Reported Vulnerabilities') {
      this.vul_based_filter.isAsset = false;
      this.vul_based_filter.isAttackSurface = false;
      this.vul_based_filter.isVersionOnly = false;
      this.vul_based_filter.isVendor = false;
    }
    if (radioNav) {
      this.getClientVulnListByCategory(this.params.category, this.vulClientCat);
    }
  }

  //  added on 26-03-21 for new requirement
  checkVulnAssetWithVer() {
    //  this.vul_based_filter.isAssetComment = false;
    //  this.assetCommets = '';
    //  this.vulnAssetWithVer = isChecked;
    if (!this.vul_based_filter.isAsset) {
      this.vul_based_filter.isVersionOnly = false;
    }
    this.getClientVulnListByCategory(this.params.category, this.vulClientCat);
  }

  //  added on 26-03-21 for new requirement
  checkVulnAttSurfWithVer() {
    //  this.vulnAttSurfWithVer = isChecked;
    this.vul_based_filter.isAssetComment = false;
    this.assetCommets = '';
    this.getClientVulnListByCategory(this.params.category, this.vulClientCat);
  }

  //  get data for Vulnerability category changed
  getClientVulnListByCategory(type: string, cat: string) {
    // console.log(this.vul_based_filter);
    //  this.resetAll();
    this.dateVisibility();
    this.pType = type;
    this.vulClientCat = cat;
    if (cat === 'Top Vulnerabilities & Exploits') {
      this.resetDefDate();
      this.switchListTab(this.tabConfig.stb);
    } else if (cat === 'Asset Related Vulnerabilities') {
      //  this.resetDefDate(); //  added on 26-03-21 modi
      this.checkVulnAssetWithComment();
      this.getThreatViewVulByOrgAsset(cat);
    } else if (cat === 'Reported Vulnerabilities') {
      this.resetDefDate(); //  added on 26-03-21 modi
      this.getThreatViewVulByOnlinereport(cat);
    }
  }

  getClientAttackMethodListByCategory(cat: string) {
    const obj: any = {
      Industry: 'isIndustry',
      Geography: 'isGeography',
      Technology: 'isTechnology',
    };
    this.topListData = this.tempTopList.filter(item => item[obj[cat]] === true);
  }

  filterAttackMethodByCategory() {
    if (this.pType === 'top-campaigns' || this.pType === 'top-malware') {
      this.tempTopList = this.topListData;
      let filterCount = 0;
      ['isIndustry', 'isGeography', 'isTechnology'].forEach(cat => {
        const tempList = this.tempTopList.filter(item => item[cat]);
        if (tempList.length > 0 && filterCount === 0) {
          this.topListData = tempList;
          this.filterClientCat = cat.replace('is', '');
          filterCount = tempList.length;
        }
      });
    }
  }

  openEWPage(_id: any, key?: string, isNew?: boolean) {
    if (key === 'Early Warnings') {
      if (isNew === true) {
        this.router.navigate(['cap/tvi/report-view'], { queryParams: { type: 'Early Warning Advisory', id: _id } });
      } else {
        this.router.navigate(['cap/tvi/report-view'], { queryParams: { type: key, id: _id } });
      }
    }
  }
  attackMethodChange(cat: any) {
    //  this.router.navigate(
    //    [],
    //    {
    //      relativeTo: this.activatedRoute,
    //      queryParams: { view: 'attack-methods', category: cat },
    //      queryParamsHandling: 'merge'
    //    });
    this.resetAll();
    this.resetDefDate();
    this.pType = cat;
    this.switchListTab(this.tabConfig.client);
  }
  //  call vulnerabilty global to reset pagination
  vulnTabChange(tab: any) {
    this.resetDefDate();
    this.resetAll();
    this.impact = '';
    if (tab.nextId === 've-ct') {
      this.tabConfig.stb = 'Client';
      this.switchListTab('Client');
    } else if (tab.nextId === 've-gt') {
      this.tabConfig.stb = 'Global';
      this.switchListTab('Global');
    }
  }

  getClientVulnListByProduct() {
    this.dcs.resetPagerInfo();
    this.cpi = 0;
    this.assetCommets = '';
    this.vul_based_filter.isAssetComment = false;
    this.switchListTab(this.tabConfig.stb);
    //  commented on 260321
    //  if (this.vulClientCat === 'Top Vulnerabilities & Exploits') {
    //    this.switchListTab(this.tabConfig.stb);
    //  } else if (this.vulClientCat === 'Asset Related Vulnerabilities') {
    //    this.getThreatViewVulByOrgAsset(this.vulClientCat);
    //  } else if (this.vulClientCat === 'Reported Vulnerabilities') {
    //    this.getThreatViewVulByOnlinereport(this.vulClientCat);
    //  }
  }

  getClientVulnListByImapact() {
    this.dcs.resetPagerInfo();
    this.cpi = 0;
    this.assetCommets = '';
    this.vul_based_filter.isAssetComment = false;
    if (this.vulClientCat === 'Reported Vulnerabilities') {
      this.getThreatViewVulByOnlinereport(this.vulClientCat);
    } else {
      this.switchListTab(this.tabConfig.stb);
    }
    //  commented on 260321
    //  if (this.vulClientCat === 'Top Vulnerabilities & Exploits') {
    //    this.switchListTab(this.tabConfig.stb);
    //  } else if (this.vulClientCat === 'Asset Related Vulnerabilities') {
    //    this.getThreatViewVulByOrgAsset(this.vulClientCat);
    //  } else if (this.vulClientCat === 'Reported Vulnerabilities') {
    //    this.getThreatViewVulByOnlinereport(this.vulClientCat);
    //  }
  }

  getTopGeoClientFilter() {
    this.dcs.resetPagerInfo();
    this.cpi = 0;
    if (this.params.category === 'top-geography-industry-and-technology' && this.topGeoCat === 'Related News') {
      this.getTopGeoClientRelated(this.pType, this.topGeoCat);
    }
  }

  getTopGeoFilter() {
    this.dcs.resetPagerInfo();
    this.cpi = 0;
    if (this.pType === 'top-geography-industry-and-technology' && this.topGeoCat === 'Related News') {
      this.getTopGeoClientRelated(this.pType, this.topGeoCat);
    }
  }

  getTopCyberFilter() {
    this.dcs.resetPagerInfo();
    this.cpi = 0;
    if (this.pType === 'top-news-incident-and-attacks' && this.relatedCat === 'Related News') {
      this.getClientRelatedFilter(this.pType, this.relatedCat);
    }
  }
  reset() {
    this.topCyberSearch = '';
    this.switchListTab(this.tabConfig.stb);
  }
  getTopCyberNews() {
    this.dcs.resetPagerInfo();
    this.cpi = 0;
    if (this.pType === 'top-news-incident-and-attacks' && this.relatedCat === 'Related News') {
      this.getClientRelatedFilter(this.pType, this.relatedCat);
    }
  }

  getTopGeoGlobal() {
    this.switchListTab(this.tabConfig.stb);
  }

  searchByTitle() {
    this.dcs.setAjexStatus(true);
    this.ctds.campaignSearch(this.clientId, this.searchCampaign).subscribe(
      (res: HttpResponse<any[]>) => {
        const totalItems: any = res.headers.get('X-Total-Count');
        if (this.tabConfig.stb === 'Client') {
          this.tempTopList = res.body ? res.body : [];
          this.getClientAttackMethodListByCategory(this.filterClientCat);
        } else if (this.tabConfig.stb === 'Global') {
          this.topListData = res.body;
          this.dcs.setTotalRecords(totalItems, this.topListData.length, 100);
        } else {
          this.topListData = res.body;
          this.dcs.setTotalRecords(totalItems, this.topListData.length, 100);
        }
        this.dcs.setAjexStatus(false);
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }
  searchByTitleRansome(reset?: any) {
    if (reset) {
      this.dcs.setTotalRecords(0, 0, 0);
    }
    this.dcs.setAjexStatus(true);
    //  tslint:disable-next-line:max-line-length
    const pagerReq = {
      page: 0,
      size: this.size,
    };
    if (pagerReq.page !== 0) {
      pagerReq.page = pagerReq.page - 1;
    }
    this.ctds.ransomeSearch(this.isRansomware, this.searchRansome ? this.searchRansome : '', this.ransomeListDropDown, pagerReq).subscribe(
      (response: HttpResponse<any[]>) => {
        this.dcs.setAjexStatus(false);
        this.ransomeListData = response.body!;
        const totalItems: any = response.headers.get('X-Total-Count');
        this.dcs.setTotalRecords(totalItems, this.ransomeListData.length, 20);
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }
  searchByMalwareTitle() {
    this.dcs.setAjexStatus(true);
    this.ctds.malwareListSearch(this.clientId, this.searchMalware).subscribe(
      (res: HttpResponse<any[]>) => {
        const totalItems: any = res.headers.get('X-Total-Count');
        this.dcs.setTotalRecords(totalItems, res.body!.length);
        this.topListData = res.body;
        this.dcs.setAjexStatus(false);
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }
  searchByPhisingTitle() {
    this.dcs.setAjexStatus(true);
    this.ctds.phishingListSearch(this.clientId, this.searchPhishing).subscribe(
      (res: HttpResponse<any[]>) => {
        const totalItems: any = res.headers.get('X-Total-Count');
        this.dcs.setTotalRecords(totalItems, res.body!.length);
        this.topListData = res.body;
        this.dcs.setAjexStatus(false);
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }
  //  impact change in phishing client view
  searchByPhishingImpact() {
    if (this.impactList.includes('LOW')) {
      this.isLow = true;
    } else {
      this.isLow = false;
    }
    if (this.impactList.includes('MEDIUM')) {
      this.isMedium = true;
    } else {
      this.isMedium = false;
    }
    if (this.impactList.includes('HIGH')) {
      this.isHigh = true;
    } else {
      this.isHigh = false;
    }
    if (this.impactList.includes('CRITICAL')) {
      this.isCritical = true;
    } else {
      this.isCritical = false;
    }
    const listReqObj = {
      fd: this.filterOpt.date.fd,
      td: this.filterOpt.date.td,
      clientId: this.clientId,
    };
    if (this.tabConfig.stb === 'Client') {
      this.dcs.setAjexStatus(true);
      this.ctds.phishingListImpact(this.clientId, this.isLow, this.isMedium, this.isHigh, this.isCritical, listReqObj.fd.getTime(),listReqObj.td.getTime()).subscribe(
        (res: HttpResponse<any[]>) => {
          const totalItems: any = res.headers.get('X-Total-Count');
          this.dcs.setTotalRecords(totalItems, res.body!.length);
          this.topListData = res.body;
          this.dcs.setAjexStatus(false);
        },
        (error: HttpErrorResponse) => this.onError(error)
      );
    } else if (this.tabConfig.stb === 'Global') {
      this.getTopPhishingFilter();
    }
  }
  //  impact change in malware client view
  searchByMalwareImpact() {
    if (this.impactList.includes('LOW')) {
      this.isLow = true;
    } else {
      this.isLow = false;
    }
    if (this.impactList.includes('MEDIUM')) {
      this.isMedium = true;
    } else {
      this.isMedium = false;
    }
    if (this.impactList.includes('HIGH')) {
      this.isHigh = true;
    } else {
      this.isHigh = false;
    }
    if (this.impactList.includes('CRITICAL')) {
      this.isCritical = true;
    } else {
      this.isCritical = false;
    }
    if (this.tabConfig.stb === 'Client') {
      this.dcs.setAjexStatus(true);
      this.ctds.malwareListImpact(this.clientId, this.isLow, this.isMedium, this.isHigh, this.isCritical).subscribe(
        (res: HttpResponse<any[]>) => {
          const totalItems: any = res.headers.get('X-Total-Count');
          this.dcs.setTotalRecords(totalItems, res.body!.length);
          this.topListData = res.body;
          this.dcs.setAjexStatus(false);
        },
        (error: HttpErrorResponse) => this.onError(error)
      );
    } else if (this.tabConfig.stb === 'Global') {
      this.getTopMawlareFilter();
    }
  }
  //  sort in phishing client view
  sortByPhishing() {
    this.dcs.setAjexStatus(true);
    this.ctds.sortByPhishing(this.clientId, this.isDateSort).subscribe(
      (res: HttpResponse<any[]>) => {
        const totalItems: any = res.headers.get('X-Total-Count');
        this.dcs.setTotalRecords(totalItems, res.body!.length);
        this.topListData = res.body;
        this.dcs.setAjexStatus(false);
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }
  //  sort in malware cleint view
  sortByMalware() {
    this.dcs.setAjexStatus(true);
    this.ctds.sortByMalware(this.clientId, this.isDateSort).subscribe(
      (res: HttpResponse<any[]>) => {
        const totalItems: any = res.headers.get('X-Total-Count');
        this.dcs.setTotalRecords(totalItems, res.body!.length);
        this.topListData = res.body;
        this.dcs.setAjexStatus(false);
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }
  //  getClientVulnListBySort() {
  //    this.dcs.resetPagerInfo();
  //    this.cpi = 0;
  //    if (this.vulClientCat === 'Top Vulnerabilities & Exploits') {
  //      this.switchListTab(this.tabConfig.stb);
  //    } else if (this.vulClientCat === 'Asset Related Vulnerabilities') {
  //      this.getThreatViewVulByOrgAsset(this.vulClientCat);
  //    } else if (this.vulClientCat === 'Reported Vulnerabilities') {
  //      this.getThreatViewVulByOnlinereport(this.vulClientCat);
  //    }
  //  }

  getThreatViewVulByOnlinereport(cate: string) {
    if (this.pType === 'vulnerabilities') {
      this.pType = 'top-vulnerability-and-exploit';
    }
    const listReqObj = {
      type: this.pType,
      fd: this.filterOpt.date.fd,
      td: this.filterOpt.date.td,
      clientId: this.clientId,
    };
    const pagerReq = {
      page: this.cpi,
      size: this.size === 5 ? 5 : 200,
    };
    if (!this.vulnPrdSearch) {
      this.vulnPrdSearch = '';
    }
    if (!this.impact) {
      this.impact = '';
    }
    const category = cate.toUpperCase();
    this.dcs.setAjexStatus(true);
    if (pagerReq.page !== 0) {
      pagerReq.page = pagerReq.page - 1;
    }
    //  tslint:disable-next-line:max-line-length
    this.ctds
      .getThreatViewByCategory(
        listReqObj.type,
        listReqObj.clientId,
        listReqObj.fd.getTime(),
        listReqObj.td.getTime(),
        category,
        this.vulnPrdSearch,
        this.impact,
        pagerReq,
        null,
        this.isDateSort,
        null!,
        null!,
        null!,
        null!,
        false,
        false,
        false
      )
      ?.subscribe(
        (response: HttpResponse<any[]>) => {
          this.dcs.setAjexStatus(false);
          this.topListData = response.body;
          const totalItems: any = response.headers.get('X-Total-Count');
          this.dcs.setTotalRecords(totalItems, this.topListData.length, pagerReq.size);
        },
        (error: HttpErrorResponse) => this.onError(error)
      );
  }

  getThreatViewVulByOrgAsset(cate: string) {
    if (this.pType === 'vulnerabilities') {
      this.pType = 'top-vulnerability-and-exploit';
    }
    const fromDatelocal = new Date(this.filterOpt.date.fd + 'Z');
    const toDatelocal = new Date(this.filterOpt.date.td + 'Z');
    const currentDate = new Date();
    toDatelocal.setDate(toDatelocal.getDate() + 1);
    if (currentDate.getTime() === toDatelocal.getTime()) {
      toDatelocal.setDate(toDatelocal.getDate() - 1);
    }
    const listReqObj = {
      type: this.pType,
      fd: fromDatelocal,
      td: toDatelocal,
      clientId: this.clientId,
    };
    const pagerReq = {
      page: this.cpi,
      size: this.size === 5 ? 5 : 200,
    };
    if (!this.vulnPrdSearch) {
      this.vulnPrdSearch = '';
    }
    if (!this.impact) {
      this.impact = '';
    }
    //  let isAsset = false;
    //  let isAttackSurface = false;
    //  let isVersionOnly = false;
    //  if (this.vulClientSubCat === 'Asset Based') {
    //    isAsset = true;
    //    isVersionOnly = this.vulnAssetWithVer;
    //  }
    //  if (this.vulClientSubCat === 'Attack Surface Based') {
    //    isAttackSurface = true;
    //    isVersionOnly = this.vulnAttSurfWithVer;
    //  }
    let category = cate.toUpperCase();
    if (this.vulClientSubCat === 'Reported Vulnerabilities') {
      category = this.vulClientSubCat.toUpperCase();
    }
    this.dcs.setAjexStatus(true);
    if (pagerReq.page !== 0) {
      pagerReq.page = pagerReq.page - 1;
    }
    //  tslint:disable-next-line:max-line-length
    this.ctds
      .getThreatViewByCategory(
        listReqObj.type,
        listReqObj.clientId,
        this.filterOpt.date.fd.getTime(),
        this.filterOpt.date.td.getTime(),
        category,
        this.vulnPrdSearch,
        this.impact,
        pagerReq,
        null,
        this.isDateSort,
        null!,
        null!,
        null!,
        null!,
        this.vul_based_filter.isAsset,
        this.vul_based_filter.isAttackSurface,
        this.vul_based_filter.isVersionOnly,
        null!,
        this.vul_based_filter.isVendor
      )
      ?.subscribe(
        (response: HttpResponse<any[]>) => {
          this.dcs.setAjexStatus(false);
          this.topListData = response.body;
          const totalItems: any = response.headers.get('X-Total-Count');
          this.dcs.setTotalRecords(totalItems, this.topListData.length, pagerReq.size);
          this.setBlurRecords('vulclnTable');
        },
        (error: HttpErrorResponse) => this.onError(error)
      );
  }

  getGITListByCategory() {
    this.switchListTab(this.tabConfig.stb);
  }

  openTVTopListNewsDialog(_ld: any, opt?: string) {
    this.router.navigate(['cap/news-details', 'tvi-list'], {
      queryParams: { category: 'news', type: _ld.srcType ? _ld.srcType : 'rss', id: _ld.parentId },
    });
  }

  openCVDBDialog(data: any) {
    this.dialog.open(OpenCVBDDialogComponent, {
      width: this.dialogConfig.dWidth,
      height: this.dialogConfig.height,
      maxWidth: this.dialogConfig.maxWidth,
      disableClose: false,
      data: { action: 'show_cvdb', data },
      panelClass: 'slide-ltr',
    });
  }

  sortByDisclosedDate() {
    const sortOrder = [[''], ['disclosedAt,DESC'], ['disclosedAt,ASC']];
    this.openCVDB_pdSort = 0;
    this.openCVDB_ddSort = (this.openCVDB_ddSort + 1) % 3;
    this.openCVDB_sort = sortOrder[this.openCVDB_ddSort];
    this.cpi = 0;
    this.dcs.resetPagerInfo();
    this.switchListTab(this.tabConfig.stb);
  }

  sortByPublishedDate() {
    const sortOrder = [[''], ['publishedAt,DESC'], ['publishedAt,ASC']];
    this.openCVDB_ddSort = 0;
    this.openCVDB_pdSort = (this.openCVDB_pdSort + 1) % 3;
    this.openCVDB_sort = sortOrder[this.openCVDB_pdSort];
    this.cpi = 0;
    this.dcs.resetPagerInfo();
    this.switchListTab(this.tabConfig.stb);
  }

  //  open threat view top list dialog
  openTVTopListDialog(_ld: any, opt?: string) {
    if (_ld.type === 'DIGITAL RISK') {
      if (_ld.category === 'Vulnerabilities') {
        this.dcs.setAjexStatus(true);
        this.databreachIpVulnerabilityService.find(_ld.parentId).subscribe(
          (res: HttpResponse<any>) => {
            this.dcs.setAjexStatus(false);
            this.dialog.open(ClientIncidentComponent, {
              width: this.dialogConfig.dWidth,
              height: 'auto',
              maxWidth: this.dialogConfig.maxWidth,
              disableClose: true,
              data: { action: _ld.type, label: _ld.type, data: res.body },
              panelClass: 'slide-ltr',
            });
          },
          (error: HttpErrorResponse) => this.onError(error)
        );
      } else {
        this.dcs.setAjexStatus(true);
        this.clientIncidentService.find(_ld.parentId).subscribe(
          (res: HttpResponse<any>) => {
            this.dcs.setAjexStatus(false);
            this.dialog.open(ClientIncidentComponent, {
              width: this.dialogConfig.dWidth,
              height: 'auto',
              maxWidth: this.dialogConfig.maxWidth,
              disableClose: true,
              data: { action: _ld.type, label: _ld.type, data: res.body },
              panelClass: 'slide-ltr',
            });
          },
          (error: HttpErrorResponse) => this.onError(error)
        );
      }
    } else if (_ld.type === 'PHISHING AND MALWARE' || _ld.type === 'PHISHING') {
      if (_ld.category === 'PHISHING') {
        this.dcs.setAjexStatus(true);
        this.phishingService.find(_ld.parentId).subscribe(
          (res: HttpResponse<any>) => {
            this.dcs.setAjexStatus(false);
            this.dialog.open(PhishingDetailsComponent, {
              width: this.dialogConfig.width,
              height: this.dialogConfig.height,
              maxWidth: this.dialogConfig.maxWidth,
              disableClose: true,
              data: { action: _ld.type, label: _ld.type, data: res.body },
              panelClass: 'slide-ltr',
            });
          },
          (error: HttpErrorResponse) => this.onError(error)
        );
      } else {
        this.router.navigate(['cap/cyber-threat/dashboard', 'details-page'], {
          queryParams: { type: _ld.srcType ? _ld.srcType : 'rss', id: _ld.parentId },
        });
      }
    } else if (_ld.type === 'VULNERABILITY AND EXPLOIT') {
      //  this.router.navigate(['cap/cyber-threat/dashboard', 'details'], { queryParams: { category: 'vulnerability', type: _ld.srcType ? _ld.srcType : 'nvd', id: _ld.id } });
      if (_ld.category === 'VULNERABILITY') {
        this.router.navigate(['cap/cyber-threat/dashboard', 'details'], { queryParams: { type: 'vulnerability', id: _ld.parentId } });
      } else if (_ld.category === 'EXPLOIT') {
        this.router.navigate(['cap/cyber-threat/dashboard', 'details'], { queryParams: { type: 'exploits', id: _ld.parentId } });
      }
    } else if (_ld.type === 'CYBERATTACKS') {
      this.router.navigate(['cap/cyber-threat/dashboard', 'details-page'], {
        queryParams: { type: _ld.srcType ? _ld.srcType : 'rss', id: _ld.parentId },
      });
    } else if (_ld.type === 'GEOGRAPHY INDUSTRY AND TECHNOLOGY') {
      this.dcs.storeSituationalAwarenessType('top-geography-industry-and-technology');
      this.router.navigate(['cap/news-details', 'tvi-list'], {
        queryParams: { type: _ld.srcType ? _ld.srcType : 'rss', id: _ld.parentId },
      });
    } else if (_ld.type === 'NEWS INCIDENT AND ATTACK') {
      this.dcs.storeSituationalAwarenessType('top-news-incident-and-attacks');
      if (_ld.category === 'INCIDENT') {
        this.router.navigate(['cap/news-details', 'tvi-list'], {
          queryParams: { category: 'incident', type: 'incident', id: _ld.parentId },
        });
      } else {
        this.router.navigate(['cap/news-details', 'tvi-list'], {
          queryParams: { category: 'news', type: _ld.srcType ? _ld.srcType : 'rss', id: _ld.parentId },
        });
      }
    } else if (_ld.type === 'HACKER INTEREST') {
      if (opt && opt === 'hi-dialog') {
        this.dcs.setAjexStatus(true);
        this.darkWebService.findClientDarkWeb(_ld.parentId).subscribe(
          (res: HttpResponse<any>) => {
            this.dcs.setAjexStatus(false);
            const response = res.body;
            if (res.body) {
              this.hackerInterest.id = response.id;
              this.hackerInterest.name = response.name;
              this.hackerInterest.date = response.date;
              this.hackerInterest.description = response.summary;
              this.hackerInterest.darkForumUrls = response.darkForumUrls;
              this.hackerInterest.hackerNameGroups = response.hackerNameGroups;
              this.hackerInterest.iocs = response.iocs;
            }
            this.dialog.open(ClientDarkwebComponent, {
              width: this.dialogConfig.width,
              height: this.dialogConfig.height,
              maxWidth: this.dialogConfig.maxWidth,
              disableClose: true,
              data: { action: _ld.type, label: _ld.type, data: this.hackerInterest },
            });
          },
          (error: HttpErrorResponse) => this.onError(error)
        );
      } else {
        this.router.navigate(['cap/cyber-threat/dashboard', 'List'], { queryParams: { type: 'hacker-interest', orgId: this.clientId } });
      }
    } else if (_ld.type === 'EARLY WARNING OR OUT OF BAND') {
      if (opt && opt === 'ew-dialog') {
        const actionData: any = { action: 'Online Report', label: 'Online Report' };
        actionData.data = { reportType: 'early warning', id: _ld.id };
        this.dialog.open(DialogComponent, {
          width: this.dialogConfig.width,
          height: this.dialogConfig.height,
          maxWidth: this.dialogConfig.maxWidth,
          disableClose: true,
          data: actionData,
        });
      } else {
        const ewType = _ld.category === 'Out of Band' ? 'OOB' : 'Early Warnings';
        const ewId = _ld.parentId ? _ld.parentId : _ld.id;
        this.router.navigate(['cap', 'early-warnings'], { queryParams: { type: ewType, id: ewId } });
        //  if (_ld.category === 'Early Warning') {
        //    this.router.navigate(['cap/cyber-threat/dashboard', 'List'], { queryParams: { type: 'early-warning', orgId: this.clientId } });
        //  } else if (_ld.category === 'Out of Band') {
        //    this.router.navigate(['cap/cyber-threat/dashboard', 'List'], { queryParams: { type: 'oob', orgId: this.clientId } });
        //  }
      }
    } else if (_ld.type === 'CAMPAIGN') {
      const _data = _ld;
      this.dialog.open(CampaignComponent, {
        width: this.dialogConfig.width,
        height: this.dialogConfig.height,
        maxWidth: this.dialogConfig.maxWidth,
        disableClose: true,
        data: { action: _ld.type, label: _ld.type, data: _data },
      });
    } else if (_ld.type === 'MALWARE') {
      const _data = _ld;
      this.dialog.open(MalwareComponent, {
        width: this.dialogConfig.width,
        height: this.dialogConfig.height,
        maxWidth: this.dialogConfig.maxWidth,
        disableClose: true,
        data: { action: _ld.type, label: _ld.type, data: _data },
      });
      this.dialog.open(ClientDarkwebComponent, {
        width: this.dialogConfig.dWidth,
        height: 'auto',
        maxWidth: this.dialogConfig.maxWidth,
        disableClose: true,
        data: { action: '', label: 'ransomeware', data: _ld },
      });
    } else if (opt === 'ransomeClient') {
      this.dialog.open(ClientDarkwebComponent, {
        width: this.dialogConfig.dWidth,
        height: 'auto',
        maxWidth: this.dialogConfig.maxWidth,
        disableClose: true,
        data: { action: '', label: 'ransomeClient', data: _ld },
      });
    } else {
      //  malicious ips
      const req: any = {
        search: _ld.title,
      };
      this.dcs.setAjexStatus(true);
      this.ctds.searchByIPs(req).subscribe(
        res => {
          this.dcs.setAjexStatus(false);
          this.dialog.open(IocComponent, {
            width: this.dialogConfig.width,
            height: this.dialogConfig.height,
            maxWidth: this.dialogConfig.maxWidth,
            disableClose: true,
            data: { action: 'IP', label: _ld.title, data: res.body },
          });
        },
        (error: HttpErrorResponse) => this.onError(error)
      );
    }
  }

  //  attack method
  loadAttackMethodManageDrill(_country: any) {
    this.resetAll();
    const req = {
      size: this.size === 5 ? 5 : 200,
      type: this.pType,
      country: _country,
    };
    this.dcs.setAjexStatus(true);
    this.ctds.getAttackMethodManagementGeoDrillList(this.clientId, req).subscribe(
      (response: HttpResponse<any[]>) => {
        this.dcs.setAjexStatus(false);
        this.topListData = response.body; //  list data*/
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }

  //  managment attack method ioc drill
  loadManageAttackMethodIOCDrill() {
    const req = {
      size: this.size === 5 ? 5 : 200,
      category: 'ioc',
      type: this.params.type,
      noOfMonth: this.params.date,
      range: this.params.range,
    };
    if (this.cpi && this.cpi !== 0) {
      this.cpi = this.cpi - 1;
    }
    const pagerReq = {
      page: this.cpi,
      size: this.size === 5 ? 5 : 200,
    };
    this.dcs.setAjexStatus(true);
    this.ctds.getAttackMethodList(this.clientId, req, pagerReq).subscribe(
      (response: HttpResponse<any[]>) => {
        this.dcs.setAjexStatus(false);
        this.topListData = response.body;
        const totalItems: any = response.headers.get('X-Total-Count');
        this.dcs.setTotalRecords(totalItems, response.body!.length, 200);
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }

  //  search ioc keywords
  searchKeywords(key: string, searchedItem: any) {
    if (key === 'VULNERABILITY') {
      this.ds.searchKeywords(key, searchedItem.title.split(':')[0], 'TVI', false);
    } else if (key === 'CVE') {
      this.ds.searchKeywords(key, searchedItem, 'TVI', false);
    } else if (key === 'Exploit') {
      this.ds.searchKeywords(key, searchedItem, 'TVI', false);
    } else if (key === 'EXPLOIT') {
      this.ds.searchKeywords(key, searchedItem.parentId, 'TVI', false);
    } else {
      this.ds.searchKeywords(key, searchedItem, 'TVI', false);
    }
  }
  //  search keywords for ioc cagegory
  openIOCKeywords(category: string, title: string) {
    if (category === 'IP Address') {
      this.searchKeywords('IP', title);
    } else if (category === 'File Hash') {
      this.searchKeywords('SHA', title);
    } else if (category === 'Domain') {
      this.searchKeywords('Domain', title);
    } else {
      this.searchKeywords(category, title);
    }
  }

  //  managment -ioc drill-down list
  isOtherIndicatorType(type: string): boolean {
    if (
      type === 'IP Address' ||
      type === 'Hostname' ||
      type === 'Domain' ||
      type === 'URL' ||
      type === 'Mutex' ||
      type === 'Email' ||
      type === 'File Hash'
    ) {
      return false;
    } else {
      return true;
    }
  }

  //  convert riskLevel to priority
  getPriorityValue(value: any, isLong?: boolean) {
    return this.dcs.getPriorityValue(value, isLong).toLowerCase();
  }

  dateVisibility(): boolean {
    let visible = true;
    if (this.routeName === 'threat-view/whats-new') {
      visible = false;
    } else if (
      this.routeName === 'operations' &&
      (this.params.category === 'top-campaigns' ||
        this.params.category === 'top-phishing' ||
        this.params.category === 'top-news-incident-and-attacks' ||
        this.params.category === 'top-geography-industry-and-technology' ||
        this.params.category === 'top-malware' ||
        this.params.category === 'latest-malicious-ip')
    ) {
      visible = false;
    } else if (this.vulClientCat === 'Asset Related Vulnerabilities' && this.tabConfig.stb === 'Client') {
      visible = true;
    } else if (this.sveCat === 'Vulnerability' && this.tabConfig.stb === 'Global') {
      visible = true;
    } else if (this.vulClientCat === 'Reported Vulnerabilities' && this.tabConfig.stb === 'Client') {
      visible = false;
    } else if (this.sveCat === 'Vulnerability News' && this.tabConfig.stb === 'Global') {
      visible = true;
    } else if (this.sveCat === 'Zero-Day Vulnerability' && this.tabConfig.stb === 'Global') {
      visible = true;
    } else if (this.sveCat === 'Exploit' && this.tabConfig.stb === 'Global') {
      visible = true;
    } else if (this.sveCat === 'Cloud Vulnerabilities' && this.tabConfig.stb === 'Global') {
      visible = false;
    } else if (this.vulClientCat === 'Top Vulnerabilities & Exploits' && this.tabConfig.stb === 'Client') {
      visible = false;
    } else if (this.pType === 'top-news-incident-and-attacks' && this.relatedCat === 'Related News') {
      visible = true;
    } else if (
      this.params.category === 'situational-awareness' &&
      this.pType === 'top-news-incident-and-attacks' &&
      this.tabConfig.stb === 'Global'
    ) {
      visible = true;
      //  tslint:disable-next-line: max-line-length
    } else if (
      this.params.category === 'situational-awareness' &&
      this.pType === 'top-news-incident-and-attacks' &&
      this.tabConfig.stb === 'Client' &&
      this.relatedCat === 'Top News'
    ) {
      visible = false;
    } else {
      visible = true;
    }
    return visible;
  }
  //  open threat story dialog
  openThreatStory(data: any) {
    this.ds.openThreatStory(data, this.clientId);
  }

  //  open threat story dialog
  openThreatStoryIOC(data: any, category: any) {
    this.ds.openThreatStoryIOC(data, category, this.clientId);
  }

  loadGITOptions(): void {
    this.geographiesOptions = this.dcs.loadGIT('geography');
    this.industriesOptions = this.dcs.loadGIT('industry');
    this.technologiesOptions = this.dcs.loadGIT('technology');
    this.gitFilterInfo['industry'].config = this.dcs.getFilterConfigByType('industry');
    this.gitFilterInfo['industry'].list = <any>this.industriesOptions;
    // console.log( this.gitFilterInfo['industry'].list);
    this.gitFilterInfo['technology'].config = this.dcs.getFilterConfigByType('technology');
    this.gitFilterInfo['technology'].list = <any>this.technologiesOptions;
    this.gitFilterInfo['geography'].config = this.dcs.getFilterConfigByType('geography');
    this.gitFilterInfo['geography'].list = <any>this.geographiesOptions;
    // console.log(this.gitFilterInfo['geography'].list);
  }

  countrySearch(e: any) {
    this.selectedGITOption = e;
    if (this.selectedGITOption && this.selectedGITOption === 'none') {
      this.selectedCountry = '';
      if (this.params && this.params.category === 'latest-malicious-ip') {
        this.tabConfig.stb = 'Global';
      }
      this.switchListTab(this.tabConfig.stb);
    } else {
      this.selectedCountry = this.selectedGITOption.name;
      if (this.params && this.params.category === 'latest-malicious-ip') {
        this.tabConfig.stb = 'Global';
      }
      this.switchListTab(this.tabConfig.stb);
    }
  }

  // downloadsearchbycommentClientVulnerability
  downloadsearchbycommentClientVulnerability() {
    const listReqObj = {
      assetCommets: this.assetCommets ? this.assetCommets : '',
      clientId: this.clientId,
    };
    if (listReqObj.assetCommets !== '') {
      this.dcs.setAjexStatus(true);
      this.ctds.downloadsearchbycommentClientVulnerability(listReqObj.clientId, listReqObj.assetCommets).subscribe(
        res => {
          this.dcs.setAjexStatus(false);
          const response: any = res;
          const blob = new Blob([response], { type: '*' });
          saveAs(blob, 'vulnerabilities_comments.csv');
        },
        (error: HttpErrorResponse) => this.onError(error)
      );
    }
  }
  //  downloadTopVulnerability
  downloadTopVulnerability() {
    const dateReq = {
      fd: this.filterOpt.date.fd.getTime(),
      td: this.filterOpt.date.td.getTime(),
    };
    //  const clinentId = this.isAnalyst ? this.dcs.getChangedOrg() : this.dcs.getLoggedUser().orgId;
    this.dcs.setAjexStatus(true);
    this.ctds.topVulnerabilityExport(this.clientId, dateReq.fd, dateReq.td).subscribe(
      res => {
        this.dcs.setAjexStatus(false);
        const response: any = res;
        const blob = new Blob([response], { type: '*' });
        saveAs(blob, 'top_vulnerability.csv');
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }

  //  downloadClientVulnerability
  downloadClientVulnerability() {
    if (this.pType === 'vulnerabilities') {
      this.pType = 'top-vulnerability-and-exploit';
    }
    const fromDatelocal = new Date(this.filterOpt.date.fd + 'Z');
    const toDatelocal = new Date(this.filterOpt.date.td + 'Z');
    const currentDate = new Date();
    toDatelocal.setDate(toDatelocal.getDate() + 1);
    if (currentDate.getTime() === toDatelocal.getTime()) {
      toDatelocal.setDate(toDatelocal.getDate() - 1);
    }
    const listReqObj = {
      type: this.pType,
      fd: fromDatelocal,
      td: toDatelocal,
      clientId: this.clientId,
    };
    if (!this.vulnPrdSearch) {
      this.vulnPrdSearch = '';
    }
    if (!this.impact) {
      this.impact = '';
    }
    let isAsset = false;
    let isAttackSurface = false;
    let isVersionOnly = false;
    if (this.vulClientSubCat === 'Asset Based') {
      isAsset = true;
      isVersionOnly = this.vulnAssetWithVer;
    }
    if (this.vulClientSubCat === 'Attack Surface Based') {
      isAttackSurface = true;
      isVersionOnly = this.vulnAttSurfWithVer;
    }
    //  const clinentId = this.isAnalyst ? this.dcs.getChangedOrg() : this.dcs.getLoggedUser().orgId;
    this.dcs.setAjexStatus(true);
    //  tslint:disable-next-line:max-line-length
    this.ctds
      .clientVulnerabilityExport(
        listReqObj.clientId,
        listReqObj.fd.getTime(),
        listReqObj.td.getTime(),
        this.vulClientCat,
        this.vulnPrdSearch,
        this.impact,
        this.vul_based_filter.isAsset,
        this.vul_based_filter.isAttackSurface,
        this.vul_based_filter.isVersionOnly,
        this.vul_based_filter.isVendor,
        this.vul_based_filter.isAssetComment,
        this.assetCommets
      )
      .subscribe(
        res => {
          this.dcs.setAjexStatus(false);
          const response: any = res;
          const blob = new Blob([response], { type: '*' });
          saveAs(blob, 'Asset_related_vulnerability.csv');
        },
        (error: HttpErrorResponse) => this.onError(error)
      );
  }

  	//global csv added
    downloadGlobalVulnerability(){
      const listReqObj = {
        fd: this.filterOpt.date.fd,
        td: this.filterOpt.date.td,
        clientId: this.clientId,
      };
      if (!this.impact) {
        this.impact = '';
      }
      if(this.sveCat === 'Vulnerability'){
        this.dcs.setAjexStatus(true);
        this.ctds
          .globalVulnerabilityExport(listReqObj.clientId,listReqObj.fd.getTime(),listReqObj.td.getTime(),this.sveCat.toUpperCase(),this.impact,)
          .subscribe(
            res => {
              this.dcs.setAjexStatus(false);
              const response: any = res;
              const blob = new Blob([response], { type: '*' });
              saveAs(blob, 'Vulnerability.csv');
            },
            (error: HttpErrorResponse) => this.onError(error)
          );
      }else if(this.sveCat === 'Exploit'){
        this.dcs.setAjexStatus(true);
        this.ctds
          .globalVulnerabilityExport(listReqObj.clientId,listReqObj.fd.getTime(), listReqObj.td.getTime(),this.sveCat.toUpperCase(),this.impact)
          .subscribe(
            res => {
              this.dcs.setAjexStatus(false);
              const response: any = res;
              const blob = new Blob([response], { type: '*' });
              saveAs(blob, 'Exploit.csv');
            },
            (error: HttpErrorResponse) => this.onError(error)
          );
          }
    }
  //  load attack method dill down list
  loadAttackMethodDrillDownList() {
    const req = {
      size: this.size === 5 ? 5 : 200,
      category: this.pType,
      type: this.pAttackType,
      date: 6,
      noOfMonth: this.params.date,
      range: this.range,
    };
    const pagerReq = {
      page: this.cpi,
      size: this.size === 5 ? 5 : 200,
    };
    if (pagerReq.page !== 0) {
      pagerReq.page = pagerReq.page - 1;
    }
    this.dcs.setAjexStatus(true);
    this.ctds.getAttackMethodList(this.clientId, req, pagerReq).subscribe(
      (response: HttpResponse<any[]>) => {
        this.dcs.setAjexStatus(false);
        this.topListData = response.body; //  list data*/
        let totalItems: any;
        if (this.topListData.length === 0) {
          totalItems = response.headers.get('0');
        } else {
          totalItems = response.headers.get('X-Total-Count');
        }
        this.dcs.setTotalRecords(totalItems, this.topListData.length, req.size);
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }

  loadClientDarkWebDrillDownList() {
    this.dcs.setAjexStatus(true);
    const req = {
      size: this.size === 5 ? 5 : 200,
      category: this.pType,
      type: this.pAttackType,
      date: 6,
      range: this.range,
    };
    this.ctds.getDarkWebDrillDownList(this.clientId, req).subscribe(
      (response: HttpResponse<any[]>) => {
        this.dcs.setAjexStatus(false);
        this.topListData = response.body; //  list data*/
        const totalItems = Number(response.headers.get('X-Total-Count'));
        this.dcs.setTotalRecords(totalItems, this.topListData.length, req.size);
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }

  getDarkwebObservationDetails(_data: any) {
    this.dialog.open(ReportDarkwebObservationsComponent, {
      width: this.dialogConfig.width,
      height: this.dialogConfig.height,
      maxWidth: this.dialogConfig.maxWidth,
      disableClose: true,
      data: { action: 'Dark Web Observation', label: 'Dark Web Observation Details', data: _data },
    });
  }
  getTopMawlareFilter() {
    this.dcs.resetPagerInfo();
    this.isImpactSelected = true;
    this.switchListTab(this.tabConfig.stb);
  }
  getTopPhishingFilter() {
    this.dcs.resetPagerInfo();
    this.isImpactSelected = true;
    this.switchListTab(this.tabConfig.stb);
  }
  resetDefDate() {
    this.filterOpt.date.isDateRange = false;
    this.filterOpt.date.defDV = 90;
    this.filterOpt.date.defDL = this.ds.getQuickDateOptions();
    this.filterOpt.date.fd = this.dcs.getDayDiff(this.filterOpt.date.defDV);
    this.filterOpt.date.td = new Date();
  }
  sortBy(sort: string, category: string) {
    if (sort === 'date') {
      if (category === 'top-news-incident-and-attacks' || category === 'top-geography-industry-and-technology') {
        this.isDateSort = !this.isDateSort;
        if (this.tabConfig.stb === 'Client' && this.relatedCat === 'Related News') {
          this.getClientRelatedFilter(this.pType, this.relatedCat);
        } else if (this.tabConfig.stb === 'Client' && this.topGeoCat === 'Related News') {
          this.getTopGeoClientRelated(this.pType, this.topGeoCat);
        } else if (this.tabConfig.stb === 'Client' && this.vulClientCat === 'Asset Related Vulnerabilities') {
          this.getClientVulnListByCategory(this.params.category, this.vulClientCat);
        } else if (this.tabConfig.stb === 'Client' && this.vulClientCat === 'Reported Vulnerabilities') {
          this.getClientVulnListByCategory(this.params.category, this.vulClientCat);
        } else {
          this.switchListTab(this.tabConfig.stb);
        }
      }
    }
  }
  //   sorting in client view
  sortByClient(sort: string, pType: string) {
    if (sort === 'date') {
      if (pType === 'top-malware') {
        this.isDateSort = !this.isDateSort;
        this.sortByMalware();
      } else if (pType === 'top-phishing') {
        this.isDateSort = !this.isDateSort;
        this.sortByPhishing();
      }
    }
  }

  checkVulnAssetWithComment() {
    //  this.vul_based_filter['isAssetComment'] = true;
    this.topListData = [];
    this.assetCommentsset.clear();
    this.isAssetCommentflag = true;
    const req: any = {
      page: 0,
      size: 20000,
      sort: ['createddate,DESC'],
    };
    this.dcs.setAjexStatus(true);
    const dbmonitor = 0;
    this.orgAssetsService.getAssetsWithcomment(this.clientId, dbmonitor, req, this.assetType).subscribe(
      res => {
        // this.dcs.setAjexStatus(false);
        this.orgAssetsList = res.body;
        for (const data of this.orgAssetsList) {
          if (data.comments) {
            if (data.comments !== '' && !this.assetCommentsset.has(data.comments.toUpperCase())) {
              this.assetCommentsset.add(data.comments.toUpperCase());
            }
          }
        }
      },
      (err: HttpErrorResponse) => this.onError(err)
    );
  }

  getAllvulwithAssetcomment(cate: string, assetComment: string) {
    if (this.pType === 'vulnerabilities') {
      this.pType = 'top-vulnerability-and-exploit';
    }
    //  this.vul_based_filter.isVendor = false;
    //  this.vul_based_filter.isAsset = false;
    //  this.vul_based_filter.isVersionOnly = false;
    this.vul_based_filter.isAssetComment = true;
    const fromDatelocal = new Date(this.filterOpt.date.fd + 'Z');
    const toDatelocal = new Date(this.filterOpt.date.td + 'Z');
    const currentDate = new Date();
    toDatelocal.setDate(toDatelocal.getDate() + 1);
    if (currentDate.getTime() === toDatelocal.getTime()) {
      toDatelocal.setDate(toDatelocal.getDate() - 1);
    }
    this.resetDefDate();
    const listReqObj = {
      type: this.pType,
      fd: fromDatelocal,
      td: toDatelocal,
      clientId: this.clientId,
    };
    const pagerReq = {
      page: this.cpi,
      size: this.size === 5 ? 5 : 200,
    };
    this.vulnPrdSearch = '';
    this.impact = '';
    const category = cate.toUpperCase();
    this.dcs.setAjexStatus(true);
    if (pagerReq.page !== 0) {
      pagerReq.page = pagerReq.page - 1;
    }
    //  tslint:disable-next-line:max-line-length
    this.ctds
      .getThreatViewByCategory(
        listReqObj.type,
        listReqObj.clientId,
        listReqObj.fd.getTime(),
        listReqObj.td.getTime(),
        category,
        this.vulnPrdSearch,
        this.impact,
        pagerReq,
        null,
        this.isDateSort,
        null!,
        null!,
        null!,
        null!,
        this.vul_based_filter.isAsset,
        this.vul_based_filter.isAttackSurface,
        this.vul_based_filter.isVersionOnly,
        null!,
        this.vul_based_filter.isVendor,
        this.vul_based_filter.isAssetComment,
        this.assetCommets
      )
      ?.subscribe(
        (response: HttpResponse<any[]>) => {
          this.dcs.setAjexStatus(false);
          this.topListData = response.body;
          const totalItems: any = response.headers.get('X-Total-Count');
          this.dcs.setTotalRecords(totalItems, this.topListData.length, pagerReq.size);
        },
        (error: HttpErrorResponse) => this.onError(error)
      );
  }

  resetAll() {
    this.dcs.resetPagerInfo();
    this.dcs.setTotalRecords(0, 0, 0);
    this.cpi = 0;
    this.vulnPrdSearch = '';
    this.vul_based_filter.isAssetComment = false;
    this.assetCommets = '';
    this.searchCampaign = '';
    this.searchPhishing = '';
    this.searchMalware = '';
  }

  resetProduct() {
    this.vulnPrdSearch = '';
    this.vul_based_filter.isAssetComment = false;
    this.assetCommets = '';
    this.switchListTab(this.tabConfig.stb);
  }

  resetCampaign() {
    this.searchCampaign = '';
    this.searchPhishing = '';
    this.searchMalware = '';
    this.switchListTab(this.tabConfig.stb);
  }
  resetRansome() {
    this.searchRansome = '';
    // this.switchListTab(this.tabConfig.stb);
    this.switchTab(this.ransomwareTab);
  }
  checkCritical(data: any): boolean {
    return this.dcs.checkForCriticalItem(data);
  }
  //  navigate back to dahsboard
  goBack(action?: string) {
    // history.back();
    this.router.navigate(['cap/tvi']);
  }

  openPopup(event: any) {
    if (event?.target) {
      const searchedData = {
        searchedItem: event.target.innerHTML,
        key: event.target.classList[event.target.classList.length - 1],
      };
      if (searchedData.key === 'TA') {
        searchedData.key = 'Threat Actor';
      }
      if (searchedData.key === 'Campaign') {
        this.ds.searchKeywords(searchedData.key, searchedData.searchedItem, 'CIA');
      } else {
        this.ds.searchKeywords(searchedData.key, searchedData.searchedItem, 'TVI');
      }
    }
  }

  private onError(error: HttpErrorResponse) {
    console.error(error);
    this.dcs.resetPagerInfo();
    this.dcs.setAjexStatus(false);
    if (error.status === 403) {
      this.dialog.closeAll();
      this.dialog.open(MatDialogComponent, {
        width: '318px',
        height: '169px',
        disableClose: false,
        panelClass: 'msgpov',
        data: { action: 'MSGPOV', message: 'res.body.message' },
      });
    }
  }

  ngOnDestroy() {
    if (this.pagerSubscription) {
      this.pagerSubscription.unsubscribe();
    }
    if (this.clientSubscription) {
      this.clientSubscription.unsubscribe();
    }
  }
  tooltiptextCopy(text: any) {
    const selBox = document.createElement('textarea');
    selBox.style.position = 'fixed';
    selBox.style.left = '0';
    selBox.style.top = '0';
    selBox.style.opacity = '0';
    selBox.value = text;
    document.body.appendChild(selBox);
    selBox.focus();
    selBox.select();
    document.execCommand('copy');
    document.body.removeChild(selBox);
  }
  tooltiptext(str: any) {
    if (str) {
      const arr = str.split('');
      for (let i = 1; i <= arr.length; i++) {
        if (i % 40 === 0) {
          arr[i] = arr[i] + '\n';
        }
      }
      return arr.join('');
    } else {
      return str;
    }
  }
  validURL(str: any) {
    const pattern = new RegExp(
      '^(https?:\\/\\/)?' +
      '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|' +
      '((\\d{1,3}\\.){3}\\d{1,3}))' +
      '(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*' +
      '(\\?[;&a-z\\d%_.~+=-]*)?' +
      '(\\#[-a-z\\d_]*)?$',
      'i'
    );
    return !!pattern.test(str);
  }
  getRansomeWareClient() {
    //  this.dcs.resetPagerInfo();
    //  this.cpi = 0;
    const pagerReq = {
      page: this.cpi,
      size: this.size,
      sort: ['date,DESC'],
    };
    if (pagerReq.page !== 0) {
      pagerReq.page = pagerReq.page - 1;
    }
    this.dcs.setAjexStatus(true);
    this.ctds.getDWClientFilterData(this.clientId, pagerReq).subscribe(
      (res: HttpResponse<any>) => {
        this.dcs.setAjexStatus(false);
        //  this.ransomeListData.ransomware = res.body;
        // console.log(res, 'getRansomewaredata');
        this.ransomeListClientData = res.body;
        const totalItems: any = res.headers.get('X-Total-Count');
        this.dcs.setTotalRecords(totalItems, this.ransomeListClientData.length, pagerReq.size);
        this.setBlurRecords('ransomclntable');
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }



  loadClientGITData() {
    const pageReq: any = {
      page: 0,
      size: 1000,
      sort: ['id,ASC'],
    };
    this.dcs.setAjexStatus(true);
    this.ctds.getDWClientFilterData(this.clientId, pageReq).subscribe(
      (res: HttpResponse<any>) => {
        console.log(res);
        // const data = res.body;
        this.ransomewarelist = res.body;
        for (let i in this.ransomewarelist) {
          let tempindustriesArr = this.ransomewarelist[i].industries.toString();
          this.ransomewarelist[i].industries = tempindustriesArr.replace(/,[m]*/g, ', ');

          let tempgeographiesArr = this.ransomewarelist[i].geographies.toString();
          this.ransomewarelist[i].geographies = tempgeographiesArr.replace(/,[u]*/g, ', ');

        }
        this.searchRansomwareData();
        for (let i = 0; i < this.ransomewarelist.length; i++) {
          if (this.ransomewarelist[i] === 'Geography') {
            this.gitFilterInfo['geography'].list.push({ name: this.ransomewarelist[i].value });
          } else if (this.ransomewarelist[i] === 'Industry') {
            this.gitFilterInfo['industry'].list.push({ name: this.ransomewarelist[i].value });
            console.log(this.gitFilterInfo['industry']);
          }
        }
      },
      (error: HttpErrorResponse) => this.onError(error)
    );
  }

  getDWSelectedTab(category: any): void {
    if (category === 'early-warnings') {
      this.dwSelectedTab = 'early-warnings';
    } else if (category === 'dw-observation') {
      this.dwSelectedTab = `dw-${this.dwTab.toLowerCase()}`;
    } else if (category === 'ransomeware') {
      this.dwSelectedTab = `ransomware-${this.ransomwareTab.toLowerCase()}`
    } else {
      this.dwSelectedTab = 'early-warnings';
    }
  }

  openTVTopListDialogBox(){
    this.dialog.open(MalwareDateDailogComponent, {
      width: "1000px",
      height: "550px",
      //maxWidth: this.dialogConfig.maxWidth,
      //disableClose: true,
      //data: { action: _ld.type, label: _ld.type, data: _data },
    });
  }
}





















